一、web基础
 - Html 展现web内容
 - Css  内容展现的样式
 - JavaScript 给页面添加一些动作，或者对页面的一些操作

二、Html基础
1、Html 网页结构
 - 基本格式
	<!DOCTYPE html>
	<html>
		<head>
			<meta charset="utf-8" />
			<title>页面标题</title>           
		</head>
		<body>
			<h1>标题1</h1>
			<p>段落1</p>
			<script type="text/javascript">
				alert("Holle")
				confirm("World")
				prompt("请输入")
			</script>
		</body>
	</html>

2、标签与元素
 - Html标签  https://www.runoob.com/tags/ref-byfunc.html
	html
	head
	title
	body
	h1
	p
 - Html元素
	- Html元素指一个具体的标签实例，下面有2个Html元素，都是h标签
		<h1>这是一个标题</h1>
		<h1>这是另一个标题</h1>
	- 整个网页就是由这些标签组成的Html元素嵌套组成

3、元素语法
 - <tag att1=v1 attr2=v2>内容</tag>
 - 每种标签都有自己的一组属性，属性分为2类
	- 全局属性: 所有标签都有的属性  https://www.runoob.com/tags/ref-standardattributes.html
		id 定义元素的唯一id
		class 为html元素定义一个或多个类名（classname）(类名从样式文件引入)
		style 规定元素的行内样式（inline style）
		title 描述了元素的额外信息 (作为工具条使用)
	- 标签属性: 每种标签肯能还有一些该标签才特有的一些属性
		href 需要有引用的属性的标签才有这个属性, 比如 链接(a标签) 和 图片(img标签)

4、常用标签
 - 基础标签
	<h1> to <h6>  定义 HTML 标题
	<p>	          定义一个段落
	<br>	      定义简单的折行
	<hr>	      定义水平线
	<!--...-->	  定义一个注释
 - 文本标签
	<del> 定义被删除文本
	<i>   定义斜体文本
	<ins> 定义被插入文本
	<sub> 下标文字
	<sup> 上标文字
	<u>   下划线文本
 - 表单标签
	<form>
	<input>
	...
 - 常见元素
	<iframe> 嵌套外部网页
	<img>    展示图像
	<area>   标签定义图像映射内部的区域: https://www.runoob.com/try/try.php?filename=tryhtml_areamap
	<a>      链接标签
	<ul>     定义一个无序列表
	<ol>     定义一个有序列表
	<li>   定义一个列表项
 - 表格
	<table>  标签定义 HTML 表格, 一个 HTML 表格包括 <table> 元素，一个或多个 <tr>、<th> 以及 <td> 元素。
	<tr>     元素定义表格行，
	<th>     元素定义表头，
	<td>     元素定义表格单元
 - 容器元素
	<div>    标签定义 HTML 文档中的一个分隔区块或者一个区域部分，标签常用于组合块级元素，以便通过 CSS 来对这些元素进行格式化
	<span>   用于对文档中的行内元素进行组合，标签提供了一种将文本的一部分或者文档的一部分独立出来的方式

5、元素id
 - 标识该元素的唯一身份，并且可以在其他地方引用
	- 通过a标题跳转到指定的位置:
		<p>
		<a href="#C4">查看章节 4</a>
		</p>
		<h2>章节 1</h2>
		<p>这边显示该章节的内容……</p>
		<h2>章节 2</h2>
		<p>这边显示该章节的内容……</p>
		<h2>章节 3</h2>
		<p>这边显示该章节的内容……</p>
		<h2><a id="C4">章节 4</a></h2>
		<p>这边显示该章节的内容……</p>
 - id 也是js操作元素的重要依据之一
	document.getElementById('C4')
	<a id=​"C4">​章节 4​</a>

6、元素的样式
 - 通过元素的style属性可以控制该元素的样式
	- 把p元素里面的这段话的字体加大, 演示改为红色
		<p style="color:red;font-size:20px;">这边显示该章节的内容……</p>
		- 语法的格式
			key: value;
			- 分号分开的就是一个样式条目，可以为一个元素添加很多样式，详情见Css
	- 控制元素的宽和高
		<iframe src="https://www.runoob.com" sytle="height: 200px;width: 400px;">
			<p>您的浏览器不支持  iframe 标签。</p>
		</iframe>

7、脚本
 - 一个静态页面具有元素和样式，页面加载完成后，如果要动态修改里面的元素，就需要用到Javascript脚本
	<script> 标签用于定义客户端脚本，比如 JavaScript
	<script> 元素既可包含脚本语句，也可通过 src 属性指向外部脚本文件
 - 示例
	- 引入脚本
		// 通过src 网络引入
		<script src="https://cdn.jsdelivr.net/npm/vue@2.6.14"></script>
		// 通过本地文件引入
		<script>
			import axios from 'axios';
		</script>
	- JavaScript 最常用于图片操作、表单验证以及内容动态更新
		<script>
		c4 = document.getElementById('C4')
		// <a id=​"C4">​章节 4​</a>​
		c4.innerText
		// '章节 4'
		c4.innerText = '章节 5'
		// '章节 5'
		</script>


三、Css基础


四、Javascript基础
1、JavaScript 运行时
	- 浏览器
		NodeJS
	- $ node -v
		v14.17.1

2、数据类型
 - JavaScript中的数据类型
	- Number
	- 字符串
	- 布尔值
	- 数组 []
		- JavaScript的Array可以包含任意数据类型，并通过索引来访问每个元素
			var arr  = new Array(1, 2, 3);                          // 创建数组arr1[1, 2, 3]
			var arr2 = [1, 2, 3.14, 'Hello', null, true];
			console.log(typeof(arr), arr)                           // object (3) [1, 2, 3]
			- 越界不报错
				arr[0]  // 1
				arr[3]  // undefined
				// 如果通过索引赋值时，索引超过了范围，统一可以赋值
				arr[5] = 5
				arr     // [1, 2, 3, 4, empty, 5]
		- push和pop
			- push() 向Array的末尾添加若干元素，并返回数组长度
				arr.push('A', 'B')
			- pop()  把Array的最后一个元素删除掉，并返回删除元素的值
				arr.pop()
			- 空数组继续pop不会报错，而是返回undefined
		- unshift和shift
			- unshift() 往Array的头部添加若干元素，并返回数组长度
				arr.unshift('A', 'B')
			- shift()   把Array的第一个元素删掉
				arr.shift()
			- 空数组继续shift不会报错，而是返回undefined
		- splice
			- splice() 可以从指定的索引开始删除若干元素，然后再从该位置添加若干元素
				var arr = ['Microsoft', 'Apple', 'Yahoo', 'AOL', 'Excite', 'Oracle'];
				// 从索引2开始删除3个元素,然后再添加两个元素:
				arr.splice(2, 3, 'Google', 'Facebook');    // 返回删除的元素 ['Yahoo', 'AOL', 'Excite']
				arr;                                       // ['Microsoft', 'Apple', 'Google', 'Facebook', 'Oracle']
				// 只删除,不添加:                          
				arr.splice(2, 2);                          // ['Google', 'Facebook']
				arr;                                       // ['Microsoft', 'Apple', 'Oracle']
				// 只添加,不删除:                          
				arr.splice(2, 0, 'Google', 'Facebook');    // 返回[],因为没有删除任何元素
				arr;                                       // ['Microsoft', 'Apple', 'Google', 'Facebook', 'Oracle']
		- sort和reverse
			- concat() 把当前的Array和另一个Array连接起来，并返回一个新的Array
				var arr = ['A', 'B', 'C'];
				var added = arr.concat([1, 2, 3]);
				added;                             // ['A', 'B', 'C', 1, 2, 3]
			- slice()  截取Array的部分元素，然后返回一个新的Array (对应String的substring()版本)
				var arr = ['A', 'B', 'C', 'D', 'E', 'F', 'G'];
				arr.slice(0, 3);                   // 从索引0开始，到索引3结束，但不包括索引3: ['A', 'B', 'C']
				arr.slice(3);                      // 从索引3开始到结束: ['D', 'E', 'F', 'G']
				// 如果不给slice()传递任何参数，它就会从头到尾截取所有元素。利用这一点，我们可以很容易地复制一个Array
				var aCopy = arr.slice();
				aCopy;                             // ['A', 'B', 'C', 'D', 'E', 'F', 'G']
				aCopy === arr;                     // false
		- Vue中的数组
			- Vue 将被侦听的数组的变更方法进行了包裹，所以它们也将会触发视图更新
				- 这些被包裹过的方法包括: 
					push()
					pop()
					shift()
					unshift()
					splice()
					sort()
					reverse()	
	- 对象 字典 Object {}
		- JavaScript的对象是一种无序的集合数据类型，它由若干键值对组成
			obj  = new Object()
			obj2 = {}
		- 由于JavaScript的对象是动态类型，可以自由地给一个对象添加或删除属性
			- 未定义的属性不报错
				obj.a = 1  
				obj.a          // 1
				obj.b          // undefined
				obj.b = 2     
				obj.b          // 2
				// 删除b属性
				delete obj1.b
				delete obj1.b  // 删除一个不存在的c属性也不会报错
		- hasOwnProperty
			- hasOwnProperty() 判断对象是否有该属性
				obj.hasOwnProperty('b')  // false
 - null和undefined
	- null表示一个空的值，而undefined表示值未定义
		var a = {a: 1}
		a.b             // undefined
		a.b = null
		a.b             // null
 - 逻辑运算符
	&& 与运算
	|| 或运算
	!  非运算
 - 关系运算符
	- JavaScript在设计时，有两种比较运算符
		==    它会自动转换数据类型再比较，很多时候，会得到非常诡异的结果
		===   它不会自动转换数据类型，如果数据类型不一致，返回false，如果一致，再比较
			false == 0; // true
			false === 0; // false

3、变量
 - var申明
	- var  变量提升，即 无论声明在何处，都会被提至其所在作用域的顶部
 - 局部变量声明
	- let  无变量提升，即 未到let声明的语句时，是无法访问该变量的
		{ let a1 = 20 }
		a1                // a1 is not defined
 - 申明常量
	- const: 无变量提升，声明一个基本类型的时候为常量，不可修改
		const c1 = 20
		c1 = 30 // Assignment to constant variable
	- 声明对象可以修改
		const c1 = 30
 - 变量提升
	- JavaScript的函数定义有个特点，它会先扫描整个函数体的语句，把所有申明的变量"提升"到函数顶部
		function foo() {
			var x = 'Hello, ' + y;
			console.log(x);
			var y = 'Bob';
		}
		// JavaScript引擎看到的代码相当于
		function foo() {
			var y; // 提升变量y的申明，此时y为undefined
			var x = 'Hello, ' + y;
			console.log(x);
			y = 'Bob';
		}
		- js里面 变量都定义在顶部，并且大量使用let来声明变量
 - 解构赋值
	- 数组属性是index，解开可以直接和变量对应
		let [x, [y, z]] = ['hello', ['JavaScript', 'ES6']];
	- 对象解开后是属性，可以直接导出需要的属性
		var person = {
			name: '小明',
			age: 20,
			gender: 'male',
			passport: 'G-12345678',
			school: 'No.4 middle school'
		};
		var {name, age, passport} = person;
		name                                // '小明'
		age                                 // 20
		passport                            // 'G-12345678'
		
4、字符串
 - 声明
	- JavaScript的字符串就是用''或""括起来的字符表示
		str  = 'str'
		str2 = "str"
 - 字符串转义
	- 使用转义符  \
		'I\'m \"OK\"!';     // `I'm "OK"!`
 - 多行字符串
		ml = `这是一个
		多行
		字符串`;            // '这是一个\n多行\n字符串'
 - 字符串模版
	- 格式: 使用``表示的字符串 可以使用${var_name} 来实现变量替换
		var name = '小明'
		var age = 20
		console.log(`你好, ${name}, 你今年${age}岁了！`)   // 你好, 小明, 你今年20岁了！
 - 字符串拼接
	- 直接使用+号
		'aa' + 'bb'         // 'aabb'
		'aa' + 123          // 'aa123'  注意字符串加数字 = 字符串
 - 常用操作
	str.toUpperCase() 把一个字符串全部变为大写
	str.toLowerCase() 把一个字符串全部变为小写
	str.toString()    把类型转换成字符串
	parseInt(str)     把字符串转换成Int
	parseFloat(str)   把字符串转换成Float

5、错误处理
 - 定义
	- 程序处理的逻辑有问题，导致代码执行异常
		- 示例
			var s = null
			s.length 
			// VM1760:1 Uncaught TypeError: Cannot read property 'length' of null
			//     at <anonymous>:1:3
		- 如果在一个函数内部发生了错误，它自身没有捕获，错误就会被抛到外层调用函数
		- 如果外层函数也没有捕获，该错误会一直沿着函数调用链向上抛出，直到被JavaScript引擎捕获，代码终止执行
		- 可以判断s的合法性，在保证安全的情况下，捕获异常，阻断其往上传传递
			if (s !== null) {s.length}
	- try catch
		- 示例
			try { s.length } catch (e) {console.log('has error, '+ e)}
			// VM2371:1 has error, TypeError: Cannot read property 'length' of null
		- 完整的{try ... catch ... finally}语句
			try {
				...
			} catch (e) {
				...
			} finally {
				...
			}
			try: 捕获代码块中的异常
			catch: 出现异常时需要执行的语句块
			finally: 无论成功还是失败 都需要执行的代码块
	- 常见实用案例 loading
 - 错误类型
	- javaScript有一个标准的Error对象表示错误
		err = new Error('异常情况')
		err 
		// <!-- Error: 异常情况
		//     at <anonymous>:1:7 -->
		err instanceof Error
		// true
 - 抛出错误
	- 程序也可以主动抛出一个错误，让执行流程直接跳转到catch块
	- 抛出错误使用throw语句
		throw new Error('抛出异常')
		// VM3447:1 Uncaught Error: 抛出异常
		//     at <anonymous>:1:7
		// (anonymous) @ VM3447:1

6、命名空间
 - JavaScript中的命名空间
	- JavaScript默认有一个全局对象window，全局作用域的变量实际上被绑定到window的一个属性
	- 不在任何函数内定义的变量就具有全局作用域
 - 全局作用域与window
	- 示例一
		alert("hello")
		// 等价于
		window.alert("hello")
	- 示例二
		var a = 10
		a // 10
		window.a // 10
	- 示例三
		- 由于函数定义有两种方式
			- 以变量方式var foo = function () {}定义的函数也是一个全局变量
			- 顶层函数的定义也被视为一个全局变量，并绑定到window对象
	- 示例四
		- 甚至可以覆盖掉浏览器的内置方法
			alert = () => {console.log("覆盖alert方法")}
			alert()                                      // 覆盖alert方法
 - 命名空间与 export
	- 可以将所有方法绑定到一个变量上暴露出去，避免全局变量的混乱
	- 许多著名的JavaScript库都采用这种方法，如: jQuery，YUI，underscore等等
		- 示例
			// 唯一的全局变量MYAPP:
			var MYAPP = {};
			// 其他变量:
			MYAPP.name = 'myapp';
			MYAPP.version = 1.0;
			// 其他函数:
			MYAPP.foo = function () {
				return 'foo';
			};
			export MYAPP
		- 示例 其他文件中
			import { MYAPP } from './export';

7、函数
 - JavaScript中的函数签名
	function abs(x) {
		if (x >= 0) {
			return x;
		} else {
			return -x;
		}
	}
	- function指出这是一个函数定义
	- abs是函数的名称
	- (x)括号内列出函数的参数，多个参数以,分隔
	- { ... }之间的代码是函数体，可以包含若干语句，甚至可以没有任何语句
 - 方法
	- 绑定方法
		var person = {name: '小明', age: 23}
		person.greet = function() {
			console.log(`hello, my name is ${this.name}`)
		}
		person.greet()
	- this 
		- 注意this的使用，没有绑带在对象上, this 指的是 浏览器的window对象
			var person = {name: '小明', age: 23}
			person.greetfn = function() {
				return function() {
					console.log(`hello, my name is ${this.name}`)
				}
			}
			person.greetfn()()                                   // hello, my name is undefined
		- 此时需要通过一个变量 + 闭包，把当前this传递过去，确保this正常传递
			var person = {name: '小明', age: 23}
			person.greetfn = function() {
				var that = this                                  // js中的特殊用法
				return function() {
					console.log(`hello, my name is ${that.name}`)
				}
			}
			person.greetfn()()                                   // hello, my name is 小明
 - 箭头函数(匿名函数)
	- 箭头函数语法
		(params ...) => { ... }
		- 示例一
			fn = x => x * x
			console.log(fn(10))  // 100
		- 示例二
			x => x * x
			// 等价于下面这个函数
			function (x) {
				return x * x;
			}
		- 示例三
			- 箭头函数看上去是匿名函数的一种简写，但实际上，箭头函数和匿名函数有个明显的区别
				- 箭头函数内部的this是词法作用域，由上下文确定
					var person = {name: '小明', age: 23}
					person.greetfn = function() {
						return () => {
							// this 继承自上层的this
							console.log(`hello, my name is ${this.name}`)
						}
					}
		- 示例四
			axios
			.get('http://localhost:8050/hosts', {params: this.query})
			.then(response => {
				console.log(response)
				this.tableData = response.data.data.items
				this.total = response.data.data.total
				console.log(this.tableData)
			})
			.catch(function (error) { // 请求失败处理
				console.log(error);
			});

8、条件判断
 - 语法格式
	if (condition) {
		...
	} else if (condition) {
		...
	} else {
		...
	}
	- 注意条件需要加上括号，其他和Go语言的if一样

9、for 循环
 - 语法格式
	for (初始条件; 判断条件; 修改变量) {
		...
	}
	- 注意条件需要加上括号
 - for in (不推荐使用)
	- for循环的一个变体是for ... in循环，它可以把一个对象的所有属性依次循环出来
		- 遍历对象: 遍历出来的属性是元素的key
			var o = {
				name: 'Jack',
				age: 20,
				city: 'Beijing'
			};
			for (var key in o) {
				console.log(key);            // 'name', 'age', 'city'
			}
		- 遍历数组: 一个Array数组实际上也是一个对象，它的每个元素的索引被视为一个属性
			var a = ['A', 'B', 'C'];
			for (var i in a) {
				console.log(i);              // '0', '1', '2'
				console.log(a[i]);           // 'A', 'B', 'C'
			}
		- 缺陷
			- 当手动给Array对象添加了额外的属性后，for ... in循环将带来意想不到的意外效果
				var a = ['A', 'B', 'C'];
				a.name = 'Hello';
				for (var x in a) {
					console.log(x);     // '0', '1', '2', 'name'
				}
			- 这和for in的遍历机制相关: 遍历对象的属性名称
			- 使用 for of 解决这个问题
 - for of
	- for ... of循环则修复了这些问题，它只循环集合本身的元素
		var a = ['A', 'B', 'C'];
		a.name = 'Hello';
		for (var x of a) {
			console.log(x);             // 'A', 'B', 'C'
		}
	- 但是for ... of循环不可用直接遍历对象，可以通过Object提供的方法获取key数组，然后遍历
		var o = {
			name: 'Jack',
			age: 20,
			city: 'Beijing'
		};
		for (var key of Object.keys(o)) {
			console.log(key);                // 'name', 'age', 'city'
		}
 - forEach方法
	- forEach()方法是ES5.1标准引入的，是遍历元素的一种常用手段，能作用于可迭代对象上，和for of一样
		arr.forEach(function(item) {console.log(item )})
		arr.forEach((item) => {console.log(item)})
 - for循环应用
	- 如果后端返回的数据不满足展示的需求，需要修改，比如vendor想要友好显示，就可以直接修改数据
	
10、Promise对象
 - 在JavaScript的世界中，所有代码都是单线程执行的
	- 由于这个"缺陷"，导致JavaScript的所有网络操作，浏览器事件，都必须是异步执行
	- Javascript通过回调函数实现异步，js的一大特色
 - 单线程异步模型
	function callback() {
		console.log('Done');
	}
	console.log('before setTimeout()');
	setTimeout(callback, 1000);         // 1秒钟后调用callback函数
	console.log('after setTimeout()');
	// before setTimeout()
	// after setTimeout()
	// 等待一秒后
	// Done
 - Promise与异步
	- Promise
		interface PromiseConstructor {
			/**
			* Creates a new Promise.
			* @param executor A callback used to initialize the promise. This callback is passed two arguments:
			* a resolve callback used to resolve the promise with a value or the result of another promise,
			* and a reject callback used to reject the promise with a provided reason or error.
			*/
			new <T>(executor: (resolve: (value: T | PromiseLike<T>) => void, reject: (reason?: any) => void) => void): Promise<T>;
		}
	- 测试一个函数，resolve是成功后的回调函数，reject是失败后的回调函数
		function testResultCallbackFunc(resolve, reject) {
			var timeOut = Math.random() * 2;
			console.log('set timeout to: ' + timeOut + ' seconds.');
			setTimeout(function () {
				if (timeOut < 1) {
					console.log('call resolve()...');
					resolve('200 OK');
				}
				else {
					console.log('call reject()...');
					reject('timeout in ' + timeOut + ' seconds.');
				}
			}, timeOut * 1000);
		}
		function testResultCallback() {
			success = (message) => {console.log(`success ${message}`)}
			failed = (error) => {console.log(`failed ${error}`)}
			testResultCallbackFunc(success, failed)
		}
	- 将回调改为Promise对象，而Promise的优势在于异步执行的流程中，把执行代码和处理结果的代码清晰地分离
		var p1 = new Promise(testResultCallbackFunc)  // 执行testResultCallbackFunc函数
		p1.then((resp) => {                           // 分析结果
			console.log(resp)
		}).catch((err) => {
			console.log(err)
		})
 - Async函数 + Promise组合
	- Async函数由内置执行器进行执行, 这和go func() 有异曲同工之妙
	- 如果声明一个异步函数，在函数前面加上一个 async关键字
		async function testWithAsync() {                        // async调用协程
			var p1 = new Promise(testResultCallbackFunc)        // new是将函数构造成一个对象
			try {
				var resp = await p1                             // await等待promise的结果
				console.log(resp)
			} catch (err) {
				console.log(err)
			}
		}
	- 这里testWithAsync就是一个异步函数，在执行的时候 是交给js的携程执行器处理的
	- 而 await关键字就是 告诉执行器当p1执行完成后，主动通知下(协程的一种实现)
	- 其实就是一个 event pool模型(简称epool模型)

11、关于JavaStript的总结
 - 推荐使用箭头函数
 - 判断使用 ===
 - 由于变量提升问题，尽量使用let声明变量，并且写在开头
 - for循环推荐forEach

五、浏览器基础