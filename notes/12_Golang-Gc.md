# Golang-Gc  Golang的Gc

## 一、经典的GC算法

### 1、引用计数(reference counting)
- 它是最简单的一种垃圾回收算法，和之前提到的智能指针异曲同工

- 实现方式
	- 对每个对象维护一个引用计数，当引用该对象的对象被销毁或更新时被引用对象的引用计数自动减一，当被引用对象被创建或被赋值给其他对象时引用计数自动加一
	- 当引用计数为0时则立即回收对象
	- 这种方法的优点是实现简单，并且内存的回收很及时

- 这种算法在内存比较紧张和实时性比较高的系统中使用的比较广泛，如ios cocoa框架，php，python等

- 简单引用计数算法也有明显的缺点
	- 频繁更新引用计数降低了性能
		- 一种简单的解决方法就是编译器将相邻的引用计数更新操作合并到一次更新
		- 还有一种方法是针对频繁发生的临时变量引用不进行计数，而是在引用达到0时通过扫描堆栈确认是否还有临时对象引用而决定是否释放
	- 循环引用问题
		- 当对象间发生循环引用时引用链中的对象都无法得到释放
		- 最明显的解决办法是避免产生循环引用，如cocoa引入了strong指针和weak指针两种指针类型
		- 或者系统检测循环引用并主动打破循环链，但这也增加了垃圾回收的复杂度

### 2、标记-清除(mark&sweep)
- 实现方式
	- 标记(Mark phase)，从根变量开始迭代得所有被引用的对象，对能够通过应用遍历访问到的对象都进行标记为"被引用" 
	- 清除(Sweep phase)，标记完成后进行清除操作，对没有标记过的内存进行回收(回收同时可能伴有碎片整理操作)

- 这种方法解决了引用计数的不足，但是也有比较明显的问题
	- STW(stop the world)，让程序暂停，程序出现卡顿
	- 标记需要扫描整个heap
	- 清除数据会产生heap碎片
	- 每次启动垃圾回收都会暂停当前所有的正常代码执行，回收使系统响应能力大大降低
	- 后续也出现了很多mark&sweep算法的变种(如三色标记法)优化了这个问题

### 3、分代收集(generation)
- 经过大量实际观察得知，在面向对象编程语言中，绝大多数对象的生命周期都非常短

- 实现方式
	- 分代收集的基本思想是，将堆划分为两个或多个称为 代(generation)的空间
	- 新创建的对象存放在称为 新生代(young generation)中(一般来说，新生代的大小会比 老年代小很多)
	- 随着垃圾回收的重复执行，生命周期较长的对象会被 提升(promotion)到老年代中
	- 因此，新生代垃圾回收和老年代垃圾回收两种不同的垃圾回收方式应运而生，分别用于对各自空间中的对象执行垃圾回收
	- 新生代垃圾回收的速度非常快，比老年代快几个数量级，即使新生代垃圾回收的频率更高，执行效率也仍然比老年代垃圾回收强，这是因为大多数对象的生命周期都很短，根本无需提升到老年代

### 4、复制收集(CopyandCollection)


## 二、Golang中的Gc算法

### 1、历史回顾
- go语言垃圾回收总体采用的是 标记-清除(mark&sweep) 算法

- v1.1 STW

- v1.3 Mark STW, Sweep 并行

- v1.5 三色标记法

- v1.8 hybrid write barrier 混合写屏障 + 三色标记法

- golang 的 GC 不断的提升并发性能并且**减少STW (Stop The World)**的时间

### 2、v1.1 标记清除算法
- 步骤
	- stw 暂停程序
	- mark 标记可达对象(分类出可对象和不可达对象)
	- sweep 清除不可达对象
	- stw 结束

### 3、v1.3 标记清除算法的优化
- 优化过程
	- 标记清除算法整个 GC 都是在 STW，STW 的时间过长
	- 为了减少 STW 的时间，golang 将 STW 的范围缩小
	- 只在 mark 时 STW，sweep 和程序并发执行

- 步骤
	- stw 暂停程序
	- mark 标记可达对象(分类出可对象和不可达对象)
	- stw 结束
	- 继续处理程序 同时并发 sweep 清除不可达对象

- 缺点
	- 整个的 STW 还是很长，特别是当需要 mark 标记的对象越多，需要 STW 的时间越长

### 4、v1.5 三色标记法
- 三色标记法
	- 动态的滚动式的做 gc，将一次长的 stw 分散到多次短暂的 stw 中去

- 步骤
	- 遍历根对象的第一层可达对象标记为灰色，不可达默认白色
	- 将灰色对象的下一层可达对象标记为灰色，自身标记为黑色
	- 多次重复步骤2，直到灰色对象为0，只剩下白色对象和黑色对象
	- sweep 白色对象

- 三色标记对象丢失
	- 如果 gc 期间不 stw 的话有可能对象丢失
		- 即 一个黑色对象在 gc 期间链接了白色对象，白色对象又没有任何的灰色对象可达就会导致对象的丢失
	- 解决思路
		- 对象丢失是在GC里面绝对不被允许的，可以暂时存在垃圾但是不能丢失
		- 所以还是要 STW，为了解决这个 STW 的问题，引入了强三色不变式和弱三色不变式，只要满足强三色不变式和弱三色不变式的任意一种就能解决 STW 的问题
			- 强三色不变式: 一个黑色对象在 gc 期间链接了白色对象
			- 弱三色不变式: 黑色对象链接的白色对象又没有任何的灰色对象可达

### 5、v1.8 三色标记法 + 写屏障
- 写屏障
	- 该屏障之前的写操作和之后的写操作相比，先被系统其它组件感知
	- 即 在gc跑的过程中，可以监控对象的内存修改，并对对象进行重新标记
	- 实际上也是超短暂的stw，然后对对象进行标记
	- 在上述情况中，新生成的对象，一律都标位灰色

- 步骤
	- STW 扫描栈，将可达对象标记为黑色(混合写屏障也是要STW的，网上很多文章都没说，scan stack 的时候要 STW，只是混合写屏障去掉了 rescan stack 这个步骤，时间在 1ms 左右)
	- gc 期间 stack 创建的对象都是灰色
	- gc 期间在堆添加混合写屏障(链接/删除链接 元素都标记为灰色，屏障会略微减少程序性能，因为会加一层)

- 解决对象丢失问题
	- 一个黑色对象在 gc 期间链接了白色对象
	- 链接对象会经过混合写屏障，新插入白色的元素会标记为灰色
	- 接下来按照三色标记法继续遍历即可

### 6、Golang-GC && Java-GC 的区别
- golang 的 gc 的不断演化通过将 STW 分散化大大减少 STW 的时间

- 最新版本的 golang 的 gc 基本都是在 1ms 以内，但是这样故意的设计是牺牲吞吐量换来的

- gc 的频率会比其他的垃圾回收更高比如 jvm 和 .net高

- go 目前的混合写屏障 + 三色标记标记在 gc 期间的屏障也会给性能带来一定的损耗，但是总体的损耗目前的机器配置完全能 cover
	- go 的开发效率很高
	- go 的主要应用领域不是 cpu 敏感型，在高 IO 的领域有很好的性能
	- go 要避免跟 jvm 和 .net 这样给高吞吐的 gc 正面竞争，才能发挥出 go 超短 stw 的优势

## 三、参考资料
- [Golang GC 垃圾回收机制详解](https://blog.csdn.net/u010649766/article/details/80582153)
- [图解Golang的GC算法](https://studygolang.com/articles/18850?fr=sidebar)
- [golang 垃圾回收 gc 详解](https://blog.csdn.net/jarvan5/article/details/122970491)