一、web基础
 - Html 展现web内容
 - Css  内容展现的样式
 - JavaScript 给页面添加一些动作，或者对页面的一些操作


二、Html基础
1、Html 网页结构
 - 基本格式
	<!DOCTYPE html>
	<html>
		<head>
			<meta charset="utf-8" />
			<title>页面标题</title>           
		</head>
		<body>
			<h1>标题1</h1>
			<p>段落1</p>
			<script type="text/javascript">
				alert("Holle")
				confirm("World")
				prompt("请输入")
			</script>
		</body>
	</html>

2、标签与元素
 - Html标签  https://www.runoob.com/tags/ref-byfunc.html
	html
	head
	title
	body
	h1
	p
 - Html元素
	- Html元素指一个具体的标签实例，下面有2个Html元素，都是h标签
		<h1>这是一个标题</h1>
		<h1>这是另一个标题</h1>
	- 整个网页就是由这些标签组成的Html元素嵌套组成

3、元素语法
 - <tag att1=v1 attr2=v2>内容</tag>
 - 每种标签都有自己的一组属性，属性分为2类
	- 全局属性: 所有标签都有的属性  https://www.runoob.com/tags/ref-standardattributes.html
		id 定义元素的唯一id
		class 为html元素定义一个或多个类名（classname）(类名从样式文件引入)
		style 规定元素的行内样式（inline style）
		title 描述了元素的额外信息 (作为工具条使用)
	- 标签属性: 每种标签肯能还有一些该标签才特有的一些属性
		href 需要有引用的属性的标签才有这个属性, 比如 链接(a标签) 和 图片(img标签)

4、常用标签
 - 基础标签
	<h1> to <h6>  定义 HTML 标题
	<p>	          定义一个段落
	<br>	      定义简单的折行
	<hr>	      定义水平线
	<!--...-->	  定义一个注释
 - 文本标签
	<del> 定义被删除文本
	<i>   定义斜体文本
	<ins> 定义被插入文本
	<sub> 下标文字
	<sup> 上标文字
	<u>   下划线文本
 - 表单标签
	<form>
	<input>
	...
 - 常见元素
	<iframe> 嵌套外部网页
	<img>    展示图像
	<area>   标签定义图像映射内部的区域: https://www.runoob.com/try/try.php?filename=tryhtml_areamap
	<a>      链接标签
	<ul>     定义一个无序列表
	<ol>     定义一个有序列表
	<li>   定义一个列表项
 - 表格
	<table>  标签定义 HTML 表格, 一个 HTML 表格包括 <table> 元素，一个或多个 <tr>、<th> 以及 <td> 元素。
	<tr>     元素定义表格行，
	<th>     元素定义表头，
	<td>     元素定义表格单元
 - 容器元素
	<div>    标签定义 HTML 文档中的一个分隔区块或者一个区域部分，标签常用于组合块级元素，以便通过 CSS 来对这些元素进行格式化
	<span>   用于对文档中的行内元素进行组合，标签提供了一种将文本的一部分或者文档的一部分独立出来的方式

5、元素id
 - 标识该元素的唯一身份，并且可以在其他地方引用
	- 通过a标题跳转到指定的位置:
		<p>
		<a href="#C4">查看章节 4</a>
		</p>
		<h2>章节 1</h2>
		<p>这边显示该章节的内容……</p>
		<h2>章节 2</h2>
		<p>这边显示该章节的内容……</p>
		<h2>章节 3</h2>
		<p>这边显示该章节的内容……</p>
		<h2><a id="C4">章节 4</a></h2>
		<p>这边显示该章节的内容……</p>
 - id 也是js操作元素的重要依据之一
	document.getElementById('C4')
	<a id=​"C4">​章节 4​</a>

6、元素的样式
 - 通过元素的style属性可以控制该元素的样式
	- 把p元素里面的这段话的字体加大, 演示改为红色
		<p style="color:red;font-size:20px;">这边显示该章节的内容……</p>
		- 语法的格式
			key: value;
			- 分号分开的就是一个样式条目，可以为一个元素添加很多样式，详情见Css
	- 控制元素的宽和高
		<iframe src="https://www.runoob.com" sytle="height: 200px;width: 400px;">
			<p>您的浏览器不支持  iframe 标签。</p>
		</iframe>

7、脚本
 - 一个静态页面具有元素和样式，页面加载完成后，如果要动态修改里面的元素，就需要用到Javascript脚本
	<script> 标签用于定义客户端脚本，比如 JavaScript
	<script> 元素既可包含脚本语句，也可通过 src 属性指向外部脚本文件
 - 示例
	- 引入脚本
		// 通过src 网络引入
		<script src="https://cdn.jsdelivr.net/npm/vue@2.6.14"></script>
		// 通过本地文件引入
		<script>
			import axios from 'axios';
		</script>
	- JavaScript 最常用于图片操作、表单验证以及内容动态更新
		<script>
		c4 = document.getElementById('C4')
		// <a id=​"C4">​章节 4​</a>​
		c4.innerText
		// '章节 4'
		c4.innerText = '章节 5'
		// '章节 5'
		</script>


三、Css基础
1、Css的作用
 - 可以通过直接指定style属性来配置 DOM元素的样式
	- <p style="color:red;font-size:20px;">这边显示该章节的内容……</p>
	- 如果一个页面上 有多个元素都是用了这个样式
	- 这是就需要将样式独立出来，单独写到一个保存在外部的 .css 文件中，这就形成了css

2、Css的语法
 - 对所有的p标签 使用下面定义的样式
	/* 这是个注释 */
	p {
	color: red;
	}
 - 选择器，对应p，用于选择样式生效的范围，也就是对那些元素生效
 - 样式属性(style attribute)，也就是具体需要添加的样式，属性有key和value组成，多个属性用';'分开
 - 注释是用来解释你的代码，并且可以随意编辑它，浏览器会忽略它
	- CSS注释以 /* 开始, 以 */ 结束

3、CSS选择器  https://www.runoob.com/cssref/css-selectors.html
 - 基础选择器
	- 类型
		- 标签，标签名称  比如  h1
		- 类，类名称      比如  .className
		- ID，元素id      比如  #id
	- 标签选择器
		- 以标签名开头，选择所有div元素，比如前面的p标签选择器就是这种
			- 所有h1标签 都显示为红色
				<style scoped>
				h1 {
				color: red;
				}
				</style>
	- 类选择器
		- 给标签取class名，以点(.)加class名开头，选择所有该class名的元素
		- 最常用的一种选择器
			<h1 class="f12">基础标签</h1>
			<style scoped>
			.f12 {
			font-size: 12px;
			}
			</style>
	- id选择器
		- 给标签取id名，以 #加id名 开头，具有唯一性
			<h2><a id="C4">章节 4</a></h2>
			<style scoped>
			#C4 {
			color: blue;
			}
			</style>
	- 群选择器
		- 也可以组合使用，一次选择多个元素，比如 h1, .f12, #C4 都选中，以逗号','分隔多个选中的元素
			<style scoped>
			h1,.f12,#C4 {
			color: blue;
			}
			</style>
	- 全局选择器
		- 既然有多选，那就有全选，使用'*'
			<style scoped>
			* {
			color: blue;
			}
			</style>
 - 层级选择器
	- 类型
		- 如果直接选择元素的话，可能会很多，并不能精确选中需要的元素
		- 因此就可以引入层级关系来选择，比如 div元素下的p标签，而不是顶层p标签
		- 总共有4种层级关系选择器
			- 子选择器: 父元素 > 子元素
			- 包含选择器: 父元素 包含的元素
			- 兄弟选择器: 当前元素 ~ 兄弟元素
			- 相邻选择器: 当前元素 + 相邻元素
	- 子选择器
		- 用于已知父元素，选择子元素、
		- 语法: 以 > 隔开父子级元素，(模块名>模块名，修饰>前模块内的子模块)
			<ul id="list_menu" class="ul_class">
				<li id="coffee">Coffee</li>
				<li>Tea</li>
				<li>Milk</li>
			</ul>
			<style scoped>
			ul>li {
			font-weight: 600;
			}
			</style>
		- 子选择器，只能选择其当前层的子元素，如果不是就无法选中
			<ul id="list_menu" class="ul_class">
				<li id="coffee">Coffee</li>
				<li>Tea</li>
				<li>Milk</li>
				<div>
				<li>In Div</li>
				</div>
			</ul>
	- 包含选择器
		- 包含选择器 可以选择父元素下的 包含该标签的所有元素
		- 语法: 父元素 子元素
			<ul id="list_menu" class="ul_class">
				<li id="coffee">Coffee</li>
				<li>Tea</li>
				<li>Milk</li>
				<div>
				<li>In Div</li>
				</div>
			</ul>
			<style scoped>
			ul li {
				font-weight: 600;
			}
			</style>
	- 兄弟选择器
		- 兄弟选择器 可以选择从一层级的兄弟元素，比如 #coffee同层的li元素
		- 语法: 同层元素 ~ 需要选中的同层元素
			<ul id="list_menu" class="ul_class">
				<li id="coffee">Coffee</li>
				<li>Tea</li>
				<li>Milk</li>
				<div>
				<li>In Div</li>
				</div>
			</ul>
			<style scoped>
			#coffee~li {
				font-weight: 600;
			}
			</style>
	- 相邻选择器
		- 相邻弟选择器 可以选择相邻的元素，而不是同层所有的元素
		- 语法: 当前元素 + 相邻元素
			<ul id="list_menu" class="ul_class">
				<li id="coffee">Coffee</li>
				<li>Tea</li>
				<li>Milk</li>
				<div>
				<li>In Div</li>
				</div>
			</ul>
			<style scoped>
			#coffee+li {
				font-weight: 600;
			}
			</style>
 - 其他常用选择器
	- 属性选择器
		- 元素会有多属性，可以根据元素的属性来选择元素，比如下面的input框
			<form action="demo_form.php">
				<input type="submit" value="提交">
			</form>
			<style scoped>
			[type=submit] {
				font-size: 22px;
			}
			</style>
	- 伪类选择器
		- 当选中一堆元素后，如果对其中部分元素 进行选择 就可以使用伪类选择器
		- 语法: 选择的元素:函数方法
			- first-child:   第一个
			- last-child:    最后一个
			- nth-child(n):  第n个元素
			- not():         not函数，不包含
			- https://www.runoob.com/css/css-pseudo-classes.html
				<ul id="list_menu" class="ul_class">
					<li id="coffee">Coffee</li>
					<li>Tea</li>
					<li>Milk</li>
				</ul>
				<style scoped>
				ul>li:first-child {
					font-weight: 600;
				}
				</style>

4、CSS引入方式
 - 内联
	- 在标签内直接写的，style="attr:value;..."
		<el-table
			:data="tableData"
			style="width: 100%">
			...
		</el-table>
 - 内嵌
	- 通过style标签定义的样式
		<style scoped>
		ul>li:first-child {
			font-weight: 600;
		}
		</style>
 - 外联
	- 当样式需要被应用到很多页面的时候，外部样式表将是理想的选择
	- 使用外部样式表，就可以通过更改一个文件来改变整个站点的外观
		<head>
		<link rel="stylesheet" type="text/css" href="mystyle.css">
		</head>

5、样式基础
 - CSS单位
	- 在布局或者设置字体大小的时候经常看到: 22px; ，px其实是css里面长度单位
	- 绝对长度
		px * 像素 (1px = 1/96th of 1in)
		cm 厘米
		mm 毫米
		in 英寸 (1in = 96px = 2.54cm)
	- 相对长度
		em 它是描述相对于应用在当前元素的字体尺寸，所以它也是相对长度单位。一般浏览器字体大小默认为16px，则2em == 32px
		ex 依赖于英文字母小 x 的高度
		ch 数字 0 的宽度
		rem rem 是根 em（root em）的缩写，rem作用于非根元素时，相对于根元素字体大小；rem作用于根元素字体大小时，相对于其出初始字体大小
		vw viewpoint width，视窗宽度，1vw=视窗宽度的1%
		vh viewpoint height，视窗高度，1vh=视窗高度的1%
		vmin vw和vh中较小的那个。
		vmax vw和vh中较大的那个。
 - CSS颜色
	- https://www.w3school.com.cn/cssref/css_colors.asp

6、常用属性
 - 元素尺寸控制
	- height 设置元素的高度
	- width 设置元素的宽度
	- line-height 设置行高
	- min-width 设置元素的最小宽度
	- min-height 设置元素的最小高度
	- max-height 设置元素的最大高度
	- max-width 设置元素的最大宽度
		<div style="height: 220px;width:440px">
			<p>我们的内容</p>
		</div>
 - 盒子模型
	- Margin(外边距)  清除边框外的区域，外边距是透明的
	- Border(边框)    围绕在内边距和内容外的边框
	- Padding(内边距) 清除内容周围的区域，内边距是透明的
	- Content(内容)   盒子的内容，显示文本和图像
		<div style="height: 220px;width:440px">
			<p style="margin-top:22px;">我们的内容</p>
		</div>
 - Display
	- inline: 现在在一行
	- block: 块元素是一个元素，占用了全部宽度，在前后都是换行符
	- flex: flex布局，见后面参考
		<div>
			<li style="display: inline;">Tea</li>
			<li style="display: inline;">Milk</li>
		</div>
		<div>
			<span style="display: block;">span1</span>
			<span style="display: block;">span2</span>
		</div>
 - Overflow
	- overflow 属性可以控制内容溢出元素框时在对应的元素区间内添加滚动条
		- visible 默认值，内容不会被修剪，会呈现在元素框之外
		- hidden  内容会被修剪，并且其余内容是不可见的
		- scroll  内容会被修剪，但是浏览器会显示滚动条以便查看其余的内容
		- auto    如果内容被修剪，则浏览器会显示滚动条以便查看其余的内容
		- inherit 规定应该从父元素继承 overflow 属性的值
			<div id="overflowTest">
				<p>这里的文本内容是可以滚动的，滚动条方向是垂直方向。</p>
				<p>这里的文本内容是可以滚动的，滚动条方向是垂直方向。</p>
				<p>这里的文本内容是可以滚动的，滚动条方向是垂直方向。</p>
				<p>这里的文本内容是可以滚动的，滚动条方向是垂直方向。</p>
				<p>这里的文本内容是可以滚动的，滚动条方向是垂直方向。</p>
				<p>这里的文本内容是可以滚动的，滚动条方向是垂直方向。</p>
			</div>
			<style scoped>
			#overflowTest {
				background: #4CAF50;
				color: white;
				padding: 15px;
				width: 80%;
				height: 100px;
				overflow: scroll;
				border: 1px solid rgb(150, 18, 18);
			}
			</style>
 - 浮动
	- 控制元素左移还是右移
		- left
		- right
		- 元素浮动之后，周围的元素会重新排列，为了避免这种情况，使用 clear 属性
			<div id="overflowTest" style="clear:both">
				<span style="display: block;">span1</span>
				<span style="display: block;">span2</span>
			</div>
 - 对齐
	- 以常见的居中为例
		<div id="overflowTest" style="text-align: center">
			<span style="display: block;">span1</span>
			<span style="display: block;">垂直居中</span>
			<span style="display: block;">span2</span>
		</div>
		- 为了文本在元素内居中对齐，可以使用 text-align: center
		- 或者行高到div 就整体居中

7、常用网址
	- CSS布局教学           https://zh.learnlayout.com/
	- Flex布局教学游戏      http://flexboxfroggy.com/
	- 在线CSS代码可视工具   https://enjoycss.com/
	- 新拟态模拟工具        https://neumorphism.io/#e0e0e0
	- 渐变色方案            https://uigradients.com/#Copper


四、JavaScript基础
1、JavaScript 运行时
	- 浏览器
		NodeJS
	- $ node -v
		v14.17.1

2、数据类型
 - JavaScript中的数据类型
	- Number
	- 字符串
	- 布尔值
	- 数组 []
		- JavaScript的Array可以包含任意数据类型，并通过索引来访问每个元素
			var arr  = new Array(1, 2, 3);                          // 创建数组arr1[1, 2, 3]
			var arr2 = [1, 2, 3.14, 'Hello', null, true];
			console.log(typeof(arr), arr)                           // object (3) [1, 2, 3]
			- 越界不报错
				arr[0]  // 1
				arr[3]  // undefined
				// 如果通过索引赋值时，索引超过了范围，统一可以赋值
				arr[5] = 5
				arr     // [1, 2, 3, 4, empty, 5]
		- push和pop
			- push() 向Array的末尾添加若干元素，并返回数组长度
				arr.push('A', 'B')
			- pop()  把Array的最后一个元素删除掉，并返回删除元素的值
				arr.pop()
			- 空数组继续pop不会报错，而是返回undefined
		- unshift和shift
			- unshift() 往Array的头部添加若干元素，并返回数组长度
				arr.unshift('A', 'B')
			- shift()   把Array的第一个元素删掉
				arr.shift()
			- 空数组继续shift不会报错，而是返回undefined
		- splice
			- splice() 可以从指定的索引开始删除若干元素，然后再从该位置添加若干元素
				var arr = ['Microsoft', 'Apple', 'Yahoo', 'AOL', 'Excite', 'Oracle'];
				// 从索引2开始删除3个元素,然后再添加两个元素:
				arr.splice(2, 3, 'Google', 'Facebook');    // 返回删除的元素 ['Yahoo', 'AOL', 'Excite']
				arr;                                       // ['Microsoft', 'Apple', 'Google', 'Facebook', 'Oracle']
				// 只删除,不添加:                          
				arr.splice(2, 2);                          // ['Google', 'Facebook']
				arr;                                       // ['Microsoft', 'Apple', 'Oracle']
				// 只添加,不删除:                          
				arr.splice(2, 0, 'Google', 'Facebook');    // 返回[],因为没有删除任何元素
				arr;                                       // ['Microsoft', 'Apple', 'Google', 'Facebook', 'Oracle']
		- sort和reverse
			- concat() 把当前的Array和另一个Array连接起来，并返回一个新的Array
				var arr = ['A', 'B', 'C'];
				var added = arr.concat([1, 2, 3]);
				added;                             // ['A', 'B', 'C', 1, 2, 3]
			- slice()  截取Array的部分元素，然后返回一个新的Array (对应String的substring()版本)
				var arr = ['A', 'B', 'C', 'D', 'E', 'F', 'G'];
				arr.slice(0, 3);                   // 从索引0开始，到索引3结束，但不包括索引3: ['A', 'B', 'C']
				arr.slice(3);                      // 从索引3开始到结束: ['D', 'E', 'F', 'G']
				// 如果不给slice()传递任何参数，它就会从头到尾截取所有元素。利用这一点，我们可以很容易地复制一个Array
				var aCopy = arr.slice();
				aCopy;                             // ['A', 'B', 'C', 'D', 'E', 'F', 'G']
				aCopy === arr;                     // false
		- Vue中的数组
			- Vue 将被侦听的数组的变更方法进行了包裹，所以它们也将会触发视图更新
				- 这些被包裹过的方法包括: 
					push()
					pop()
					shift()
					unshift()
					splice()
					sort()
					reverse()	
	- 对象 字典 Object {}
		- JavaScript的对象是一种无序的集合数据类型，它由若干键值对组成
			obj  = new Object()
			obj2 = {}
		- 由于JavaScript的对象是动态类型，可以自由地给一个对象添加或删除属性
			- 未定义的属性不报错
				obj.a = 1  
				obj.a          // 1
				obj.b          // undefined
				obj.b = 2     
				obj.b          // 2
				// 删除b属性
				delete obj1.b
				delete obj1.b  // 删除一个不存在的c属性也不会报错
		- hasOwnProperty
			- hasOwnProperty() 判断对象是否有该属性
				obj.hasOwnProperty('b')  // false
 - null和undefined
	- null表示一个空的值，而undefined表示值未定义
		var a = {a: 1}
		a.b             // undefined
		a.b = null
		a.b             // null
 - 逻辑运算符
	&& 与运算
	|| 或运算
	!  非运算
 - 关系运算符
	- JavaScript在设计时，有两种比较运算符
		==    它会自动转换数据类型再比较，很多时候，会得到非常诡异的结果
		===   它不会自动转换数据类型，如果数据类型不一致，返回false，如果一致，再比较
			false == 0; // true
			false === 0; // false

3、变量
 - var申明
	- var  变量提升，即 无论声明在何处，都会被提至其所在作用域的顶部
 - 局部变量声明
	- let  无变量提升，即 未到let声明的语句时，是无法访问该变量的
		{ let a1 = 20 }
		a1                // a1 is not defined
 - 申明常量
	- const: 无变量提升，声明一个基本类型的时候为常量，不可修改
		const c1 = 20
		c1 = 30 // Assignment to constant variable
	- 声明对象可以修改
		const c1 = 30
 - 变量提升
	- JavaScript的函数定义有个特点，它会先扫描整个函数体的语句，把所有申明的变量"提升"到函数顶部
		function foo() {
			var x = 'Hello, ' + y;
			console.log(x);
			var y = 'Bob';
		}
		// JavaScript引擎看到的代码相当于
		function foo() {
			var y; // 提升变量y的申明，此时y为undefined
			var x = 'Hello, ' + y;
			console.log(x);
			y = 'Bob';
		}
		- js里面 变量都定义在顶部，并且大量使用let来声明变量
 - 解构赋值
	- 数组属性是index，解开可以直接和变量对应
		let [x, [y, z]] = ['hello', ['JavaScript', 'ES6']];
	- 对象解开后是属性，可以直接导出需要的属性
		var person = {
			name: '小明',
			age: 20,
			gender: 'male',
			passport: 'G-12345678',
			school: 'No.4 middle school'
		};
		var {name, age, passport} = person;
		name                                // '小明'
		age                                 // 20
		passport                            // 'G-12345678'
		
4、字符串
 - 声明
	- JavaScript的字符串就是用''或""括起来的字符表示
		str  = 'str'
		str2 = "str"
 - 字符串转义
	- 使用转义符  \
		'I\'m \"OK\"!';     // `I'm "OK"!`
 - 多行字符串
		ml = `这是一个
		多行
		字符串`;            // '这是一个\n多行\n字符串'
 - 字符串模版
	- 格式: 使用``表示的字符串 可以使用${var_name} 来实现变量替换
		var name = '小明'
		var age = 20
		console.log(`你好, ${name}, 你今年${age}岁了！`)   // 你好, 小明, 你今年20岁了！
 - 字符串拼接
	- 直接使用+号
		'aa' + 'bb'         // 'aabb'
		'aa' + 123          // 'aa123'  注意字符串加数字 = 字符串
 - 常用操作
	str.toUpperCase() 把一个字符串全部变为大写
	str.toLowerCase() 把一个字符串全部变为小写
	str.toString()    把类型转换成字符串
	parseInt(str)     把字符串转换成Int
	parseFloat(str)   把字符串转换成Float

5、错误处理
 - 定义
	- 程序处理的逻辑有问题，导致代码执行异常
		- 示例
			var s = null
			s.length 
			// VM1760:1 Uncaught TypeError: Cannot read property 'length' of null
			//     at <anonymous>:1:3
		- 如果在一个函数内部发生了错误，它自身没有捕获，错误就会被抛到外层调用函数
		- 如果外层函数也没有捕获，该错误会一直沿着函数调用链向上抛出，直到被JavaScript引擎捕获，代码终止执行
		- 可以判断s的合法性，在保证安全的情况下，捕获异常，阻断其往上传传递
			if (s !== null) {s.length}
	- try catch
		- 示例
			try { s.length } catch (e) {console.log('has error, '+ e)}
			// VM2371:1 has error, TypeError: Cannot read property 'length' of null
		- 完整的{try ... catch ... finally}语句
			try {
				...
			} catch (e) {
				...
			} finally {
				...
			}
			try: 捕获代码块中的异常
			catch: 出现异常时需要执行的语句块
			finally: 无论成功还是失败 都需要执行的代码块
	- 常见实用案例 loading
 - 错误类型
	- javaScript有一个标准的Error对象表示错误
		err = new Error('异常情况')
		err 
		// <!-- Error: 异常情况
		//     at <anonymous>:1:7 -->
		err instanceof Error
		// true
 - 抛出错误
	- 程序也可以主动抛出一个错误，让执行流程直接跳转到catch块
	- 抛出错误使用throw语句
		throw new Error('抛出异常')
		// VM3447:1 Uncaught Error: 抛出异常
		//     at <anonymous>:1:7
		// (anonymous) @ VM3447:1

6、命名空间
 - JavaScript中的命名空间
	- JavaScript默认有一个全局对象window，全局作用域的变量实际上被绑定到window的一个属性
	- 不在任何函数内定义的变量就具有全局作用域
 - 全局作用域与window
	- 示例一
		alert("hello")
		// 等价于
		window.alert("hello")
	- 示例二
		var a = 10
		a // 10
		window.a // 10
	- 示例三
		- 由于函数定义有两种方式
			- 以变量方式var foo = function () {}定义的函数也是一个全局变量
			- 顶层函数的定义也被视为一个全局变量，并绑定到window对象
	- 示例四
		- 甚至可以覆盖掉浏览器的内置方法
			alert = () => {console.log("覆盖alert方法")}
			alert()                                      // 覆盖alert方法
 - 命名空间与 export
	- 可以将所有方法绑定到一个变量上暴露出去，避免全局变量的混乱
	- 许多著名的JavaScript库都采用这种方法，如: jQuery，YUI，underscore等等
		- 示例
			// 唯一的全局变量MYAPP:
			var MYAPP = {};
			// 其他变量:
			MYAPP.name = 'myapp';
			MYAPP.version = 1.0;
			// 其他函数:
			MYAPP.foo = function () {
				return 'foo';
			};
			export MYAPP
		- 示例 其他文件中
			import { MYAPP } from './export';

7、函数
 - JavaScript中的函数签名
	function abs(x) {
		if (x >= 0) {
			return x;
		} else {
			return -x;
		}
	}
	- function指出这是一个函数定义
	- abs是函数的名称
	- (x)括号内列出函数的参数，多个参数以,分隔
	- { ... }之间的代码是函数体，可以包含若干语句，甚至可以没有任何语句
 - 方法
	- 绑定方法
		var person = {name: '小明', age: 23}
		person.greet = function() {
			console.log(`hello, my name is ${this.name}`)
		}
		person.greet()
	- this 
		- 注意this的使用，没有绑带在对象上, this 指的是 浏览器的window对象
			var person = {name: '小明', age: 23}
			person.greetfn = function() {
				return function() {
					console.log(`hello, my name is ${this.name}`)
				}
			}
			person.greetfn()()                                   // hello, my name is undefined
		- 此时需要通过一个变量 + 闭包，把当前this传递过去，确保this正常传递
			var person = {name: '小明', age: 23}
			person.greetfn = function() {
				var that = this                                  // js中的特殊用法
				return function() {
					console.log(`hello, my name is ${that.name}`)
				}
			}
			person.greetfn()()                                   // hello, my name is 小明
 - 箭头函数(匿名函数)
	- 箭头函数语法
		(params ...) => { ... }
		- 示例一
			fn = x => x * x
			console.log(fn(10))  // 100
		- 示例二
			x => x * x
			// 等价于下面这个函数
			function (x) {
				return x * x;
			}
		- 示例三
			- 箭头函数看上去是匿名函数的一种简写，但实际上，箭头函数和匿名函数有个明显的区别
				- 箭头函数内部的this是词法作用域，由上下文确定
					var person = {name: '小明', age: 23}
					person.greetfn = function() {
						return () => {
							// this 继承自上层的this
							console.log(`hello, my name is ${this.name}`)
						}
					}
		- 示例四
			axios
			.get('http://localhost:8050/hosts', {params: this.query})
			.then(response => {
				console.log(response)
				this.tableData = response.data.data.items
				this.total = response.data.data.total
				console.log(this.tableData)
			})
			.catch(function (error) { // 请求失败处理
				console.log(error);
			});

8、条件判断
 - 语法格式
	if (condition) {
		...
	} else if (condition) {
		...
	} else {
		...
	}
	- 注意条件需要加上括号，其他和Go语言的if一样

9、for 循环
 - 语法格式
	for (初始条件; 判断条件; 修改变量) {
		...
	}
	- 注意条件需要加上括号
 - for in (不推荐使用)
	- for循环的一个变体是for ... in循环，它可以把一个对象的所有属性依次循环出来
		- 遍历对象: 遍历出来的属性是元素的key
			var o = {
				name: 'Jack',
				age: 20,
				city: 'Beijing'
			};
			for (var key in o) {
				console.log(key);            // 'name', 'age', 'city'
			}
		- 遍历数组: 一个Array数组实际上也是一个对象，它的每个元素的索引被视为一个属性
			var a = ['A', 'B', 'C'];
			for (var i in a) {
				console.log(i);              // '0', '1', '2'
				console.log(a[i]);           // 'A', 'B', 'C'
			}
		- 缺陷
			- 当手动给Array对象添加了额外的属性后，for ... in循环将带来意想不到的意外效果
				var a = ['A', 'B', 'C'];
				a.name = 'Hello';
				for (var x in a) {
					console.log(x);     // '0', '1', '2', 'name'
				}
			- 这和for in的遍历机制相关: 遍历对象的属性名称
			- 使用 for of 解决这个问题
 - for of
	- for ... of循环则修复了这些问题，它只循环集合本身的元素
		var a = ['A', 'B', 'C'];
		a.name = 'Hello';
		for (var x of a) {
			console.log(x);             // 'A', 'B', 'C'
		}
	- 但是for ... of循环不可用直接遍历对象，可以通过Object提供的方法获取key数组，然后遍历
		var o = {
			name: 'Jack',
			age: 20,
			city: 'Beijing'
		};
		for (var key of Object.keys(o)) {
			console.log(key);                // 'name', 'age', 'city'
		}
 - forEach方法
	- forEach()方法是ES5.1标准引入的，是遍历元素的一种常用手段，能作用于可迭代对象上，和for of一样
		arr.forEach(function(item) {console.log(item )})
		arr.forEach((item) => {console.log(item)})
 - for循环应用
	- 如果后端返回的数据不满足展示的需求，需要修改，比如vendor想要友好显示，就可以直接修改数据
	
10、Promise对象
 - 在JavaScript的世界中，所有代码都是单线程执行的
	- 由于这个"缺陷"，导致JavaScript的所有网络操作，浏览器事件，都必须是异步执行
	- Javascript通过回调函数实现异步，js的一大特色
 - 单线程异步模型
	function callback() {
		console.log('Done');
	}
	console.log('before setTimeout()');
	setTimeout(callback, 1000);         // 1秒钟后调用callback函数
	console.log('after setTimeout()');
	// before setTimeout()
	// after setTimeout()
	// 等待一秒后
	// Done
 - Promise与异步
	- Promise
		interface PromiseConstructor {
			/**
			* Creates a new Promise.
			* @param executor A callback used to initialize the promise. This callback is passed two arguments:
			* a resolve callback used to resolve the promise with a value or the result of another promise,
			* and a reject callback used to reject the promise with a provided reason or error.
			*/
			new <T>(executor: (resolve: (value: T | PromiseLike<T>) => void, reject: (reason?: any) => void) => void): Promise<T>;
		}
	- 测试一个函数，resolve是成功后的回调函数，reject是失败后的回调函数
		function testResultCallbackFunc(resolve, reject) {
			var timeOut = Math.random() * 2;
			console.log('set timeout to: ' + timeOut + ' seconds.');
			setTimeout(function () {
				if (timeOut < 1) {
					console.log('call resolve()...');
					resolve('200 OK');
				}
				else {
					console.log('call reject()...');
					reject('timeout in ' + timeOut + ' seconds.');
				}
			}, timeOut * 1000);
		}
		function testResultCallback() {
			success = (message) => {console.log(`success ${message}`)}
			failed = (error) => {console.log(`failed ${error}`)}
			testResultCallbackFunc(success, failed)
		}
	- 将回调改为Promise对象，而Promise的优势在于异步执行的流程中，把执行代码和处理结果的代码清晰地分离
		var p1 = new Promise(testResultCallbackFunc)  // 执行testResultCallbackFunc函数
		p1.then((resp) => {                           // 分析结果
			console.log(resp)
		}).catch((err) => {
			console.log(err)
		})
 - Async函数 + Promise组合
	- Async函数由内置执行器进行执行, 这和go func() 有异曲同工之妙
	- 如果声明一个异步函数，在函数前面加上一个 async关键字
		async function testWithAsync() {                        // async调用协程
			var p1 = new Promise(testResultCallbackFunc)        // new是将函数构造成一个对象
			try {
				var resp = await p1                             // await等待promise的结果
				console.log(resp)
			} catch (err) {
				console.log(err)
			}
		}
	- 这里testWithAsync就是一个异步函数，在执行的时候 是交给js的携程执行器处理的
	- 而 await关键字就是 告诉执行器当p1执行完成后，主动通知下(协程的一种实现)
	- 其实就是一个 event pool模型(简称epool模型)

11、关于JavaStript的总结
 - 推荐使用箭头函数
 - 判断使用 ===
 - 由于变量提升问题，尽量使用let声明变量，并且写在开头
 - for循环推荐forEach

12、Jquery
 - Jquery 是一JavaScript的一个库，极大的简化了js的开发
	- 包含
		- Html元素选取
		- Html元素操作
		- Css操作
		- 绑定事件
		- Ajax
		- 工具函数
		- 插件系统

五、浏览器基础
1、浏览器
 - 场景
	- 适配屏幕
	- 兼容多种浏览器
	- JavaScript可以获取浏览器提供的很多对象，并进行操作
 - 浏览器对象
	- 网页是通过浏览器加载出来的，而浏览器本身也有很多功能
		- 浏览器本身版本信息
		- 当前窗口大小
		- 历史记录
		- ...
	- 而这些数据都是绑定在window对象上，可以认为对于浏览器加载的网页，window就表示浏览器本身
 - 浏览器窗口大小
	- window的如下4个属性控制这个浏览器的窗口大小
		- IE9+、Safari、Opera和Chrome都支持这4个属性
			- innerWidth: 页面视图的宽
			- innerHeight: 页面视图的高
			- outerWidth: 浏览器整个窗口的宽
			- outerHeight: 浏览器整个窗口的高
		- 调整浏览器窗口大小
			- console.log('window inner size: ' + window.innerWidth + ' x ' + window.innerHeight);
			- console.log('window outer size: ' + window.outerWidth + ' x ' + window.outerHeight);
 - 浏览器信息
	- 关于浏览器的相关信息都保存在navigator对象上面
		window.navigator
		- 常用的属性
			navigator.appName: 浏览器名称；
			navigator.appVersion: 浏览器版本；
			navigator.language: 浏览器设置的语言；
			navigator.platform: 操作系统类型；
			navigator.userAgent: 浏览器设定的User-Agent字符串
			navigator.userAgentData: useragent相关信息, Object
 - 屏幕信息
	- 需要知道用户的屏幕尺寸，以便做网页布局，这是就需要获取屏幕的数据
		window.screen
 - 访问网址
	- 为了保证每个用户访问该URL都呈现统一的效果，页面往往都需要读取当前Page的参数
		window.location
		- 常用的属性
			location.protocol;     // 'http'
			location.host;         // 'www.example.com'
			location.port;         // '8080'
			location.pathname;     // '/path/index.html'
			location.search;       // '?a=1&b=2'
			location.hash;         // 'TOP'
			location.assign(url)   // 加载页面
			location.replace(url)  // 重定向页面
			location.reload()      // 重新加载当前页面
		- 示例
			if (confirm('重新加载当前页' + location.href + '?')) {
				location.reload();
			} else {
				location.assign('/'); // 设置一个新的URL地址
			}
 - 历史记录
	- history对象保存了浏览器的历史记录
	- JavaScript可以调用history对象的back()或forward ()，相当于用户点击了浏览器的"后退"或"前进"按钮
		- <- 浏览器的"后退"按钮
			history.back();
		- -> 浏览器的"前进"按钮
			history.forward()

2、AJAX
 - Asynchronous JavaScript and XML，意思就是用JavaScript执行异步网络请求
	- 简单来说就是浏览器中的Http Client
	- 在现代浏览器上写AJAX主要依靠XMLHttpRequest对象
	- 异步获取数据 + 局部刷新页面
 - XMLHttpRequest
	- 声明XMLHttpRequest对象
		var request = new XMLHttpRequest(); 
	- 发送请求
		request.open('GET', 'https://www.baidu.com');
		request.send();
	- 由于js都是异步的，需要定义回调来处理返回，用于获取请求结果
		request.onreadystatechange = function () {
			console.log(request.status)
			console.log(request.responseText)
		}
	- 对于AJAX请求特别需要注意跨域问题: CORS  https://www.ruanyifeng.com/blog/2016/04/cors.html
		- 简单请求
			- 请求特征
				- HTTP Method: GET、HEAD和POST
				- Content-Type: application/x-www-form-urlencoded、multipart/form-data和text/plain
				- 不能出现任何自定义头
			- 请求流程
				- 通常能满足90%的需求
				- 控制其跨域的关键头 来自于服务端设置的: Access-Control-Allow-Origin
				- 对于简单请求，浏览器直接发出CORS请求
					- 具体来说，就是在头信息之中，增加一个Origin字段
				- 客户端发送请求时 Origin: xxxx
				- 服务端响应请求时 Access-Control-Allow-Origin: xxxx / *
				- 如果服务端不允许该域，就跨越失败
				- 如果想允许特定的Header，服务端也可以通过添加 Access-Control-Expose-Headers 来进行控制
		- 复杂请求
			- 请求特征
				- HTTP Method: PUT、DELETE
				- Content-Type: 其他类型如application/json
				- 含自定义头，比如后面携带的用于认证的X-OAUTH-TOKEN头
			- 请求流程
				- 非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为"预检"请求(preflight)
					- preflight请求
						- Method: OPTIONS
						- Header: Access-Control-Request-Method   列出浏览器的CORS请求会用到哪些HTTP方法
						- Header: Access-Control-Request-Headers  该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段
							OPTIONS /cors HTTP/1.1
							Origin: http://api.bob.com
							Access-Control-Request-Method: PUT
							Access-Control-Request-Headers: X-Custom-Header
							Host: api.alice.com
							Accept-Language: en-US
							Connection: keep-alive
							User-Agent: Mozilla/5.0...
					- preflight响应
						- Header: Access-Control-Allow-Origin    允许的源(域)
						- Header: Access-Control-Allow-Methods   服务端 允许的方法(所有方法，一般大于请求的该头)
						- Header: Access-Control-Allow-Headers   服务端 允许的自定义Header
						- Header: Access-Control-Max-Age         用来指定本次预检请求的有效期，避免多次请求，该字段可选
							Access-Control-Allow-Methods: GET, POST, PUT
							Access-Control-Allow-Headers: X-Custom-Header
							Access-Control-Allow-Credentials: true
							Access-Control-Max-Age: 1728000
 - axios
 - 页面(DOM)
	- DOM
		- 浏览器当前加载的Page也是一个对象: window.document
		- 由于HTML在浏览器中以DOM形式表示为树形结构，document对象就是整个DOM树的根节点
		- 获取当前Document中的一些属性
			- 比如 title document的title属性是从HTML文档中的<title>xxx</title>读取的，但是可以动态改变
				document.title
				// 'golang random int_百度搜索'
				// 动态修改
				document.title = '测试修改'
		- 很多js库比如JQuery都是通过动态操作Dom来实现很多高级功能的，这些是上层库的基石
	- DOM查询
		- 要查找DOM树的某个节点，需要从document对象开始查找
		- 最常用的查找是根据ID和Tag Name以及ClassName
			<h1>列表</h1>
			<ul id="list_menu" class="ul_class">
				<li>Coffee</li>
				<li>Tea</li>
				<li>Milk</li>
			</ul>
			document.getElementById('list_menu')
			// <ul data-v-7ba5bd90 id=​"list_menu">​<li data-v-7ba5bd90>​…​</li>​<li data-v-7ba5bd90>​…​</li>​<li data-v-7ba5bd90>​…​</li>​</ul>​
			document.getElementsByTagName('ul')
			// 返回所有的ul元素
			document.getElementsByClassName('ul_class')
		- 组合使用
			document.getElementById('list_menu').getElementsByTagName('li')
			// 上面也等价于
			document.getElementById('list_menu').children
			// firstElementChild
			document.getElementById('list_menu').firstElementChild
			// lastElementChild
			document.getElementById('list_menu').lastElementChild
			// parentElement 获取父元素
			document.getElementById('list_menu').parentElement
	- 更新DOM
		- 获取的元素后，可以通过元素的如下2个方法，修改元素
			- innerHTML: 不但可以修改一个DOM节点的文本内容，还可以直接通过HTML片段修改DOM节点内部的子树
			- innerText: 只修改文本内容
				var le = document.getElementById('list_menu').lastElementChild
				le.innerText = '牛奶'                                           // 页面的内容已经修改
				le.innerText = '<span style="color:red">牛奶</span>'            // html格式无法识别
				le.innerHTML = '<span style="color:red">牛奶</span>'            // 使用innterHTML则可以
	- 插入DOM
		- 很多响应式框架都会根据数据新增，动态创建一个DOM元素，并插入到指定位置
			- 使用 createElement 来创建一个DOM元素，比如创建一个a标签
				
				var newlink = document.createElement('a')                       // 创建一个A标签
				newlink.href = "http://www.baidu.com"                           // <a></a>
				newlink.innerText = '跳转到百度'                                // 修改A标签属性
				var lm = document.getElementById('list_menu')                   // 追加到某个元素后面
				lm.appendChild(newlink)
			- 想要控制元素插入的位置可以使用insertBefore
				parentElement.insertBefore(newElement, referenceElement);       // 父元素
				var lm = document.getElementById('list_menu')                   // 子元素
				var cf = document.getElementById('coffee')                      // 需要插入的元素
				var newlink = document.createElement('a')
				newlink.href = "http://www.baidu.com"   
				newlink.innerText = '跳转到百度'
				lm.insertBefore(newlink, cf)                                    // 插入到coffee之前
		- 有2种方式可以插入一个DOM元素
			- appendChild: 把一个子节点添加到父节点的最后一个子节点
			- insertBefore: 插入到某个元素之前
	- 删除DOM
		- 删除一个节点，首先要获得该节点本身以及它的父节点，然后调用父节点的removeChild把自己删掉
			parent.removeChild(childNode);
		- 删除刚才添加的那个元素
			lm.removeChild(newlink)


六、Vue
1、Vue的简介
 - Vue 是一套用于构建用户界面的渐进式框架
	- 与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用
 - Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合，比如实现拖拽: vue + sortable.js
 - vue借鉴了很有框架优秀的部分进行了整合
	- 借鉴 angular 的模板和数据绑定技术
	- 借鉴 react 的组件化和虚拟 DOM 技术
 - 所有框架的逻辑都是通过js封装，上层概念比如MVVM，方便快速开发，因此学习任何框架前都需要具有Web基础
	- HTML
	- CSS
	- Javascript

2、Vue.js与环境的安装
1).安装Node.js
 - 一个基于 Chrome V8 引擎 的 JavaScript 运行时环境
	https://nodejs.org/zh-cn/
	$ node -v   // v14.17.1
	$ npm -v    // 6.14.13
 - 配置使用国内源
	$ npm config set registry http://registry.npm.taobao.org/
	$ npm config get registry

2).安装Vue和脚手架工具
 - 直接使用Node.js进行全局安装
	# 最新稳定版
	$ npm install -g vue            // -g 参数即为全局安装
 - 安装项目脚手架工具
	- 官方同时提供了1个cli工具，用于快速初始化一个vue工程，官方文档 https://cli.vuejs.org/
		$ npm install -g @vue/cli
		$ npm list -g               // 查看当前Node.js环境下安装的包
		
3).Vue Devtools
 - chrome商店
 - https://www.jianshu.com/p/63f09651724c
 
4).vscode 插件
 - Beautify:          js, css, html 语法高亮差距
 - ESLint:            js eslint语法风格检查
 - Auto Rename Tag:   tag rename
 - Vetur:             vue语法高亮插件
 
5).项目
 - vue项目创建
	$ vue create demo
	$ cd demo 
	$ npm run serve
 - 项目结构
	- 通过vue-cli搭建一个vue项目，会自动生成一系列文件
		├── dist/                      	# 项目构建后的产物
		├── node_module/               	# 项目中安装的依赖模块
		├── public/                    	# 纯静态资源，入口文件(index.html)也在里面
		├── src/
		│   ├── main.js                 # 程序入口文件
		│   ├── App.vue                 # 程序入口vue组件，大写字母开头，后缀 .vue
		│   ├── components/             # 组件
		│   │   └── ...
		│   └── assets/                 # 资源文件夹，一般放一些静态资源文件，比如CSS/字体/图片
		│       └── ...
		├── babel.config.js             # babel 配置文件，es6语法转换
		├── .gitignore                  # 用来过滤一些版本控制的文件，比如node_modules文件夹 
		└── package.json                # 项目文件，记载着一些命令和依赖还有简要的项目描述信息 
		└── README.md                   # 介绍创建的项目，可参照github上star多的项目
 - 部署项目
	$ npm run build ## 会在项目的dist目录下生成html文件, 使用这个静态文件部署即可
	// 比如使用python快速搭建一个http静态站点，如果是nginx copy到 对应的Doc Root位置
	$ cd dist
	$ python3 -m http.server

3、MVVM
 - MVVM模型
	- M  (Model，模型层): 模型层，主要负责业务数据相关，对应vue中的 data部分
	- V  (View，视图层) : 视图层，顾名思义，负责视图相关，细分下来就是html+css层，对应于vue中的模版部分
	- VM (ViewModel, 控制器): V与M沟通的桥梁，负责监听M或者V的修改，是实现MVVM双向绑定的要点，对应vue中双向绑定
 - Web技术的历史
	- CGI时代
	- 后端模版时代
		- ASP: 微软，C#体系
		- JSP: SUN，Java体系
		- PHP: 开源社区
	- JavaScript原生时代
	- 前端模版时代
		- ViewModel动态完成渲染
	- 虚拟DOM技术
	- 组件化时代
		- MVVM最早由微软提出来，它借鉴了桌面应用程序的MVC思想，在前端页面中，把Model用纯JavaScript对象表示，View负责显示，两者做到了最大限度的分离
		- 结合虚拟Dom技术，就可以动态生成view，在集合mvvm的思想，前端终于迎来了组件化时代
			- 页面由多个组建构成
			- 每个组件都有自己的 MVVM
	
4、Vue与MVVM
	- Model: vue中用于标识model的数据是 data对象，data 对象中的所有的 property 加入到 vue 的响应式系统中，由Vue监听变化  // Data
	- View:  vue使用模版来实现展示，但是渲染时要结合 vdom技术	                                                         // Html、Css 
	- ViewModle: vue的核心，负责视图的响应，也就是数据双向绑定
		- 监听view中的数据，如果数据有变化，动态同步到 data中
		- 监听data中的数据，如果数据有变化，通过vdom动态渲视图

5、Vue实例
 - Vue实例源码
	export interface Vue {
		// 生产的HTML元素
		readonly $el: Element; 
		// 实例的一些配置, 比如components, directives, filters ...
		readonly $options: ComponentOptions<Vue>;
		// 父Vue实例 
		readonly $parent: Vue;
		// Root Vue实例
		readonly $root: Vue;
		// 该vue实例的子vue实例，一般为 子组建
		readonly $children: Vue[];
		// 元素refs, 当元素有refs属性时才能获取
		readonly $refs: { [key: string]: Vue | Element | (Vue | Element)[] | undefined };
		// 插槽, 模版插槽
		readonly $slots: { [key: string]: VNode[] | undefined };
		readonly $scopedSlots: { [key: string]: NormalizedScopedSlot | undefined };
		readonly $isServer: boolean;
		// Model对应的数据
		readonly $data: Record<string, any>;
		// 实例props, 用于组件见消息传递
		readonly $props: Record<string, any>;
		readonly $ssrContext: any;
		// 虚拟node
		readonly $vnode: VNode;
		readonly $attrs: Record<string, string>;
		readonly $listeners: Record<string, Function | Function[]>;
		// 实例挂在到具体的HTML上
		$mount(elementOrSelector?: Element | string, hydrating?: boolean): this;
		// 强制刷新渲染, 收到刷新界面, 当有些情况下 界面没响应时
		$forceUpdate(): void;
		// 销毁实例
		$destroy(): void;
		$set: typeof Vue.set;
		$delete: typeof Vue.delete;
		// watch对象变化
		$watch(
			expOrFn: string,
			callback: (this: this, n: any, o: any) => void,
			options?: WatchOptions
		): (() => void);
		$watch<T>(
			expOrFn: (this: this) => T,
			callback: (this: this, n: T, o: T) => void,
			options?: WatchOptions
		): (() => void);
		$on(event: string | string[], callback: Function): this;
		$once(event: string | string[], callback: Function): this;
		$off(event?: string | string[], callback?: Function): this;
		// 触发事件
		$emit(event: string, ...args: any[]): this;
		// Dom更新完成后调用
		$nextTick(callback: (this: this) => void): void;
		$nextTick(): Promise<void>;
		$createElement: CreateElement;
	}
 - Vue实例的构造函数
	- Data: Model
	- Methods: 方法
	- Computed: 计算属性
	- Props: 类似于一个自定义 attribute
		new <Data = object, Methods = object, Computed = object, Props = object>(options?: ThisTypedComponentOptionsWithRecordProps<V, Data, Methods, Computed, Props>): CombinedVueInstance<V, Data, Methods, Computed, Record<keyof Props, any>>;

6、Vue实例生命周期
 - 生命周期
	https://gitee.com/infraboard/go-course/blob/master/day16/images/lifecycle.png
 - 定义的函数钩子
	beforeCreate()
	created()
	beforeMount()
	mounted()
	beforeUpdate()
	updated()
	beforeDestroy()
	destroyed()

7、模板语法
1)、模板定义
 - 通过template标签定义的部分都是vue的模版
	- 模版会被vue-template-compiler编译后渲染
		<template>
		  ...
		</template>

2)、文本值
 - 当需要访问Model时，比如 data 这个Object
	- 直接使用 {{ attr }} 就可以访问
	- vue会根据属性是否变化，而动态渲染模版
		<template>
		<div>{{ name }}</div>              // data中的 name属性
		</template>
		<script>
		export default {
		  name: 'HelloWorld',
		  data() {
		    return {
		      name: '老喻'
		    }
		  }
		}
		</script>

3)、元素属性
 - 变量不能作用在 HTML attribute 上
	- 示例一  语法错误
		<template>
		  <div id={{ name }}>{{ name }}</div>
		</template>
	- 示例二
		- buttom有个disabled属性，用于控制当前按钮是否可以点击
		<template>
		  <button disabled="true">Button</button>
		</template>
 - 针对HTML元素的属性 vue专门提供一个 v-bind指令，这个指令就是模版引擎里面的一个函数，作用是完成HTML属性变量替换
	- v-bind:disabled="attr"   ==>  disabled="data.attr"
		<template>
		  <button v-bind:disabled="isButtomDisabled">Button</button>
		</template>
		<script>
		export default {
		  name: 'HelloWorld',
		  data() {
		    return {
		      name: '老喻',
		      isButtomDisabled: false,
		    }
		  }
		}
		</script>
	- v-binding 缩写 `:`
		<template>
		  <button :disabled="isButtomDisabled">Button</button>
		</template>

4)、元素事件
 - 给buttom元素绑定一个事件
	- HTML 原生语法  https://www.runoob.com/tags/ref-eventattributes.html
		<button onclick="copyText()">复制文本</button>
 - 对于vue的模版系统来说，copyText这个函数如何渲染，他不是一个文本，而是一个函数
	- vue针对事件专门定义了一个指令: v-on
		v-on:eventName="eventHandler"
		eventName: 事件的名称
		eventHandler: 处理这个事件的函数
	- data 是定义Model的地方，vue专门给一个属性用于定义方法: methods
		<template>
		  <button :disabled="isButtomDisabled" v-on:click="clickButtom" >Button</button>
		</template>
		<script>
		export default {
		  name: 'HelloWorld',
		  data() {
		    return {
			  name: '老喻',
			  isButtomDisabled: false,
		    }
		  },
		  methods: {
		    clickButtom() {
		      alert("别点我")  
		    }
		  }
		}
		</script>
	- v-on 缩写 `@`
		<template>
		  <button :disabled="isButtomDisabled" @click="clickButtom" >Button</button>
		</template>

4)、Vue指令
 - 指令类型
	v-model: 双向绑定的数据
	v-bind: html元素属性绑定
	v-on: html元素事件绑定
	v-if: if 渲染
	v-show: 控制是否显示
	v-for: for 循环
 - 指令
	- 语法
		v-directive:argument.modifier.modifier...
	- v-directive: 表示指令名称，如v-on
	- argument： 表示指令的参数，比如click
	- modifier:  修饰符，用于指出一个指令应该以特殊方式绑定
	- 示例 当用户按下回车时，表示用户输入完成，触发搜索
		v-directive: 需要使用绑定事件的指令: v-on
		argument:    监听键盘事件: keyup，按键弹起时
		modifier:    监听Enter建弹起时
		完整语法:    v-on:keyup.enter
			<template>
			  <input v-model="name" type="text" @keyup.enter="pressEnter">
			</template>
			<script>
			export default {
			  name: 'HelloWorld',
				data() {
				return {
				  name: '老喻',
				  isButtomDisabled: false,
				}
			  },
			  methods: {
			    clickButtom() {
			      alert("别点我")  
			    },
			    pressEnter() {
			 	  alert("点击了回车键")
			    }
			  },
			}
			</script>
	- 需要注意事件的指令的函数是可以接受参数的
		<template>
		  <input v-model="name" type="text" @keyup.enter="pressEnter(name)">
		  <button v-on:click="say('hi')">Say hi</button>
		</template>
	- 函数是直接读到model数据的，不能使用{{ }}，如果要传字符串 使用''
	- 修饰符还有很多其他用法，具体的请看官方文档
		<!-- 即使 Alt 或 Shift 被一同按下时也会触发 -->
		<button v-on:click.ctrl="onClick">A</button>
		
		<!-- 有且只有 Ctrl 被按下的时候才触发 -->
		<button v-on:click.ctrl.exact="onCtrlClick">A</button>
		
		<!-- 没有任何系统修饰符被按下的时候才触发 -->
		<button v-on:click.exact="onClick">A</button>

5)、JavaScript 表达式
	- 模版支持JavaScript的表达式, 可以在显示的动态的做一些处理
		<template>
		  <div>{{ name.split('').reverse().join('') }}</div>
		</template>
		<script>
		export default {
		  name: 'HelloWorld',
		  data() {
		    return {
		      name: '老喻'
		    }
		  }
		}
		</script>

6)、条件渲染
 - 有2个指令用于在模版中控制条件渲染
	v-if: 控制元素是否创建，创建开销较大
	v-show: 控制元素是否显示，对象无效销毁，开销较小
 - v-if 语法
	<t v-if="" /> 
	<t v-else-if="" /> 
	<t v-else="" /> 
 - v-show 语法
	<t v-show="" />
 - 示例 根据用户输入，判断当前分数的等级
	<input v-model="name" type="text" @keyup.enter="pressEnter(name)">
	<div v-if="name >= 90">
	  A
	</div>
	<div v-else-if="name >= 80">
	  B
	</div>
	<div v-else-if="name >= 60">
	  C
	</div>
	<div v-else-if="name >= 0">
	  D
	</div>
	<div v-else>
	  请输入正确的分数
	</div>
	// 使用 v-show
	<input v-model="name" type="text" @keyup.enter="pressEnter(name)">
	<div v-show="name >= 90">
	  A
	</div>
	<div v-show="name >= 80 && name < 90">
	  B
	</div>
	<div v-show="name >= 60 && name < 80">
	  C
	</div>
	<div v-show="name >= 0 && name < 60">
	  D
	</div>
	- 一般来说，v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销
	- 因此，如果需要非常频繁地切换，则使用 v-show 较好
	- 如果在运行时条件很少改变，则使用 v-if 较好

7)、列表渲染
 - v-for元素的列表渲染
	<t v-for="(item, index) in items" :key="item.message">
	  {{ item.message }}
	</t>
	<!-- items: [
	  { message: 'Foo' },
	  { message: 'Bar' }
	] -->
 - 也可以省略 index
	<ul>
	  <li v-for="item in items" :key="item.message">
	    {{ item.message }}
	  </li>
	</ul>
	<script>
	export default {
	  name: 'HelloWorld',
	  data() {
	    return {
	    items: [
		  { message: 'Foo' },
		  { message: 'Bar' }
	    ]
	    }
	  },
	}
	</script>
 - v-for 除了可以遍历列表，可以遍历对象，比如嵌套2层循环，先遍历列表，再遍历对象
	<ul>
	  <li v-for="(item, index) in items" :key="item.message">
	    {{ item.message }} - {{ index}}
	    <br>
	    <span v-for="(value, key) in item" :key="key"> {{ value }} {{ key }} <br></span>
	  </li>
	</ul>
	<script>
	export default {
	  name: 'HelloWorld',
	  data() {
	    return {
	      items: [
	        { message: 'Foo', level: 'info' },
	        { message: 'Bar', level: 'error'}
	      ]
	    }
	  }
	}
	</script>
 - 可以在console界面里进行数据修改测试
	$vm._data.items.push({message: "num4", level: "pannic"})
	$vm._data.items.pop()
 - 不推荐在同一元素上使用 v-if 和 v-for，请另外单独再起一个元素进行条件判断
		<li v-for="todo in todos" v-if="!todo.isComplete">
		{{ todo }}
		</li>
	- 请改写成下面方式:
		<ul v-if="todos.length">
		  <li v-for="todo in todos">
		    {{ todo }}
		  </li>
		</ul>
		<p v-else>No todos left!</p>

8、计算属性
 - 如果model的数据并不是要直接渲染的，需要处理再展示，简单的方法是使用表达式
	- 示例
		<h2>{{ name.split('').reverse().join('') }}</h2>
	- 这种把数据处理逻辑嵌入的视图中，并不合适，不易于维护，可以把改成一个方法	
		<h2>{{ reverseData(name) }}</h2>
		<script>
		  methods: {
		    reverseData(data) {
		      return data.split('').reverse().join('')
		    }
		  }
		</script>
	- 除了函数，vue还提供了一个计算属性，这样视图可以看起来更干净
		computed: {
		  attrName: {
		    get() {
		      return value
		    },
		    set(value) {
		    // set value
		    }
		  }
		}
	- 修改为计算属性
		<h2>{{ reverseName }}</h2>
		<script>
		export default {
		  computed: {
		    reverseName: {
		      get() {
		        return this.name.split('').reverse().join('')
		      },
		      set(value) {
		        this.name = this.name = value.split('').reverse().join('')
		      }
		    }
		  },
		}
		</script>

9、侦听器
 - 一个页面有多个参数，用户可能把url copy给别人，需要不同的url看到页面内容不同，不然用户每次到这个页面都是第一个页面
	- 这个就需要监听url参数的变化，然后视图做调整，vue-router会有个全局属性: $route 可以监听它的变化
 - window本身提供一个事件回调
	window.onhashchange = function () {
	  console.log('URL发生变化了', window.location.hash);
	  this.urlHash = window.location.hash
	};
 - vue 提供的属性watch
	watch: {
	  // 如果 `urlHash` 发生改变，这个函数就会运行
	  urlHash: function (newData, oldData) {
	    this.debouncedGetAnswer()
	  }
	},
 - 先监听变化，挂载后修改vue对象，然后watch
	<script>
	export default {
	  name: 'HelloWorld',
	  data() {
	    return {
	      urlHash: '',
	    }
	  },
	  mounted() {
	    /* 来个骚操作 */
	    let that = this
	    window.onhashchange = function () {
	      that.urlHash = window.location.hash
	    };
	  },
	  watch: {
	    urlHash: function(newURL, oldURL) {
	      console.log(newURL, oldURL)
	    }
	  }
	}
	</script>
 - Vue Watch API  
	https://cn.vuejs.org/v2/api/#vm-watch

10、过滤器
 - Vue.js 允许自定义过滤器，可被用于一些常见的文本格式化，最常见的是 时间的格式化
	- 过滤器语法
		<!-- 在双花括号中 -->
		{{ message | capitalize }}
	- 可以将其等价于一个函数: capitalize(message)
	- 在当前组件的vue实例上定义一个过滤器
		filters: {
		  capitalize: function (value) {
		    /*过滤逻辑*/
		  }
		}
 - 定义 parseTime过滤器
	{{ ts | parseTime }}
	<script>
	export default {
	  name: 'HelloWorld',
	  data() {
	    return {
	      ts: Date.now()
	    }
	  },
	  filters: {
	    parseTime: function (value) {
	      let date = new Date(value)
	      return `${date.getFullYear()}-${date.getMonth() + 1}-${date.getDate()} ${date.getHours()}:${date.getMinutes()}`
	    }
	  }
	}
	</script>
 - vue提供全局过滤器，再初始化vue实例的时候可以配置，找到main.js添加
	// 添加全局过滤器
	Vue.filter('parseTime', function (value) {
	  let date = new Date(value)
	  return `${date.getFullYear()}-${date.getMonth() + 1}-${date.getDate()} ${date.getHours()}:${date.getMinutes()}`
	})

11、自定义指令
 - 除了核心功能默认内置的指令 (v-model 和 v-show)，Vue 也允许注册自定义指令
	- 比如用户进入页面让输入框自动聚焦，方便快速输入
	- 比如登陆页面，快速聚焦到 username输入框
	- 如果是HTML元素聚焦，找到元素，调用focus
		let inputE = document.getElementsByTagName('input')
		inputE[0].focus()
	- 添加到mounted中进行测试
		mounted() {
		  let inputE = document.getElementsByTagName('input')
		  inputE[0].focus()
		}
    - 将这个功能做成一个vue的指令，比如 v-focus
		- 先注册一个局部指令，在本组件中使用
			<script>
			export default {
			  name: 'HelloWorld',
			  directives: {
			    focus: {
			      // 指令的定义
			      inserted: function (el) {
			        el.focus()
				  }
				}
			  },
			}
			</script>
		- 这里注册的指令名字叫focus，所有的指令在模版要加一个v前缀，因此注册的指令就是v-focus
			<input v-focus v-model="name" type="text" @keyup.enter="pressEnter(name)">
			// 注册一个全局自定义指令 `v-focus`
			Vue.directive('focus', {
			  // 当被绑定的元素插入到 DOM 中时……
			  inserted: function (el) {
			    // 聚焦元素
			    el.focus()
			  }
			})

12、组件
1)、组件的介绍
 - 组件是可复用的 Vue 实例，所以它们与 new Vue 接收相同的选项，例如 data、computed、watch、methods 以及生命周期钩子等，仅有的例外是像 el 这样根实例特有的选项
	- export default语法，ES6的模块语法
	- 每个vue组件，只能有1个根元素，所以不能在模版里面写2个并排的div
	- 组件的命名风格是首字母大写，导出名字最好和文件名称相同，方便阅读
	- 局部组件必须放到实例的components属性里面，代表这个组件注册到了该实例，只有注册后的组件才能使用
	- 组件的使用方式和HTML标签一样，可以认为是自定义的HTML标签，应该遵循html标签规范，小写加-链接，比如hello-world
		<template>
		  <div id="app">
		    <img alt="Vue logo" src="./assets/logo.png">
		    <hello-world msg="Welcome to Your Vue.js App"/>
		    <hello-world msg="component2"/>
		  </div>
		</template>
2)、向子组件传递数据
 - props就是用于传递数据的变量，使用Prop 可以在组件上注册的一些自定义 attribute，父组件通过绑定数据来传递消息给子组件
 - 子组件
	<script>
	export default {
	  name: 'HelloWorld',
	  props: {
	    msg: String
	  }
	}
	</script>
 - 父组件
	<template>
	  <div id="app">
	    <img alt="Vue logo" src="./assets/logo.png">
	    <hello-world :msg="msg1"/>
	  </div>
	</template>
	<script>
	import HelloWorld from './components/HelloWorld.vue'
	export default {
	name: 'App',
	  data() {
	    return {
	      msg1: 'Welcome to Your Vue.js App'
	    }
	  },
	  components: {
	    HelloWorld
	  }
	}
	</script>
3)、向父组件传递数据
 - 需要条件	 
	- 子组件使用$emit发送事件，事件名称: changeMsg
	- 父组件使用v-on 订阅子组件的事件
 - 具体步骤
	- 修改子组建，重新绑定一个属性: tmpMsg，等点击回车时发生事件给父组件
		<input v-model="tmpMsg" type="text" @keyup.enter="changeProps(tmpMsg)">
		<script>
		export default {
		  name: 'HelloWorld',
		  data() {
		    return {
		      tmpMsg: '',
		    }
		  },
		  methods: {
		    changeProps(msg) {
		      this.$emit('changeMsg', msg)
		    }
		  },
		  props: {
		    msg: String
		  }
		}
		</script>
	- 父组件修改
		<hello-world :msg="msg1" @changeMsg="msgChanged" />
		<script>
		import HelloWorld from './components/HelloWorld.vue'
		export default {
		  name: 'App',
		  data() {
		    return {
		      msg1: 'Welcome to Your Vue.js App'
		    }
		  },
		  methods: {
		    msgChanged(event) {
		      this.msg1 = event
		    }
		  },
		  components: {
		    HelloWorld
		  }
		}
		</script>
4)、使用 v-model 实现
 - 上述使用 v-bind 和 v-on 完成了数据的双向绑定
	- 但其实就是 v-model
		v-model <==>  v-bind:value + v-on:input
	- 将其 value attribute 绑定到一个名叫 value 的 prop 上 在其 input 事件被触发时，将新的值通过自定义的 input 事件抛出
 - 使用 v-model
	- 父组件使用 v-model进行值的双向传递
		<hello-world v-model="msg1" />
	- 子组件绑定value属性和抛出input事件
		<input :value="value" type="text" @input="$emit('input', $event.target.value)">
		<script>
		export default {
		  name: 'HelloWorld',
		  props: {
		    value: String,
		  }
		}
		</script>

13、插件
 - 插件通常用来为 Vue 添加全局功能
 - 插件的功能范围没有严格的限制，一般有下面几种
	- 添加全局方法或者 property，如：vue-custom-element
	- 添加全局资源：指令/过滤器/过渡等，如 vue-touch
	- 通过全局混入来添加一些组件选项，如 vue-router
	- 添加 Vue 实例方法，通过把它们添加到 Vue.prototype 上实现
	- 一个库，提供自己的 API，同时提供上面提到的一个或多个功能，如 vue-router
 - 示例 element-ui 插件
	import ElementUI from "element-ui"
	import "element-ui/lib/theme-chalk/index.css"
	Vue.use(ElementUI)
	// 组件
	import Vue, { PluginObject } from 'vue'
	import { ElementUIComponent, ElementUIComponentSize, ElementUIHorizontalAlignment } from './component'
	import { ElAlert } from './alert'
	import { ElAside } from './aside'
	import { ElAutocomplete } from './autocomplete'
	import { ElBadge } from './badge'
	import { ElBreadcrumb } from './breadcrumb'
	import { ElBreadcrumbItem } from './breadcrumb-item'
	import { ElButton } from './button'
	// 这些element的组件都被注册到vue里面
	import Vue from 'vue'
	/** ElementUI component common definition */
	export declare class ElementUIComponent extends Vue {
	  /** Install component into Vue */
	  static install (vue: typeof Vue): void
	}

14、Vue路由
1)、页面路由
 - 当前的vue配置
	// Root Vue实例
	new Vue({
	  render: h => h(App),
	}).$mount('#app')

2)、简单路由
 - window.location.pathname
	- 为每个path，定义一个组件，就实现了一个简单的路由
		// Root Vue实例
		// 添加currentRoute数据 和 浏览器的path绑定
		// 根据path 返回对应组件
		new Vue({
		  data: {
		    currentRoute: window.location.pathname
		  },
		  render(h) {
		    if (this.currentRoute === '/index') {
		      return h(App2)
		    }
		    return h(App)
		  },
		}).$mount('#app')
	- 官方示例
		https://cn.vuejs.org/v2/guide/routing.html
 - vue-router
	- Vue Router 是 Vue.js (opens new window)官方的路由管理器
		- 它和 Vue.js 的核心深度集成，让构建单页面应用变得易如反掌
		- 包含的功能
			- 套的路由/视图表
			- 块化的、基于组件的路由配置
			- 由参数、查询、通配符
			- 于 Vue.js 过渡系统的视图过渡效果
			- 粒度的导航控制
			- 有自动激活的 CSS class 的链接
			- TML5 历史模式或 hash 模式，在 IE9 中自动降级
			- 定义的滚动条行为
	- 安装vue-router
		- 使用npm
			- $ npm install vue-router
			- vue-router是vue的插件，按照插件的方式引入到vue中
				import Vue from 'vue'
				import VueRouter from 'vue-router'
				Vue.use(VueRouter)
		- 使用vue-cil
			- $ vue add router
	- 基本使用
		- 添加一个页面: Test.vue
			<template>
			  <div class="about">
			    <h1>This is an test page</h1>
			  </div>
			</template>
		- 补充到路由 ./router/index.js
			const routes = [
			  {
			    path: '/test',
			    name: 'Test',
			    // route level code-splitting
			    // this generates a separate chunk (about.[hash].js) for this route
			    // which is lazy-loaded when the route is visited.
			    component: () => import(/* webpackChunkName: "about" */ '../views/Test.vue')
			  }
			  ]
		- 在界面上添加一个跳转
			<div id="nav">
			  <router-link to="/">Home</router-link> |
			  <router-link to="/about">About</router-link> |
			  <router-link to="/test">Test</router-link>
			</div>
	- 编程式的导航
		- router-link 组件是需要用户点击生效，如果需要动态加载，或者跳转前检查用户的权限，这个时候再使用router-link就不合适了
			- window.history 和 location 可以模拟用户操作浏览器
				location.assign('/')
				location.reload()
				history.back()
				history.forward()
			- vue-router 提供了一个函数用于js来控制路由那就是 push 功能和location.assign类似
				vm.router
				router.push(location, onComplete?, onAbort?)
				// location    location参数 等价于 <router-link :to="...">, 比如<router-link :to="/home">  等价于 router.push('/home')
				// onComplete  完成后的回调
				// onAbort     取消后的回调
			- 使用a标签
				<div id="nav">
				  <a @click="jumpToHome">Home</a> |
				  <a @click="jumpToAbout">About</a> |
				  <a @click="jumpToTest">Test</a>
				</div>
				<script>
				export default {
				  name: 'App',
				  data() {
				    return {
				    }
				  },
				  methods: {
				    jumpToHome() {
				      this.$router.push('/')
				    },
				    jumpToAbout() {
				      this.$router.push('/about')
				    },
				    jumpToTest() {
				 	  this.$router.push('/test')
				    }
				  },
				}
				</script>
	- 动态路由匹配
		- 前后端路由的区别
			后端:  path --->   handler
			前端:  path --->   view
		- 后端demo里面的http-router路由
			r.GET("/hosts", api.QueryHost)
			r.POST("/hosts", api.CreateHost)
			r.GET("/hosts/:id", api.DescribeHost)
			r.DELETE("/hosts/:id", api.DeleteHost)
			r.PUT("/hosts/:id", api.PutHost)
			r.PATCH("/hosts/:id", api.PatchHost)
		- 前端vue-router的路由
			模式                            匹配路径              $route.params
			/user/:username                 /user/evan            { username: 'evan' }
			/user/:username/post/:post_id   /user/evan/post/123   { username: 'evan', post_id: '123' }
		- 修改./router/index.js
			{
			  path: '/test/:id',
			  name: 'Test',
			  // route level code-splitting
			  // this generates a separate chunk (about.[hash].js) for this route
			  // which is lazy-loaded when the route is visited.
			  component: () => import(/* webpackChunkName: "about" */ '../views/Test.vue')
			}
	- 404处理
		- 如果找不页面，需要返回一个视图，告诉用户页面不存在
		- vue-router在处理404的方式和后端不同，路由依次匹配
			- 如果都匹配不上，写一个特殊的*路由作为 404路由
				{
				  path: '*',
				  name: '404',
				  // route level code-splitting
				  // this generates a separate chunk (about.[hash].js) for this route
				  // which is lazy-loaded when the route is visited.
				  component: () => import(/* webpackChunkName: "about" */ '../views/404.vue')
				}
	- 加载数据
		- 制作一个详情页面，根据不同的id，向后端获取不同的对象，用于显示
			- 请求id对应的后端数据，通过axios
				$ npm install --save axios  // axios@0.21.4
			- 需要将ajax封装下，添加一些通用逻辑，模块位于 utils/request.js
				import axios from 'axios'
				// create an axios instance
				const service = axios.create({
				    baseURL: 'http://localhost:8050', // url = base url + request url
				    // withCredentials: true, // send cookies when cross-domain requests
				    timeout: 5000 // request timeout
				})
				// request interceptor
				service.interceptors.request.use(
				    config => {
				      return config
				    },
				    error => {
				      // do something with request error
				      console.log(error) // for debug
				      return Promise.reject(error)
				    }
				)
				// response interceptor
				service.interceptors.response.use(
				    /**
				    * If you want to get http information such as headers or status
				    * Please return  response => response
				    */
				    
				    /**
				    * Determine the request status by custom code
				    * Here is just an example
				    * You can also judge the status by HTTP Status Code
				    */
				    response => {
				      const res = response.data
				      // if the custom code is not 20000, it is judged as an error.
				      if (res.code !== 0) {
				  	    // 比如 token过期
				      } else {
				  	    // 正常
				  	    return res
				      }
				    },
				    error => {
				      console.log('err' + error) // for debug
				      // 传递出去
				      return Promise.reject(error)
				    }
				)
				export default service
			- 新增一个api目录用于存放所有的API请求，在里面新建一个模块: test.js
				import request from '../utils/request'
				export function GET_TEST_DATA(id, query) {
				  return request({
				    url: `/hosts/${id}`,
				    method: 'get',
				    params: query
				  })
				}
			- 最后在视图中使用: Test.vue
				- 关于选择在什么时候加载数据，通常有2种方案
					- 导航完成之后获取: 先完成导航，然后在接下来的组件生命周期钩子中获取数据，在数据获取期间显示"加载中"之类的指示
					- 导航完成之前获取: 导航完成前，在路由进入的守卫中获取数据，在数据获取成功后执行导航
				- 方案一
					<script>
					import { GET_TEST_DATA } from '../api/test'
					export default {
					  name: 'Test',
					  data () {
					    return {
					      loading: false,
					      post: null,
					      error: null
					    }
					  },
					  created () {
					    // 组件创建完后获取数据，
					    // 此时 data 已经被 observed 了
					    this.fetchData()
					  },
					  watch: {
					    // 如果路由有变化，会再次执行该方法
					    '$route': 'fetchData'
					  },
					  methods: {
					    async fetchData () {
					      this.error = this.post = null
					      this.loading = true
					      // replace GET_TEST_DATA with your data fetching util / API wrapper
					      try {
					        this.loading = true
					        let resp = await GET_TEST_DATA(this.$route.params.id)
					        this.post = resp.data
					      } catch (err) {
					        this.error = err.toString()
					      } finally {
					        this.loading = false
					      }
						}
					  }
					}
					</script>
				- 方案二
					- 在router的钩子中获取数据
						beforeRouteEnter: 进入路由前
						beforeRouteUpdate: 路由update前
					- https://router.vuejs.org/zh/guide/advanced/data-fetching.html#%E5%9C%A8%E5%AF%BC%E8%88%AA%E5%AE%8C%E6%88%90%E5%89%8D%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE
	- Router对象
		- VueRouter源码
			export declare class VueRouter {
			  constructor(options?: RouterOptions)
			  
			  app: Vue
			  options: RouterOptions
			  mode: RouterMode
			  currentRoute: Route
			  
			  beforeEach(guard: NavigationGuard): Function
			  beforeResolve(guard: NavigationGuard): Function
			  afterEach(hook: (to: Route, from: Route) => any): Function
			  push(location: RawLocation): Promise<Route>
			  replace(location: RawLocation): Promise<Route>
			  push(
			    location: RawLocation,
			    onComplete?: Function,
			    onAbort?: ErrorHandler
			  ): void
			  replace(
			    location: RawLocation,
			    onComplete?: Function,
			    onAbort?: ErrorHandler
			  ): void
			  go(n: number): void
			  back(): void
			  forward(): void
			  match (raw: RawLocation, current?: Route, redirectedFrom?: Location): Route
			  getMatchedComponents(to?: RawLocation | Route): Component[]
			  onReady(cb: Function, errorCb?: ErrorHandler): void
			  onError(cb: ErrorHandler): void
			  addRoutes(routes: RouteConfig[]): void
			  
			  addRoute(parent: string, route: RouteConfig): void
			  addRoute(route: RouteConfig): void
			  getRoutes(): RouteRecordPublic[]
			  
			  resolve(
			    to: RawLocation,
			    current?: Route,
			    append?: boolean
			  ): {
			  location: Location
			  route: Route
			  href: string
			  // backwards compat
			  normalizedTo: Location
			    resolved: Route
			  }
			}
	- Router钩子
		- 在路由前后做一些额外的处理，可以通过路由留得钩子
		- 最常见的使用钩子的地方是认证，在访问页面的时候，判断用户是否有权限访问
		- router为提供了如下钩子
			beforeEach: 路由前处理
			beforeEnter
			beforeRouteEnter
			beforeRouteUpdate
			beforeRouteLeave
			afterEach: 路由后出来
		- 示例 设置钩子函数，做一个简单的页面加载progress bar
			- 使用最广泛的函数 beforeEach和afterEach
				router.beforeEach((to, from, next) => {
				  console.log(to, from, next)
				  next()
				})
				router.afterEach((to, from) => {
				  console.log(to, from)
				})
			- 选用nprogress库 https://www.npmjs.com/package/nprogress
				- 安装
					// nprogress@0.2.0
					$ npm install --save nprogress
				- 使用
					NProgress.start();
					NProgress.done();
					NProgress.set(0.0);     // Sorta same as .start()
					NProgress.set(0.4);
					NProgress.set(1.0);     // Sorta same as .done()
			- 代码
				- 引入库和样式
					import NProgress from 'nprogress' // progress bar
					import 'nprogress/nprogress.css'  // progress bar style
					// 路由开始时: NProgress.start();
					// 路由结束时: NProgress.done();
				- 修改router
					router.beforeEach((to, from, next) => {
					  // start progress bar
					  NProgress.start()
					  console.log(to, from, next)
					  next()
					})
					router.afterEach(() => {
					  // finish progress bar
					  NProgress.done()
					})
				- 调整颜色   找到样式，写入一个文件: styles/index.css，进行全局加载
					#nprogress .bar {
					    background:#13C2C2;
					  }
				- 在main.js加载全局样式
					// 加载全局样式
					import './styles/index.css'

15、Vue状态管理

16、参考
 - VUE2官方文档                   https://cn.vuejs.org/v2/guide/
 - 那些前端MVVM框架是如何诞生的   https://zhuanlan.zhihu.com/p/36453279
 - MVVM设计模式                   https://zhuanlan.zhihu.com/p/36141662 
 - vue核心之虚拟DOM(vdom)         https://www.jianshu.com/p/af0b398602bc















