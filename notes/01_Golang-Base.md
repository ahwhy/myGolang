# Golang-Base  Golangçš„åŸºç¡€è¯­æ³•

## ä¸€ã€Golangç®€ä»‹
- Goè¯­è¨€çš„ç¼–è¯‘
	- å†³å®šè¯­æ³•æ­£ç¡®çš„æ˜¯: åº•å±‚ç¼–è¯‘å™¨
	- ç¼–è¯‘çš„åŸºç¡€å•ä½: Lexical Token (è¯æ³•æ ‡è®°)ï¼Œå¦‚ `go/token` åŒ…

- Goè¯­è¨€çš„æ³¨é‡Š 
	- `// å•è¡Œæ³¨é‡Š`
	- `/* å¤šè¡Œæ³¨é‡Š */`
	- ç‰¹å®šåœºæ™¯æ³¨é‡Š: æ„å»ºæ³¨é‡Šï¼Œå¦‚: windowsï¼Œlinux  
	- åŒ…æ³¨é‡Šï¼ŒåŒ…æ–‡ä»¶å¼€å¤´æ³¨é‡Šç­‰  

- Goè¯­è¨€ä¸­å°†æ•°æ®ç±»å‹åˆ†ä¸ºå››ç±»: åŸºç¡€ç±»å‹ã€å¤åˆç±»å‹ã€å¼•ç”¨ç±»å‹å’Œæ¥å£ç±»å‹
	- åŸºç¡€ç±»å‹ï¼ŒåŒ…æ‹¬: æ•°å­—ã€å­—ç¬¦ä¸²å’Œå¸ƒå°”å‹
	- å¤åˆæ•°æ®ç±»å‹ï¼ŒåŒ…æ‹¬: æ•°ç»„å’Œç»“æ„ä½“ï¼Œå³é€šè¿‡ç»„åˆç®€å•ç±»å‹ï¼Œæ¥è¡¨è¾¾æ›´åŠ å¤æ‚çš„æ•°æ®ç»“æ„
	- å¼•ç”¨ç±»å‹ï¼ŒåŒ…æ‹¬æŒ‡é’ˆã€åˆ‡ç‰‡ã€å­—å…¸ã€å‡½æ•°ã€é€šé“ï¼Œè™½ç„¶æ•°æ®ç§ç±»å¾ˆå¤šï¼Œä½†å®ƒä»¬éƒ½æ˜¯å¯¹ç¨‹åºä¸­ä¸€ä¸ªå˜é‡æˆ–çŠ¶æ€çš„é—´æ¥å¼•ç”¨ï¼Œè¿™æ„å‘³ç€å¯¹ä»»ä¸€å¼•ç”¨ç±»å‹æ•°æ®çš„ä¿®æ”¹éƒ½ä¼šå½±å“æ‰€æœ‰è¯¥å¼•ç”¨çš„æ‹·è´
	- æ¥å£ç±»å‹


## äºŒã€ç¨‹åºç»“æ„

### 1. å‘½å&&å£°æ˜
- æ ‡è¯†ç¬¦: æ ‡è¯†ç¬¦æ˜¯ç¼–ç¨‹æ—¶æ‰€ä½¿ç”¨çš„åå­—ï¼Œç”¨äºç»™å˜é‡ã€å¸¸é‡ã€å‡½æ•°ã€ç±»å‹ã€æ¥å£ã€åŒ…åç­‰è¿›è¡Œå‘½åï¼Œä»¥å»ºç«‹åç§°å’Œä½¿ç”¨ä¹‹é—´çš„å…³ç³»

- å†…ç½®å¸¸é‡: `trueã€falseã€nilã€iota`

- å†…ç½®ç±»å‹: `boolã€byteã€runeã€intã€int8ã€int16ã€int32ã€int64ã€uintã€uint8ã€unit16ã€unit32ã€unit64ã€uintptrã€float32ã€float64ã€complex64ã€complex128ã€stringã€error`

- ç©ºç™½æ ‡è¯†ç¬¦: `_` ä½¿ç”¨ç©ºç™½æ ‡è¯†ç¬¦ï¼Œåˆ™æ— éœ€å¼•ç”¨

- å†…ç½®å‡½æ•°: `makeã€lenã€capã€newã€appendã€copyã€closeã€deleteã€complexã€realã€imagã€panicã€recover`

- 25 å…³é”®å­—

	Goè¯­è¨€ä¸­ç±»ä¼¼ifå’Œswitchçš„å…³é”®å­—æœ‰25ä¸ªï¼Œä¸”å…³é”®å­—ä¸èƒ½ç”¨äºè‡ªå®šä¹‰åå­—ï¼Œåªèƒ½åœ¨ç‰¹å®šè¯­æ³•ç»“æ„ä¸­ä½¿ç”¨
		- å¼•ç”¨åŒ…: `importã€package`
		- å®ä½“å£°æ˜å’Œå®šä¹‰: `constã€varã€typeã€funcã€interfaceã€mapã€structã€chan`
		- æµç¨‹æ§åˆ¶: `breakã€caseã€continueã€defaultã€deferã€elseã€fallthroughã€forã€goã€gotoã€ifã€rangeã€returnã€selectã€switch`

### 2. å˜é‡
- åœ¨å£°æ˜å˜é‡æ—¶ï¼Œå¦‚æœåˆå§‹åŒ–è¡¨è¾¾å¼è¢«çœç•¥ï¼Œé‚£ä¹ˆå°†ç”¨é›¶å€¼åˆå§‹åŒ–è¯¥å˜é‡
	- æ•°å€¼ç±»å‹å˜é‡å¯¹åº”çš„é›¶å€¼æ˜¯0
	- å¸ƒå°”ç±»å‹å˜é‡å¯¹åº”çš„é›¶å€¼æ˜¯false
	- å­—ç¬¦ä¸²ç±»å‹å¯¹åº”çš„é›¶å€¼æ˜¯ç©ºå­—ç¬¦ä¸²
	- æ¥å£æˆ–å¼•ç”¨ç±»å‹(åŒ…æ‹¬sliceã€mapã€chanå’Œå‡½æ•°)å˜é‡å¯¹åº”çš„é›¶å€¼æ˜¯nil
	- æ•°ç»„æˆ–ç»“æ„ä½“ç­‰èšåˆç±»å‹å¯¹åº”çš„é›¶å€¼æ˜¯æ¯ä¸ªå…ƒç´ æˆ–å­—æ®µéƒ½æ˜¯å¯¹åº”è¯¥ç±»å‹çš„é›¶å€¼

- åˆå§‹åŒ–è¡¨è¾¾å¼å¯ä»¥æ˜¯å­—é¢é‡æˆ–ä»»æ„çš„è¡¨è¾¾å¼
	- åœ¨åŒ…çº§åˆ«å£°æ˜çš„å˜é‡ä¼šåœ¨mainå…¥å£å‡½æ•°æ‰§è¡Œå‰å®Œæˆåˆå§‹åŒ–
	- å±€éƒ¨å˜é‡å°†åœ¨å£°æ˜è¯­å¥è¢«æ‰§è¡Œåˆ°çš„æ—¶å€™å®Œæˆåˆå§‹åŒ–

### 3. åŸºæœ¬è¯­å¥
```go
	// å½“å‰ç¨‹åºçš„åŒ…å, mainåŒ…è¡¨ç¤ºå…¥å£åŒ…, æ˜¯ç¼–è¯‘æ„å»ºçš„å…¥å£
	package main
	// å¯¼å…¥å…¶ä»–åŒ…
	import "fmt"
	// å¸¸é‡å®šä¹‰
	const PI = 3.1415
	// å…¨å±€å˜é‡å£°æ˜å’Œèµ‹å€¼     å˜é‡æœ¬è´¨: å†…å­˜åœ°å€; å€¼: æ•°æ®; å˜é‡èµ‹å€¼: ä¿®æ”¹å€¼ç©ºé—´é‡Œå­˜å‚¨çš„æ•°æ®; å˜é‡çš„å£°æ˜: å¼ºç±»å‹ -> å˜é‡æŒ‡å‘çš„å€¼ç©ºé—´ï¼Œå­˜å‚¨çš„æ•°æ®ï¼Œå—åˆ°ç±»å‹çš„é™åˆ¶; ä½œç”¨: å¤ç”¨ã€é…ç½®ã€ç®€æ´æ˜“è¯»
	var name = "fly"
	// å®šä¹‰"åˆ«å"ï¼Œcounterç±»å‹å®é™…è¿˜æ˜¯intï¼Œæ¯”å¦‚ rune ä¸º int32ï¼› byte ä¸º uint8
	type counter = int
	// ä¸€èˆ¬ç±»å‹å£°æ˜
	type newType int
	// å‡½æ•°å£°æ˜
	type myFun func(x, y int) int
	// ç»“æ„ä½“å£°æ˜
	type student struct{}
	// æ¥å£å£°æ˜
	type reader interface{}
	// ç¨‹åºå…¥å£
	func main() {
			fmt.Println("hello world, this is my first golang program!")
	}
```


## ä¸‰ã€åŸºç¡€æ•°æ®ç±»å‹
- ä»åº•å±‚è€Œè¨€ï¼Œæ‰€æœ‰çš„æ•°æ®éƒ½æ˜¯ç”±æ¯”ç‰¹ç»„æˆï¼Œä½†è®¡ç®—æœºä¸€èˆ¬æ“ä½œçš„æ˜¯å›ºå®šå¤§å°çš„æ•°ï¼Œå¦‚æ•´æ•°ã€æµ®ç‚¹æ•°ã€æ¯”ç‰¹æ•°ç»„ã€å†…å­˜åœ°å€ç­‰

- è¿›ä¸€æ­¥å°†è¿™äº›æ•°ç»„ç»‡åœ¨ä¸€èµ·ï¼Œå°±å¯è¡¨è¾¾æ›´å¤šçš„å¯¹è±¡ï¼Œä¾‹å¦‚æ•°æ®åŒ…ã€åƒç´ ç‚¹ã€è¯—æ­Œï¼Œç”šè‡³å…¶ä»–ä»»ä½•å¯¹è±¡

- Goè¯­è¨€æä¾›äº†ä¸°å¯Œçš„æ•°æ®ç»„ç»‡å½¢å¼ï¼Œè¿™ä¾èµ–äºGoè¯­è¨€å†…ç½®çš„æ•°æ®ç±»å‹

- è¿™äº›å†…ç½®çš„æ•°æ®ç±»å‹ï¼Œå…¼é¡¾äº†ç¡¬ä»¶çš„ç‰¹æ€§å’Œè¡¨è¾¾å¤æ‚æ•°æ®ç»“æ„çš„ä¾¿æ·æ€§

### 1. æ•´å‹
- Goè¯­è¨€åŒæ—¶æä¾›äº†æœ‰ç¬¦å·å’Œæ— ç¬¦å·ç±»å‹çš„æ•´æ•°è¿ç®—
	- `int8ã€int16ã€int32ã€int64` å››ç§æˆªç„¶ä¸åŒå¤§å°çš„æœ‰ç¬¦å·æ•´å½¢æ•°ç±»å‹ï¼Œåˆ†åˆ«å¯¹åº” `8ã€16ã€32ã€64bit` å¤§å°çš„æœ‰ç¬¦å·æ•´å½¢æ•°ï¼Œä¸æ­¤å¯¹åº”çš„æ˜¯ `uint8ã€uint16ã€uint32ã€uint64` å››ç§æ— ç¬¦å·æ•´å½¢æ•°ç±»å‹
	- `int ã€uint` ä¸¤ç§ä¸€èˆ¬å¯¹åº”ç‰¹å®š CPUå¹³å°æœºå™¨å­—å¤§å°çš„æœ‰ç¬¦å·å’Œæ— ç¬¦å·æ•´æ•°
		- å…¶ä¸­ intæ˜¯åº”ç”¨æœ€å¹¿æ³›çš„æ•°å€¼ç±»å‹
		- è¿™ä¸¤ç§ç±»å‹éƒ½æœ‰åŒæ ·çš„å¤§å°ï¼Œ32æˆ–64bitï¼Œä½†ä¸åŒçš„ç¼–è¯‘å™¨å³ä½¿åœ¨ç›¸åŒçš„ç¡¬ä»¶å¹³å°ä¸Šå¯èƒ½äº§ç”Ÿä¸åŒçš„å¤§å°
	- `rune` ç±»å‹çš„ Unicodeå­—ç¬¦æ˜¯å’Œ int32ç­‰ä»·çš„ç±»å‹ï¼Œé€šå¸¸ç”¨äºè¡¨ç¤ºä¸€ä¸ª Unicodeç ç‚¹
	- `byte` ç±»å‹çš„ Unicodeå­—ç¬¦æ˜¯å’Œ uint8ç­‰ä»·çš„ç±»å‹ï¼Œbyteç±»å‹ä¸€èˆ¬ç”¨äºå¼ºè°ƒæ•°å€¼æ˜¯ä¸€ä¸ªåŸå§‹çš„æ•°æ®è€Œä¸æ˜¯ä¸€ä¸ªå°çš„æ•´æ•°
	- `uintptr` ä¸€ç§æ— ç¬¦å·çš„æ•´æ•°ç±»å‹ï¼Œæ²¡æœ‰æŒ‡å®šå…·ä½“çš„ bitå¤§å°ä½†æ˜¯è¶³ä»¥å®¹çº³æŒ‡é’ˆ
		- uintptrç±»å‹åªæœ‰åœ¨åº•å±‚ç¼–ç¨‹æ˜¯æ‰éœ€è¦ï¼Œç‰¹åˆ«æ˜¯ Goè¯­è¨€å’Œ Cè¯­è¨€å‡½æ•°åº“æˆ–æ“ä½œç³»ç»Ÿæ¥å£ç›¸äº¤äº’çš„åœ°æ–¹

- ä¸ç®¡å®ƒä»¬çš„å…·ä½“å¤§å°ï¼Œintã€uintå’Œuintptræ˜¯ä¸åŒç±»å‹çš„å…„å¼Ÿç±»å‹
	- å…¶ä¸­ intå’Œ int32ä¹Ÿæ˜¯ä¸åŒçš„ç±»å‹ï¼Œå³ä½¿ intçš„å¤§å°ä¹Ÿæ˜¯ 32bitï¼Œåœ¨éœ€è¦å°† intå½“ä½œ int32ç±»å‹çš„åœ°æ–¹éœ€è¦ä¸€ä¸ªæ˜¾å¼çš„ç±»å‹è½¬æ¢æ“ä½œï¼Œåä¹‹äº¦ç„¶
	- å…¶ä¸­æœ‰ç¬¦å·æ•´æ•°é‡‡ç”¨ 2çš„è¡¥ç å½¢å¼è¡¨ç¤ºï¼Œä¹Ÿå°±æ˜¯æœ€é«˜bitä½ç”¨ä½œè¡¨ç¤ºç¬¦å·ä½ï¼Œä¸€ä¸ª n-bitçš„æœ‰ç¬¦å·æ•°çš„å€¼åŸŸæ˜¯ä» `-2^(n-1)` åˆ° `2^(n-1) - 1`
	- æ— ç¬¦å·æ•´æ•°çš„æ‰€æœ‰ bitä½éƒ½ç”¨äºè¡¨ç¤ºéè´Ÿæ•°ï¼Œå€¼åŸŸæ˜¯ `0` åˆ° `2^n - 1`
	- ä¾‹å¦‚ï¼Œint8ç±»å‹æ•´æ•°çš„å€¼åŸŸæ˜¯ä» -128åˆ° 127ï¼Œè€Œ uint8ç±»å‹æ•´æ•°çš„å€¼åŸŸæ˜¯ä» 0åˆ° 255

### 2. æµ®ç‚¹å‹
- Goè¯­è¨€æä¾›äº†ä¸¤ç§ç²¾åº¦çš„æµ®ç‚¹æ•°ï¼Œfloat32å’Œfloat64

- å®ƒä»¬çš„ç®—æœ¯è§„èŒƒç”±IEEE754æµ®ç‚¹æ•°å›½é™…æ ‡å‡†å®šä¹‰ï¼Œè¯¥æµ®ç‚¹æ•°è§„èŒƒè¢«æ‰€æœ‰ç°ä»£çš„CPUæ”¯æŒ

### 3. å¤æ•°
- Goè¯­è¨€æä¾›äº†ä¸¤ç§ç²¾åº¦çš„å¤æ•°ç±»å‹ï¼šcomplex64å’Œcomplex128ï¼Œåˆ†åˆ«å¯¹åº”float32å’Œfloat64ä¸¤ç§æµ®ç‚¹æ•°ç²¾åº¦

- å†…ç½®çš„complexå‡½æ•°ç”¨äºæ„å»ºå¤æ•°ï¼Œå†…å»ºçš„realå’Œimagå‡½æ•°åˆ†åˆ«è¿”å›å¤æ•°çš„å®éƒ¨å’Œè™šéƒ¨

### 4. å¸ƒå°”å‹
- ä¸€ä¸ªå¸ƒå°”ç±»å‹çš„å€¼åªæœ‰ä¸¤ç§ï¼štrueå’Œfalse

- ifå’Œforè¯­å¥çš„æ¡ä»¶éƒ¨åˆ†éƒ½æ˜¯å¸ƒå°”ç±»å‹çš„å€¼ï¼Œå¹¶ä¸”==å’Œ<ç­‰æ¯”è¾ƒæ“ä½œä¹Ÿä¼šäº§ç”Ÿå¸ƒå°”å‹çš„å€¼

### 5. å­—ç¬¦ä¸²
- å­—ç¬¦ä¸²æ˜¯ Go è¯­è¨€ä¸­çš„åŸºç¡€æ•°æ®ç±»å‹
	- è™½ç„¶å­—ç¬¦ä¸²å¾€å¾€è¢«çœ‹åšä¸€ä¸ªæ•´ä½“ï¼Œä½†æ˜¯å®ƒå®é™…ä¸Šæ˜¯ä¸€ç‰‡è¿ç»­çš„å†…å­˜ç©ºé—´ï¼Œä¹Ÿå¯ä»¥å°†å®ƒç†è§£æˆä¸€ä¸ªç”±å­—ç¬¦ç»„æˆçš„æ•°ç»„  
	- å­—ç¬¦ä¸²ä¸­çš„æ¯ä¸€ä¸ªå…ƒç´ å«åš"å­—ç¬¦"

- å­—ç¬¦ä¸²çš„æœ¬è´¨
	- å­—ç¬¦ä¸²æ˜¯ç”±å­—ç¬¦ç»„æˆçš„æ•°ç»„[]byte
	- æ•°ç»„ä¼šå ç”¨ä¸€ç‰‡è¿ç»­çš„å†…å­˜ç©ºé—´ï¼Œè€Œå†…å­˜ç©ºé—´å­˜å‚¨çš„å­—èŠ‚å…±åŒç»„æˆäº†å­—ç¬¦ä¸²
	- Goè¯­è¨€ä¸­çš„å­—ç¬¦ä¸²åªæ˜¯ä¸€ä¸ªåªè¯»çš„å­—èŠ‚æ•°ç»„
```go
		// runtime/string.go
		type stringStruct struct {
			str unsafe.Pointer
			len int
		}
```

- ä¸€ä¸ªå­—ç¬¦ä¸²æ˜¯ä¸€ä¸ªä¸å¯æ”¹å˜çš„å­—èŠ‚åºåˆ—
	- å­—ç¬¦ä¸²å¯ä»¥åŒ…å«ä»»æ„çš„æ•°æ®ï¼ŒåŒ…æ‹¬byteå€¼0ï¼Œä½†æ˜¯é€šå¸¸æ˜¯ç”¨æ¥åŒ…å«äººç±»å¯è¯»çš„æ–‡æœ¬
	- æ–‡æœ¬å­—ç¬¦ä¸²é€šå¸¸è¢«è§£é‡Šä¸ºé‡‡ç”¨UTF8ç¼–ç çš„Unicodeç ç‚¹(rune)åºåˆ—

- å†…ç½®çš„lenå‡½æ•°å¯ä»¥è¿”å›ä¸€ä¸ªå­—ç¬¦ä¸²ä¸­çš„å­—èŠ‚æ•°ç›®(ä¸æ˜¯runeå­—ç¬¦æ•°ç›®)
	- ç´¢å¼•æ“ä½œs[i]è¿”å›ç¬¬iä¸ªå­—èŠ‚çš„å­—èŠ‚å€¼ï¼Œiå¿…é¡»æ»¡è¶³0 â‰¤ i< len(s)æ¡ä»¶çº¦æŸ
	- è¯•å›¾è®¿é—®è¶…å‡ºå­—ç¬¦ä¸²ç´¢å¼•èŒƒå›´çš„å­—èŠ‚å°†ä¼šå¯¼è‡´panicå¼‚å¸¸ `panic: index out of range`
	- å­å­—ç¬¦ä¸²æ“ä½œs[i:j]åŸºäºåŸå§‹çš„så­—ç¬¦ä¸²çš„ç¬¬iä¸ªå­—èŠ‚å¼€å§‹åˆ°ç¬¬jä¸ªå­—èŠ‚(å¹¶ä¸åŒ…å«jæœ¬èº«)ç”Ÿæˆä¸€ä¸ªæ–°å­—ç¬¦ä¸²ï¼Œæˆçš„æ–°å­—ç¬¦ä¸²å°†åŒ…å«j-iä¸ªå­—èŠ‚

- å­—ç¬¦ä¸²èµ‹å€¼
```go
	s1 := "My name is å°æ˜ğŸ˜€"                         // å­—ç¬¦ä¸²é‡Œå¯ä»¥åŒ…å«ä»»æ„Unicodeå­—æ¡
	s2 := "He say:\"i'm fine.\" \n\\Thank\tyou.\\"    // åŒ…å«è½¬ä¹‰å­—ç¬¦
	s3 := `There is first line.
	
	There is third line.`                             // åå¼•å·é‡Œçš„è½¬ä¹‰å­—ç¬¦æ— æ•ˆï¼Œåå¼•å·é‡Œçš„å†…å®¹åŸå°ä¸åŠ¨åœ°è¿›è¡Œè¾“å‡ºï¼ŒåŒ…æ‹¬ç©ºç™½ç¬¦å’Œæ¢è¡Œç¬¦
```

- å­—ç¬¦ä¸²æ˜¯ä¸å¯ä¿®æ”¹çš„ï¼Œä¿®æ”¹å­—ç¬¦ä¸²å†…éƒ¨æ•°æ®çš„æ“ä½œä¹Ÿæ˜¯è¢«ç¦æ­¢çš„
```go
	s[0] = 'L' // compile error: cannot assign to s[0]
```
	- ä¸å˜æ€§æ„å‘³å¦‚æœä¸¤ä¸ªå­—ç¬¦ä¸²å…±äº«ç›¸åŒçš„åº•å±‚æ•°æ®çš„è¯ä¹Ÿæ˜¯å®‰å…¨çš„ï¼Œè¿™ä½¿å¾—å¤åˆ¶ä»»ä½•é•¿åº¦çš„å­—ç¬¦ä¸²ä»£ä»·æ˜¯ä½å»‰çš„
	- åŒæ ·ï¼Œä¸€ä¸ªå­—ç¬¦ä¸²så’Œå¯¹åº”çš„å­å­—ç¬¦ä¸²åˆ‡ç‰‡s[7:]çš„æ“ä½œä¹Ÿå¯ä»¥å®‰å…¨åœ°å…±äº«ç›¸åŒçš„å†…å­˜ï¼Œå› æ­¤å­—ç¬¦ä¸²åˆ‡ç‰‡æ“ä½œä»£ä»·ä¹Ÿæ˜¯ä½å»‰çš„
	- åœ¨è¿™ä¸¤ç§æƒ…å†µä¸‹éƒ½æ²¡æœ‰å¿…è¦åˆ†é…æ–°çš„å†…å­˜

- `+` æ“ä½œç¬¦å°†ä¸¤ä¸ªå­—ç¬¦ä¸²é“¾æ¥æ„é€ ä¸€ä¸ªæ–°å­—ç¬¦ä¸²

- byte å’Œ rune
	- string ä¸­æ¯ä¸ªå…ƒç´ å«"å­—ç¬¦"ï¼Œå­—ç¬¦æœ‰ä¸¤ç§
		- byte: 1ä¸ªå­—èŠ‚ï¼Œä»£è¡¨ ASCLLç  çš„ä¸€ä¸ªå­—ç¬¦
		- rune: 4ä¸ªå­—èŠ‚ï¼Œä»£è¡¨ä¸€ä¸ª UTF-8å­—ç¬¦ï¼Œä¸€ä¸ªæ±‰å­—å¯ç”¨ä¸€ä¸ª rune è¡¨ç¤º
	- string åº•å±‚æ˜¯byteæ•°ç»„ï¼Œstringçš„é•¿åº¦å°±æ˜¯è¯¥byteæ•°ç»„çš„é•¿åº¦ï¼ŒUTF-8 ç¼–ç ä¸‹ä¸€ä¸ªæ±‰å­—å  3ä¸ªbyteï¼Œå³ä¸€ä¸ªæ±‰å­—å 3ä¸ªé•¿åº¦
	- string å¯ä»¥è½¬æ¢ä¸º []byte æˆ– []rune ç±»å‹

- å¼ºåˆ¶ç±»å‹è½¬æ¢
	- byte  å’Œ int å¯ä»¥ç›¸äº’è½¬æ¢
	- float å’Œ int å¯ä»¥ç›¸äº’è½¬æ¢ï¼Œå°æ•°ä½ä¼šä¸¢å¤±
	- boot  å’Œ int ä¸å¯ä»¥ç›¸äº’è½¬æ¢
	- ä¸åŒé•¿åº¦çš„ int å’Œ float ä¹‹é—´å¯ä»¥ç›¸äº’è½¬æ¢
	- string å¯ä»¥è½¬æ¢ä¸º []byte æˆ– []rune ç±»å‹ï¼Œbyte æˆ– rune ç±»å‹å¯ä»¥è½¬æ¢ä¸ºstring
	- ä½ç²¾åº¦å‘é«˜ç²¾åº¦è½¬æ¢æ²¡æœ‰é—®é¢˜ï¼Œé«˜ç²¾åº¦å‘ä½ç²¾åº¦è½¬æ¢ä¼šä¸¢å¤±ä½æ•°
	- æ— ç¬¦å·å‘æœ‰ç¬¦å·è½¬æ¢ï¼Œæœ€é«˜ä½æ˜¯æ— ç¬¦å·

### 6. å¸¸é‡
- å¸¸é‡è¡¨è¾¾å¼çš„å€¼åœ¨ç¼–è¯‘æœŸè®¡ç®—ï¼Œè€Œä¸æ˜¯åœ¨è¿è¡ŒæœŸï¼Œæ¯ç§å¸¸é‡çš„æ½œåœ¨ç±»å‹éƒ½æ˜¯åŸºç¡€ç±»å‹: boolã€stringæˆ–æ•°å­—

- ä¸€ä¸ªå¸¸é‡çš„å£°æ˜è¯­å¥å®šä¹‰äº†å¸¸é‡çš„åå­—ï¼Œå’Œå˜é‡çš„å£°æ˜è¯­æ³•ç±»ä¼¼ï¼Œå¸¸é‡çš„å€¼ä¸å¯ä¿®æ”¹ï¼Œè¿™æ ·å¯ä»¥é˜²æ­¢åœ¨è¿è¡ŒæœŸè¢«æ„å¤–æˆ–æ¶æ„çš„ä¿®æ”¹

### 7. å…¶ä»–
- æ“ä½œç¬¦
	- ç®—æœ¯è¿ç®—ç¬¦: `+ã€-ã€*ã€/ã€%ã€++ã€--` i++ ä¸ºè¡¨è¾¾å¼ï¼Œéè¯­å¥ï¼Œæ— æ³•èµ‹å€¼ç»™å˜é‡
	- å…³ç³»è¿ç®—ç¬¦: `>ã€>=ã€<ã€<=ã€==ã€!=` åˆ¤æ–­ A ä¸ B çš„å…³ç³»ï¼Œç»“æ„: å¸ƒå°”å€¼ï¼Œæ³¨æ„å‡½æ•°ä¸å¯ä»¥æ¯”è¾ƒ
	- é€»è¾‘è¿ç®—ç¬¦: `&&ã€||ã€!` &&å¯¹åº”é€»è¾‘ä¹˜æ³•ï¼Œ||å¯¹åº”é€»è¾‘åŠ æ³•ï¼Œä¹˜æ³•æ¯”åŠ æ³•ä¼˜å…ˆçº§è¦é«˜
	- ä½è¿ç®—ç¬¦: `&ã€|ã€^ã€<<ã€>>ã€&^` x<<n å·¦ç§»è¿ç®—ç­‰ä»·äºä¹˜ä»¥2^nï¼Œx>>n å³ç§»è¿ç®—ç­‰ä»·äºé™¤ä»¥ 2^n
	- èµ‹å€¼è¿ç®—ç¬¦: `=ã€+=ã€-=ã€*=ã€/=ã€%=ã€&=ã€|=ã€^=ã€<<=ã€>>=` å€¼å¯èƒ½æ˜¯æ•°æ®ï¼Œä¹Ÿå¯èƒ½æ˜¯åœ°å€
	- å…¶ä»–è¿ç®—ç¬¦: `&(å•ç›®)ã€*(å•ç›®)ã€.(ç‚¹)ã€-(å•ç›®)ã€â€¦ã€<-` å•ç›®è¿ç®—ç¬¦ä¼˜å…ˆçº§æœ€é«˜
	- å ä½ç¬¦: `_` /dev/null 1B<>,_ å°±æ˜¯ä¸¢å¼ƒå€¼  

- åˆ†å‰²ç¬¦
	- `()`å°æ‹¬å·  `[]`ä¸­æ‹¬å·  `{}`å¤§æ‹¬å·  `;`åˆ†å·  `,`é€—å·  

- åŸºç¡€æ•°æ®ç±»å‹
	|ç±»å‹|é•¿åº¦(å­—èŠ‚byte)|é»˜è®¤å€¼|è¯´æ˜|
	|:------:|:------:|:------:|:------:|
	|bool|1|false|2^8|
	|byte|1|0|uint8, å–å€¼èŒƒå›´[0, 255], 2^8|
	|rune|4|0|Unicode Code Point, int32 , 2^32|
	|int, uint|4æˆ–8|0|32 æˆ– 64 ä½, å–å†³äºæ“ä½œç³»ç»Ÿ, 2^16 æˆ– 2^32|
	|int8, uint8|1|0|å–å€¼èŒƒå›´[-128, 127], [0, 255]|
	|int16, uint16|2|0|å–å€¼èŒƒå›´[-32768, 32767], [0, 65535]|
	|int32, uint32|4|0|å–å€¼èŒƒå›´[-21äº¿, 21äº¿], [0, 42äº¿], rune æ˜¯ int32 çš„åˆ«å|
	|int64, uint64|8|0|2^64|
	|float32|4|0.0|uint8ï¼Œå–å€¼èŒƒå›´[0, 255]ï¼Œ2^8|
	|float64|8|0.0|uint8ï¼Œå–å€¼èŒƒå›´[0, 255]ï¼Œ2^8|
	|complex64|8|||
	|complex128|16|||
	|uintptr|4æˆ–8||ä»¥å­˜å‚¨æŒ‡é’ˆçš„ uint32 æˆ– uint64 æ•´æ•°|

- å¤åˆæ•°æ®ç±»å‹
	|ç±»å‹|é•¿åº¦(å­—èŠ‚byte)|é»˜è®¤å€¼|è¯´æ˜|
	|:------:|:------:|:------:|:------:|
	|array|||å€¼ç±»å‹|
	|struct|||å€¼ç±»å‹|
	|string|16bytes(4 * 4)|""|UTF-8 å­—ç¬¦ä¸², string = 2*int64 = 2*8bytes, []byte(string)|
	|slice|24bytes|nil|å¼•ç”¨ç±»å‹, åˆ‡ç‰‡çš„æœ¬è´¨æ˜¯ä¸€ä¸ªsliceç»“æ„ä½“æŒ‡é’ˆï¼ŒæŒ‡é’ˆä¸ºä¸€ä¸ªuint64å†…å­˜åœ°å€ï¼Œé»˜è®¤å€¼ä¸º0ï¼Œé•¿åº¦ä¸º24|
	|map||nil|å¼•ç”¨ç±»å‹|
	|channel||nil|å¼•ç”¨ç±»å‹|
	|interface||nil|æ¥å£|
	|function||nil|å‡½æ•°|

- æ•°æ®å•ä½
```
		1Word(å­—) = 2Bytes(å­—èŠ‚)
		1Byte = 8bit(ä½)  // 2^8
		1KB   = 1024B
		1MB   = 1024KB
		1GB   = 1024Mb
		1TB   = 1024GB
```


## å››ã€æµç¨‹æ§åˆ¶

### 1. æ¡ä»¶è¯­å¥ - ifè¯­å¥
- å¯¹äºæ¡ä»¶è¯­å¥å¿…é¡»æœ‰ if è¯­å¥ï¼Œå¯ä»¥æœ‰ 0 ä¸ªæˆ–å¤šä¸ª else if è¯­å¥ ï¼Œæœ€å¤šæœ‰ 1 ä¸ª else è¯­å¥
 
- ifåµŒå¥—
```go
	if bool1 {
		/* bool1 = true */
	} else {
		if bool2 {
			/* bool2 = true */
		} else {
			if bool3 {
			/* bool3 = true */
			} else {
				/* bool3 = false */
				}
			}
		}
```

- å¤šé‡åˆ¤æ–­
```go
	if bool1 {
		/* bool1 = true */
	} else if boolè¡¨è¾¾å¼2 {
		/* bool2 = true */
	} else if boolè¡¨è¾¾å¼3 {
		/* bool3 = true */
	} else {
		/* bool = false */
	}
```

### 2. é€‰æ‹©è¯­å¥ - switch
- å¯¹äºé€‰æ‹©è¯­å¥å¯ä»¥æœ‰0ä¸ªæˆ–å¤šä¸ªcaseè¯­å¥ï¼Œæœ€å¤šæœ‰1ä¸ªdefaultè¯­å¥é€‰æ‹©æ¡ä»¶ä¸ºtrueçš„caseè¯­å¥å—å¼€å§‹æ‰§è¡Œå¹¶é€€å‡º
 
- è‹¥æ‰€æœ‰æ¡ä»¶ä¸ºfalseï¼Œåˆ™æ‰§è¡Œdefaultè¯­å¥å—å¹¶é€€å‡º

- å¯ä»¥é€šè¿‡fallthroughä¿®æ”¹æ‰§è¡Œé€€å‡ºè¡Œä¸ºï¼Œç»§ç»­æ‰§è¡Œä¸‹ä¸€æ¡çš„caseæˆ–defaultè¯­å¥å—
```go
	switch var1 {
	case var2 :
		...
		fallthrough  // åªè¦æ‰§è¡ŒæˆåŠŸï¼Œå°±æ— è§†case2çš„æ¡ä»¶ï¼Œå¼ºåˆ¶æ‰§è¡Œä¸‹ä¸€ä¸ªè¯­å¥
	case var3 :
		...
	case var4,var5 :
		...
		if(...){
			break
		}
		fallthrough // æ­¤æ—¶switchä¼šæ‰§è¡Œcase3å’Œcase4ï¼Œä½†æ˜¯å¦‚æœæ»¡è¶³ifæ¡ä»¶ï¼Œåˆ™åªæ‰§è¡Œcase3
	case var6 :
		...
	default:
		...
	}
```

### 3. å¾ªç¯è¯­å¥ - for
- åŸºæœ¬ç”¨æ³•
	- åŸºæœ¬è¡¨è¾¾å¼
```go
		for init; condition; post { 
			...
		}
```
		- init:  ä¸€èˆ¬ä¸ºèµ‹å€¼è¡¨è¾¾å¼ï¼Œç»™æ§åˆ¶å˜é‡èµ‹åˆå€¼
		- condition:  å…³ç³»è¡¨è¾¾å¼æˆ–é€»è¾‘è¡¨è¾¾å¼ï¼Œå¾ªç¯æ§åˆ¶æ¡ä»¶
		- post:  ä¸€èˆ¬ä¸ºèµ‹å€¼è¡¨è¾¾å¼ï¼Œç»™æ§åˆ¶å˜é‡å¢é‡æˆ–å‡é‡
		- æ‰§è¡Œé¡ºåºä¸º
			a) åˆå§‹åŒ–å­è¯­å¥ init
			b) æ¡ä»¶å­è¯­å¥   condition
			c) è¯­å¥å—
			d) åç½®å­è¯­å¥   post
			e) b -->c -->d
			f) ç›´åˆ°æ¡ä»¶å­è¯­å¥ä¸º false ç»“æŸå¾ªç¯
	- break     ç”¨äºè·³å‡ºå¾ªç¯ï¼Œå½“æ¡ä»¶æ»¡è¶³åˆ™ç»“æŸå¾ªç¯
	- continue  ç”¨äºè·³è¿‡å¾ªç¯ï¼Œå½“æ¡ä»¶æ»¡è¶³è¿™è·³è¿‡æœ¬æ¬¡å¾ªç¯è¿›è¡Œåç½®æˆ–æ¡ä»¶å­è¯­å¥æ‰§è¡Œ
	
- ç±»while
	- forå­è¯­å¥å¯ä»¥åªä¿ç•™æ¡ä»¶å­è¯­å¥ï¼Œæ­¤æ—¶ç±»ä¼¼äºå…¶ä»–è¯­è¨€ä¸­çš„ while å¾ªç¯
```go
		for condition { 
			...
		}
```

- æ— é™å¾ªç¯
	- forå­è¯­å¥å…¨éƒ¨çœç•¥ï¼Œåˆ™ä¸ºæ— é™å¾ªç¯(æ­»å¾ªç¯)ï¼Œå¸¸ä¸ break ç»“åˆä½¿ç”¨
	- `for i := 0;;i++`
	- `for ;; { }`
	- `for true { }`
	- `for { }`

- for-range 
	- ç”¨äºéå† å¯è¿­ä»£å¯¹è±¡ä¸­çš„æ¯ä¸ªå…ƒç´ ï¼Œä¾‹å¦‚å­—ç¬¦ä¸²ï¼Œæ•°ç»„ï¼Œåˆ‡ç‰‡ï¼Œæ˜ å°„ï¼Œé€šé“ ç­‰
	- é’ˆå¯¹åŒ…å«Unicode å­—ç¬¦çš„å­—ç¬¦ä¸²éå†æ˜¯éœ€è¦ä½¿ç”¨ for range
	- range è¿”å›ä¸¤ä¸ªå…ƒç´ åˆ†åˆ«ä¸ºå­—èŠ‚ç´¢å¼•index å’Œ rune å­—ç¬¦ï¼Œå¯é€šè¿‡ç©ºç™½æ ‡è¯†ç¬¦_ å¿½ç•¥éœ€è¦æ¥æ”¶çš„å˜é‡
```go
		for index,value := range iterable {
			...
		}
```

- label ä¸ goto
	- é€šè¿‡ goto è¯­å¥ä»»æ„è·³è½¬åˆ°å½“å‰å‡½æ•°æŒ‡å®šçš„ label ä½ç½®

- åµŒå¥—å¾ªç¯:
```go
	for [condition |  ( init; condition; increment ) | Range] {
		for [condition |  ( init; condition; increment ) | Range]{
			statement(s);
		}
		statement(s);
	}
```

### 4. ç¤ºä¾‹
- ä¹˜æ³•å£è¯€è¡¨
	- æ­£ä¸‰è§’
```go
		for i := 1; i < 10; i++ {
				for j := 1; j <= i; j++ {
						fmt.Printf("%-2d * %-2d = %-2d\t", j, i, i*j)
				}
				fmt.Println()
		}
```
	- å€’ä¸‰è§’
```go
		for i := 1; i < 10; i++ {
			for j := 1; j < i; j++ {
				var n string
				fmt.Printf("%-2s   %-2s   %-2s\t", n, n, n)
			}
			for j := i; j < 10; j++ {
				fmt.Printf("%-2d * %-2d = %-2d\t", j, i, i*j)
			}
			fmt.Println()
		}
```

- æ±‚100ä»¥å†…ç´ æ•°çš„å’Œ
```go
	var sum int
	i := 2
	var isP bool
	for i < 101 {
			isP = true
			j := 2
			for j <= (i / j) {
					if i%j == 0 {
							// fmt.Printf("%dä¸æ˜¯ç´ æ•°\n",i)
							isP = false
							break
					}
					j++
			}
			if isP {
					fmt.Printf("%dæ˜¯ç´ æ•°\n", i)
					sum += i
			}
			i++
	}
	fmt.Println(sum)
	}
```


## äº”ã€å¤åˆæ•°æ®ç±»å‹
 - åŸºæœ¬æ•°æ®ç±»å‹ï¼Œç”¨ä»¥æ„å»ºç¨‹åºä¸­æ•°æ®ç»“æ„ï¼Œæ˜¯Goè¯­è¨€çš„ä¸–ç•Œçš„åŸå­
 
 - å¤åˆæ•°æ®ç±»å‹ï¼Œä»¥ä¸åŒçš„æ–¹å¼ç»„åˆåŸºæœ¬ç±»å‹ï¼Œæ„é€ å‡ºæ¥çš„å¤åˆæ•°æ®ç±»å‹
	- æ•°ç»„å’Œç»“æ„ä½“æ˜¯èšåˆç±»å‹ï¼Œå®ƒä»¬çš„å€¼ç”±è®¸å¤šå…ƒç´ æˆ–æˆå‘˜å­—æ®µçš„å€¼ç»„æˆ
		- æ•°ç»„æ˜¯ç”±åŒæ„çš„å…ƒç´ ç»„æˆâ€”â€”æ¯ä¸ªæ•°ç»„å…ƒç´ éƒ½æ˜¯å®Œå…¨ç›¸åŒçš„ç±»å‹
		- ç»“æ„ä½“åˆ™æ˜¯ç”±å¼‚æ„çš„å…ƒç´ ç»„æˆçš„
	- æ•°ç»„å’Œç»“æ„ä½“éƒ½æ˜¯æœ‰å›ºå®šå†…å­˜å¤§å°çš„æ•°æ®ç»“æ„
	- è€Œ slice å’Œ map åˆ™æ˜¯åŠ¨æ€çš„æ•°æ®ç»“æ„ï¼Œå®ƒä»¬å°†æ ¹æ®éœ€è¦åŠ¨æ€å¢é•¿

### 1. æ•°ç»„ array
- æ•°ç»„æ˜¯å…·æœ‰ç›¸åŒæ•°æ®ç±»å‹çš„æ•°æ®é¡¹ç»„æˆçš„ä¸€ç»„é•¿åº¦å›ºå®šçš„åºåˆ—ï¼Œæ•°æ®é¡¹å«åšæ•°ç»„çš„å…ƒç´ ï¼Œæ•°ç»„çš„é•¿åº¦å¿…é¡»æ˜¯éè´Ÿæ•´æ•°çš„å¸¸é‡ï¼Œé•¿åº¦ä¹Ÿæ˜¯ç±»å‹çš„ä¸€éƒ¨åˆ†
	- å ç”¨å†…å­˜ç©ºé—´ = length * æ•°æ®ç±»å‹çš„å­—èŠ‚å¤§å°
	- æ•°ç»„çš„é•¿åº¦æ˜¯æ•°ç»„ç±»å‹çš„ä¸€ä¸ªç»„æˆéƒ¨åˆ†ï¼Œå› æ­¤[3]intå’Œ[4]intæ˜¯ä¸¤ç§ä¸åŒçš„æ•°ç»„ç±»å‹
	- æ•°ç»„çš„é•¿åº¦å¿…é¡»æ˜¯å¸¸é‡è¡¨è¾¾å¼ï¼Œå› ä¸ºæ•°ç»„çš„é•¿åº¦éœ€è¦åœ¨ç¼–è¯‘é˜¶æ®µç¡®å®š

- å½“åœ¨Goä¸­å£°æ˜ä¸€ä¸ªæ•°ç»„ä¹‹åï¼Œä¼šåœ¨å†…å­˜ä¸­å¼€è¾Ÿä¸€æ®µå›ºå®šé•¿åº¦çš„ã€è¿ç»­çš„ç©ºé—´å­˜æ”¾æ•°ç»„ä¸­çš„å„ä¸ªå…ƒç´ ï¼Œè¿™äº›å…ƒç´ çš„æ•°æ®ç±»å‹å®Œå…¨ç›¸åŒï¼Œå¯ä»¥æ˜¯å†…ç½®çš„ç®€å•æ•°æ®ç±»å‹(intã€stringç­‰)ï¼Œä¹Ÿå¯ä»¥æ˜¯è‡ªå®šä¹‰çš„structç±»å‹
	- å›ºå®šé•¿åº¦: è¿™æ„å‘³ç€æ•°ç»„ä¸å¯å¢é•¿ã€ä¸å¯ç¼©å‡ï¼›æƒ³è¦æ‰©å±•æ•°ç»„ï¼Œåªèƒ½åˆ›å»ºæ–°æ•°ç»„ï¼Œå°†åŸæ•°ç»„çš„å…ƒç´ å¤åˆ¶åˆ°æ–°æ•°ç»„
	- è¿ç»­ç©ºé—´: è¿™æ„å‘³å¯ä»¥åœ¨ç¼“å­˜ä¸­ä¿ç•™çš„æ—¶é—´æ›´é•¿ï¼Œæœç´¢é€Ÿåº¦æ›´å¿«ï¼Œæ˜¯ä¸€ç§éå¸¸é«˜æ•ˆçš„æ•°æ®ç»“æ„ï¼ŒåŒæ—¶è¿˜æ„å‘³ç€å¯ä»¥é€šè¿‡æ•°å€¼indexçš„æ–¹å¼è®¿é—®æ•°ç»„ä¸­çš„æŸä¸ªå…ƒç´ 
	- æ•°æ®ç±»å‹: æ„å‘³ç€é™åˆ¶äº†æ¯ä¸ªblockä¸­å¯ä»¥å­˜æ”¾ä»€ä¹ˆæ ·çš„æ•°æ®ï¼Œä»¥åŠæ¯ä¸ªblockå¯ä»¥å­˜æ”¾å¤šå°‘å­—èŠ‚çš„æ•°æ®

- å£°æ˜ && åˆå§‹åŒ–
	- æŒ‡å®šæ•°ç»„é•¿åº¦ `var name [length]type = [length]type{v1, v2, â€¦,vlength}`
	- ä½¿ç”¨åˆå§‹åŒ–å…ƒç´ æ•°é‡æ¨åˆ°æ•°ç»„é•¿åº¦ `name := [...]type{v1, v2, â€¦,vlength}`
	- å¯¹æŒ‡å®šä½ç½®å…ƒç´ è¿›è¡Œåˆå§‹åŒ–  `var name [length]type = [length]type{im:vm, â€¦, sin:in}`
```go
		type Currency int
		
		const (
			USD Currency = iota // ç¾å…ƒ
			EUR                 // æ¬§å…ƒ
			GBP                 // è‹±é•‘
			RMB                 // äººæ°‘å¸
		)
		
		symbol := [...]string{USD: "$", EUR: "â‚¬", GBP: "ï¿¡", RMB: "ï¿¥"}
		
		fmt.Println(RMB, symbol[RMB]) // "3 ï¿¥"
```

- æ•°ç»„çš„æ¯”è¾ƒ
	- å¦‚æœä¸€ä¸ªæ•°ç»„çš„å…ƒç´ ç±»å‹æ˜¯å¯ä»¥ç›¸äº’æ¯”è¾ƒçš„ï¼Œé‚£ä¹ˆæ•°ç»„ç±»å‹ä¹Ÿæ˜¯å¯ä»¥ç›¸äº’æ¯”è¾ƒçš„
	- å¯ä»¥ç›´æ¥é€šè¿‡ ==æ¯”è¾ƒè¿ç®—ç¬¦ æ¥æ¯”è¾ƒä¸¤ä¸ªæ•°ç»„ï¼Œåªæœ‰å½“ä¸¤ä¸ªæ•°ç»„çš„æ‰€æœ‰å…ƒç´ éƒ½æ˜¯ç›¸ç­‰çš„æ—¶å€™æ•°ç»„æ‰æ˜¯ç›¸ç­‰çš„
	- ä¸ç›¸ç­‰ æ¯”è¾ƒè¿ç®—ç¬¦!= éµå¾ªåŒæ ·çš„è§„åˆ™
	- åˆ‡ç‰‡ä¸ºå¼•ç”¨ç±»å‹ï¼Œä¸èƒ½æ¯”è¾ƒ
```go
		a := [2]int{1, 2}
		b := [...]int{1, 2}
		c := [2]int{1, 3}
		fmt.Println(a == b, a == c, b == c) // "true false false"
		d := [3]int{1, 2}
		fmt.Println(a == d) // compile error: cannot compare [2]int == [3]int
```

- æŒ‡é’ˆæ•°ç»„
	- å£°æ˜ä¸€ä¸ªæŒ‡é’ˆç±»å‹çš„æ•°ç»„ï¼Œè¿™æ ·æ•°ç»„ä¸­å°±å¯ä»¥å­˜æ”¾æŒ‡é’ˆ
	- æŒ‡é’ˆçš„é»˜è®¤åˆå§‹åŒ–å€¼ä¸ºnil
```go
		a := [4]*int{0: new(int), 3: new(int)}   // [0xc00011a300 <nil> <nil> 0xc00011a308]
		a[1] = new(int)                          // ç©ºæŒ‡é’ˆç›´æ¥èµ‹å€¼ä¼šæŠ¥é”™
		*a[1] = 10                               // [0xc00011a300 0xc00011a310 <nil> 0xc00011a308]
		b := a                                   // [0xc00011a300 0xc00011a310 <nil> 0xc00011a308]

		func zero(ptr *[32]byte) {
			*ptr = [32]byte{}
		}
```

- éå†æ•°ç»„
```go
	for i := 0; i < len(name); i++ {
			fmt.Println(i, name[i])
	}
	
	for i, j := range name {
			fmt.Printf("%d %q\n", i, j)
	}
```

- å¤šç»´æ•°ç»„
	- å£°æ˜ && åˆå§‹åŒ–
```go
		var name [vlength][vvlength]type = [vlength][vvlength]type{{v1,v2, â€¦,vvlength}, {v1,v2, â€¦,vvlength}, â€¦,{vlength,vvlength}}
		name := [...][vvlength]type{{v1,v2, â€¦,vvlength}, {v1,v2, â€¦,vvlength}, â€¦,{vlength,vvlength}}  // å¤šç»´æ•°ç»„åªæœ‰ç¬¬ä¸€ç»´é•¿åº¦å¯ä½¿ç”¨å˜é‡æ•°é‡æ¨æµ‹
		name := [vlength][vvlength]type{0:{0:v1,3:v2},5:{2:v1,5:v2, â€¦,m:v3}, â€¦,n:{6:v1,m:vvlength}}
```
	- éå†
```go
		for i := 0; i < len(name); i++ {
				for j := 0; j < len(name[i]); j++ {
						fmt.Printf("[%d ,%d]: %q\n", i, j, name[i][j]) 
				}
		}
		
		for i, line := range name {
				for n, m := range line {
						fmt.Printf("[%d ,%d]: %q\n", i, n, m)
				}
		}
```

### 2. åˆ‡ç‰‡ slice
- åˆ‡ç‰‡æ˜¯é•¿åº¦å¯å˜çš„'æ•°ç»„'ï¼Œå³ å…·æœ‰ç›¸åŒæ•°æ®ç±»å‹çš„æ•°æ®é¡¹ç»„æˆçš„ä¸€ç»„é•¿åº¦å¯å˜çš„åºåˆ— ï¼Œåˆ‡ç‰‡ç”±ä¸‰éƒ¨åˆ†ç»„æˆ
	- æŒ‡é’ˆ(array): æŒ‡å‘ ç¬¬ä¸€ä¸ªsliceå…ƒç´ å¯¹åº”çš„åº•å±‚æ•°ç»„å…ƒç´ çš„åœ°å€ï¼Œè¦æ³¨æ„çš„æ˜¯sliceçš„ç¬¬ä¸€ä¸ªå…ƒç´ å¹¶ä¸ä¸€å®šå°±æ˜¯æ•°ç»„çš„ç¬¬ä¸€ä¸ªå…ƒç´ 
	- é•¿åº¦(length): åˆ‡ç‰‡å…ƒç´ çš„æ•°é‡
	- å®¹é‡(capacity): åˆ‡ç‰‡å¼€å§‹åˆ°ç»“æŸä½ç½®(å¯å®¹çº³)å…ƒç´ çš„æ•°é‡

- Goè¯­è¨€ä¸­çš„sliceä¾èµ–äºæ•°ç»„ï¼Œå®ƒçš„åº•å±‚å°±æ˜¯æ•°ç»„ï¼Œæ‰€ä»¥æ•°ç»„å…·æœ‰çš„ä¼˜ç‚¹ï¼Œsliceéƒ½æœ‰
```go
	// runtime/slice.go
	type slice struct {
		array unsafe.Pointer // æ•°ç»„æŒ‡é’ˆ
		len   int // é•¿åº¦ 
		cap   int // å®¹é‡
	}
```

- Goè¯­è¨€ä¸­çš„sliceæ”¯æŒé€šè¿‡appendå‘sliceä¸­è¿½åŠ å…ƒç´ ï¼Œé•¿åº¦ä¸å¤Ÿæ—¶ä¼šåŠ¨æ€æ‰©å±•ï¼Œé€šè¿‡å†æ¬¡sliceåˆ‡ç‰‡ï¼Œå¯ä»¥å¾—åˆ°å¾—åˆ°æ›´å°çš„sliceç»“æ„ï¼Œå¯ä»¥è¿­ä»£ã€éå†ç­‰
	- åˆ‡ç‰‡å…±äº«åº•å±‚æ•°ç»„ï¼Œè‹¥æŸä¸ªåˆ‡ç‰‡å…ƒç´ å‘ç”Ÿå˜åŒ–ï¼Œåˆ™æ•°ç»„å’Œå…¶ä»–æœ‰å…±äº«å…ƒç´ çš„åˆ‡ç‰‡ä¹Ÿä¼šå‘ç”Ÿå˜åŒ–
	- åˆ‡ç‰‡åº•å±‚æ˜¯ä¸€ä¸ªé•¿åº¦å’Œæ•°æ®ç±»å‹å›ºå®šçš„æ•°ç»„ï¼Œåªæœ‰åœ¨åˆ‡ç‰‡çš„é•¿åº¦å¤§äºåº•å±‚æ•°ç»„çš„é•¿åº¦åï¼Œè¯¥åˆ‡ç‰‡çš„åº•å±‚æ‰ä¼šåœ¨å†…å­˜ä¸­æ›´æ¢æ–°çš„æ•°ç»„

- å£°æ˜ && åˆå§‹åŒ–
	- ä½¿ç”¨å­—é¢é‡åˆå§‹åŒ–ç©ºåˆ‡ç‰‡ `[]type{} // åˆå§‹åŒ–ä¸ºé›¶å€¼ nil`
	- ä½¿ç”¨å­—é¢é‡åˆå§‹åŒ– `var name []type = []type{v1, v2, â€¦,vn}`
	- æŒ‡å®šé•¿åº¦å’Œå®¹é‡å­—é¢é‡åˆå§‹åŒ– `[]type{im:vm, in:vn, ilength:vlength]`
	- ä½¿ç”¨makeå‡½æ•°åˆå§‹åŒ– `make([]type, len)/make([]type, len, cap)    é€šè¿‡ make å‡½æ•°åˆ›å»ºé•¿åº¦ä¸º lenï¼Œå®¹é‡ä¸º cap çš„åˆ‡ç‰‡ï¼Œä¸” len å¿…é¡»å°äºç­‰äº cap`
	- ä½¿ç”¨æ•°ç»„åˆ‡ç‰‡æ“ä½œåˆå§‹åŒ– 
```go
		array[start:end]            // end <= src_cap ; æ–°åˆ›å»ºåˆ‡ç‰‡é•¿åº¦å’Œå®¹é‡è®¡ç®—: new_len: end-start, new_cap: src_cap-start ;
		array[start:end:end_cap]    // ç”¨äºé™åˆ¶æ–°åˆ‡ç‰‡çš„å®¹é‡å€¼(end<=cap<=src_cap)ï¼›æ–°åˆ›å»ºåˆ‡ç‰‡é•¿åº¦å’Œå®¹é‡è®¡ç®— new_len: end-start, new_cap: end_cap-start
```

- éå†åˆ‡ç‰‡ (åŒæ•°ç»„)

- å¢åŠ å…ƒç´  
	- ä½¿ç”¨appendå‡½æ•°å¯¹åˆ‡ç‰‡å¢åŠ ä¸€ä¸ªæˆ–å¤šä¸ªå…ƒç´ å¹¶è¿”å›ä¿®æ”¹ååˆ‡ç‰‡ï¼Œå½“é•¿åº¦åœ¨å®¹é‡èŒƒå›´å†…æ—¶åªå¢åŠ é•¿åº¦ï¼Œå®¹é‡å’Œåº•å±‚æ•°ç»„ä¸å˜ã€‚
	- å½“é•¿åº¦è¶…è¿‡å®¹é‡èŒƒå›´åˆ™ä¼šåˆ›å»ºä¸€ä¸ªæ–°çš„åº•å±‚æ•°ç»„å¹¶å¯¹å®¹é‡è¿›è¡Œæ™ºèƒ½è¿ç®—(å…ƒç´ æ•°é‡<1024æ—¶ï¼Œçº¦æŒ‰åŸå®¹é‡1å€å¢åŠ ï¼Œ>1024æ—¶çº¦æŒ‰åŸå®¹é‡0.25å€å¢åŠ )
```go
		append(slice, 1, 2, ...,n)  
		// ç§»é™¤å…ƒç´  
		append(slince[:n-1], slince[n+1]...)
```

- å¤åˆ¶åˆ‡ç‰‡
```go
	copy(drc_slice, src_slice)  
	// 
	ç§»é™¤å…ƒç´  copy(slice[3:], slice[4:])
```

- åˆ‡ç‰‡çš„æ¯”è¾ƒ
	- æ•°ç»„å¯ä»¥æ¯”è¾ƒï¼Œä½†åˆ‡ç‰‡ä¸èƒ½è¿›è¡Œæ¯”è¾ƒ
	- æ ‡å‡†åº“æä¾›äº†é«˜åº¦ä¼˜åŒ–çš„bytes.Equalå‡½æ•°æ¥åˆ¤æ–­ä¸¤ä¸ªå­—èŠ‚å‹sliceæ˜¯å¦ç›¸ç­‰`[]byte`ï¼Œ
	- å¯¹äºå…¶ä»–ç±»å‹çš„sliceï¼Œå¿…é¡»å±•å¼€æ¯ä¸ªå…ƒç´ è¿›è¡Œæ¯”è¾ƒ
```go
		func equal(x, y []string) bool {
			if len(x) != len(y) {
				return false
			}
			for i := range x {
				if x[i] != y[i] {
					return false
				}
			}
			return true
		}
```
	- sliceå”¯ä¸€åˆæ³•çš„æ¯”è¾ƒæ“ä½œæ˜¯å’Œnilæ¯”è¾ƒ
```go
		if summer == nil { /* ... */ }
```

- nil silce
	- ä¸€ä¸ªé›¶å€¼çš„sliceç­‰äºnil
	- ä¸€ä¸ªnilå€¼çš„sliceå¹¶æ²¡æœ‰åº•å±‚æ•°ç»„
	- ä¸€ä¸ªnilå€¼çš„sliceçš„é•¿åº¦å’Œå®¹é‡éƒ½æ˜¯0ï¼Œä½†æ˜¯ä¹Ÿæœ‰énilå€¼çš„sliceçš„é•¿åº¦å’Œå®¹é‡ä¹Ÿæ˜¯0çš„ï¼Œä¾‹å¦‚[]int{}æˆ–make([]int, 3)[3:]
	- ä¸ä»»æ„ç±»å‹çš„nilå€¼ä¸€æ ·ï¼Œå¯ä»¥ç”¨[]int(nil)ç±»å‹è½¬æ¢è¡¨è¾¾å¼æ¥ç”Ÿæˆä¸€ä¸ªå¯¹åº”ç±»å‹sliceçš„nilå€¼
```go
		var s []int    // len(s) == 0, s == nil
		s = nil        // len(s) == 0, s == nil
		s = []int(nil) // len(s) == 0, s == nil
		s = []int{}    // len(s) == 0, s != nil
```

- åº”ç”¨
	- ç”¨åˆ‡ç‰‡å®ç°é˜Ÿåˆ—
```go
		queue := []int{}
		queue = append(queue, 1)
		queue = append(queue, 2)
		queue = queue[1:]
```
	- ç”¨åˆ‡ç‰‡å®ç°å †æ ˆ
```go
		stack := []int{}
		stack = append(stack, 1)	
		stack = append(stack, 2)
		stack = stack[:len(stack)-1]
```

- å¤šç»´åˆ‡ç‰‡
	- å£°æ˜&&åˆå§‹åŒ–
```go
		var name [][]type = [][]type{{v1,v2, â€¦,vvlength}, {v1,v2, â€¦,vvlength}, â€¦,{vlength,vvlength}}
		name := [][]type{0:{0:v1,3:v2},5:{2:v1,5:v2, â€¦,m:v3}, â€¦,n:{6:v1,m:vvlength}}
```
	- append
```go
		slice = append(slice, []int{1, 2, 3})
		slice[0] = append(point[0], 1)
```
	- copy
```go
		slice2 := [][]int{{}, {}}
		copy(slice2, slice)
```

- å…¶ä»–
	- å­—èŠ‚åˆ‡ç‰‡ bytesåŒ…
```go
	[]byte{string}
	string([]byte{})
```
	- runeåˆ‡ç‰‡
```go
	[]rune{string}
	string([]rune{})
```

### 3. æ˜ å°„ map
- å“ˆå¸Œè¡¨æ˜¯ä¸€ç§å·§å¦™å¹¶ä¸”å®ç”¨çš„æ•°æ®ç»“æ„ï¼Œå®ƒæ˜¯ä¸€ä¸ªæ— åºçš„key/valueå¯¹çš„é›†åˆï¼Œå…¶ä¸­æ‰€æœ‰çš„keyéƒ½æ˜¯ä¸åŒçš„ï¼Œç„¶åé€šè¿‡ç»™å®šçš„keyå¯ä»¥åœ¨å¸¸æ•°æ—¶é—´å¤æ‚åº¦O(1)å†…æ£€ç´¢ã€æ›´æ–°æˆ–åˆ é™¤å¯¹åº”çš„value

- åœ¨Goè¯­è¨€ä¸­ï¼Œä¸€ä¸ª map å°±æ˜¯ä¸€ä¸ªå“ˆå¸Œè¡¨çš„å¼•ç”¨ï¼Œmapç±»å‹å¯ä»¥å†™ä¸º `map[K]V` ï¼Œå…¶ä¸­ K å’Œ V åˆ†åˆ«å¯¹åº”keyå’Œvalue
	- key ç»è¿‡å“ˆå¸Œåï¼Œå¯¹å“ˆå¸Œç»“æœä½¿ç”¨mapæ§½ä½æ€»æ•°å–æ¨¡ï¼Œå¾—åˆ°çš„ç»“æœï¼Œå°±æ’å…¥å¯¹åº”æ§½ä½
		- æ¯”å¦‚ key1 å“ˆå¸Œåå¾—åˆ° 5437ï¼Œä½¿ç”¨æ§½ä½æ€»æ•°å–æ¨¡ï¼Œå¾—åˆ° 5 ï¼Œå³æ’å…¥ç¬¬ 5 ä¸ªæ§½ä½
		- è‹¥æ’å…¥æ—¶å†²çªå¤ªå¤šï¼Œåˆ™éœ€è¦å¢åŠ æ§½ä½æ•°ï¼Œç»™æ¯ä¸ª key é‡æ–°åˆ†é…æ§½ä½
	- mapä¸­æ‰€æœ‰çš„keyéƒ½æœ‰ç›¸åŒçš„ç±»å‹ï¼Œæ‰€æœ‰çš„valueä¹Ÿæœ‰ç€ç›¸åŒçš„ç±»å‹ï¼Œä½†æ˜¯keyå’Œvalueä¹‹é—´å¯ä»¥æ˜¯ä¸åŒçš„æ•°æ®ç±»å‹
	- å¼€é”€: ç¨€ç–å‹æ•°æ®ç»“æ„ï¼Œç‰ºç‰²ç©ºé—´æ¢å–æ—¶é—´
		- ç›¸å¯¹è€Œè¨€çš„æ•°ç»„ï¼Œå®Œæ•´å‹æ•°æ®ç»“æ„
	- mapåˆ é™¤æ•°æ®æ—¶å­˜åœ¨å»¶è¿Ÿï¼Œæ‰€ä»¥æœ€å¥½ä¸ä½œä¸ºå†…å­˜å­˜å‚¨

- Goè¯­è¨€ä¸­åªè¦æ˜¯å¯æ¯”è¾ƒçš„ç±»å‹éƒ½å¯ä»¥ä½œä¸º keyï¼Œé™¤å¼€ sliceï¼Œmapï¼Œfunctions è¿™å‡ ç§ç±»å‹ï¼Œå…¶ä»–ç±»å‹éƒ½æ˜¯ OK çš„ 
	- å…·ä½“åŒ…æ‹¬: å¸ƒå°”å€¼ã€æ•°å­—ã€å­—ç¬¦ä¸²ã€æŒ‡é’ˆã€é€šé“ã€æ¥å£ç±»å‹ã€ç»“æ„ä½“ã€åªåŒ…å«ä¸Šè¿°ç±»å‹çš„æ•°ç»„
	- è™½ç„¶ æµ®ç‚¹æ•°ç±»å‹ä¹Ÿæ˜¯æ”¯æŒç›¸ç­‰è¿ç®—ç¬¦æ¯”è¾ƒçš„ï¼Œä½†æ˜¯å°†æµ®ç‚¹æ•°ç”¨åškeyç±»å‹åˆ™æ˜¯ä¸€ä¸ªåçš„æƒ³æ³•ï¼Œæœ€åçš„æƒ…å†µæ˜¯å¯èƒ½å‡ºç°çš„NaNå’Œä»»ä½•æµ®ç‚¹æ•°éƒ½ä¸ç›¸ç­‰
	- å¯¹äºVå¯¹åº”çš„valueæ•°æ®ç±»å‹åˆ™æ²¡æœ‰ä»»ä½•çš„é™åˆ¶ã€‚
	- è¿™äº›ç±»å‹çš„å…±åŒç‰¹å¾æ˜¯æ”¯æŒ == å’Œ != æ“ä½œç¬¦ï¼Œk1 == k2 æ—¶ï¼Œå¯è®¤ä¸º k1 å’Œ k2 æ˜¯åŒä¸€ä¸ª key 
	- å¦‚æœæ˜¯ç»“æ„ä½“ï¼Œåˆ™éœ€è¦å®ƒä»¬çš„å­—æ®µå€¼éƒ½ç›¸ç­‰ï¼Œæ‰è¢«è®¤ä¸ºæ˜¯ç›¸åŒçš„ key
	- keyå’Œmapæœ¬èº«éƒ½å¯ä»¥è¢«å“ˆå¸Œ(ç±»ä¼¼æ¼æ–—ï¼Œå¯ä»¥æŠŠå¾ˆå¤§ä¸€éƒ¨åˆ†æ•°æ®ï¼Œç­›é€‰æˆä¸€å°éƒ¨åˆ†ç‰¹å¾ï¼Œåˆå«æ•£åˆ—)

- å£°æ˜&&åˆå§‹åŒ–
	- mapå£°æ˜éœ€è¦æŒ‡å®šç»„æˆ å…ƒç´ key å’Œ value çš„ç±»å‹
		- mapç±»å‹çš„é›¶å€¼æ˜¯nilï¼Œä¹Ÿå°±æ˜¯æ²¡æœ‰å¼•ç”¨ä»»ä½•å“ˆå¸Œè¡¨
		- åœ¨å£°æ˜åï¼Œè‹¥ä¸æ³¨æ„ä¼šè¢«åˆå§‹åŒ–ä¸º nilï¼Œè¡¨ç¤ºæš‚ä¸å­˜åœ¨çš„æ˜ å°„ 
		- nil mapï¼Œå®ƒå°†ä¸ä¼šåšä»»ä½•åˆå§‹åŒ–ï¼Œä¸ä¼šæŒ‡å‘ä»»ä½•æ•°æ®ç»“æ„ï¼Œæ·»åŠ å…ƒç´ ä¼šæŠ¥é”™
			- è€Œç›´æ¥èµ‹å€¼ä¼šæŠ¥ç©ºæŒ‡é’ˆï¼Œmapç±»å‹å®é™…ä¸Šå°±æ˜¯ä¸€ä¸ªæŒ‡é’ˆï¼Œå…·ä½“ä¸º `*hmap`
		- å¦‚åœ¨ç»“æ„ä½“ä¸­æ–°å¢mapå­—æ®µï¼Œåœ¨åé¢çš„å¼•ç”¨ä»£ç ä¸­éœ€è¦æ·»åŠ makeåˆå§‹åŒ–map
	- åˆå§‹åŒ–
		- ä½¿ç”¨å­—é¢é‡åˆå§‹åŒ– `map[ktype]vtype{k1:v1, k2:v2, â€¦, kn:vn} // key -> stringã€intã€boolã€array`
		- ä½¿ç”¨å­—é¢é‡åˆå§‹åŒ–ç©ºæ˜ å°„ `map[ktype]vtype{} // è‹¥ä¸åŠ {}ï¼Œåˆ™åˆå§‹åŒ–ä¸ºnilï¼Œå³æ— æ³•æ·»åŠ key`
		- ä½¿ç”¨makeå‡½æ•°åˆå§‹åŒ– `make(map[ktype]vtype)`ï¼Œé€šè¿‡makeå‡½æ•°åˆ›å»ºæ˜ å°„ï¼Œå®ƒä¼šå…ˆåˆ›å»ºå¥½åº•å±‚æ•°æ®ç»“æ„ï¼Œç„¶åå†åˆ›å»ºmapï¼Œå¹¶è®©mapæŒ‡å‘åº•å±‚æ•°æ®ç»“æ„
	- åˆ¤æ–­æ˜¯å¦å­˜åœ¨
		- é€šè¿‡keyè®¿é—®å…ƒç´ æ—¶å¯æ¥æ”¶ä¸¤ä¸ªå€¼ï¼Œç¬¬ä¸€ä¸ªå€¼ä¸ºvalueï¼Œç¬¬äºŒä¸ªå€¼ä¸ºboolç±»å‹è¡¨ç¤ºå…ƒç´ æ˜¯å¦å­˜åœ¨ï¼Œè‹¥å­˜åœ¨ä¸ºtrueï¼Œå¦åˆ™ä¸ºfalse
```go
			map_01, ok := map[1]
			fmt.Printf("%t, %v\n", ok, map_01)
```
	- ä¿®æ”¹&å¢åŠ 
		- ä½¿ç”¨keyå¯¹æ˜ å°„èµ‹å€¼æ—¶å½“keyå­˜åœ¨åˆ™ä¿®æ”¹keyå¯¹åº”çš„valueï¼Œè‹¥keyä¸å­˜åœ¨åˆ™å¢åŠ keyå’Œvalue
	- åˆ é™¤
		- ä½¿ç”¨deleteå‡½æ•°åˆ é™¤æ˜ å°„ä¸­å·²ç»å­˜åœ¨çš„key
```go
			delete(map, 3)
			delete(map[2], "XX")
```
	- æ¯”è¾ƒ
```go
		func equal(x, y map[string]int) bool {
			if len(x) != len(y) {
				return false
			}
			for k, xv := range x {
				if yv, ok := y[k]; !ok || yv != xv {
					return false
				}
			}
			return true
		}
```
	- mapä¸­çš„å…ƒç´ å¹¶ä¸æ˜¯ä¸€ä¸ªå˜é‡ï¼Œç¦æ­¢å¯¹mapå…ƒç´ å–å€ï¼ŒåŸå› æ˜¯mapå¯èƒ½éšç€å…ƒç´ æ•°é‡çš„å¢é•¿è€Œé‡æ–°åˆ†é…æ›´å¤§çš„å†…å­˜ç©ºé—´ï¼Œä»è€Œå¯èƒ½å¯¼è‡´ä¹‹å‰çš„åœ°å€æ— æ•ˆ
```go
		_ = &ages["bob"] // compile error: cannot take address of map element
```
	
- å¤šç»´æ˜ å°„
```go
	map := map[int]map[string]string{1: map[string]string{"name": "aa", "tel": "123"}, 2: map[string]string{"name": "bb", "tel": "456"}}
```

- æ˜ å°„çš„éå†
	- åŸºæœ¬è¯­å¥
```go
		for k, v := range map {
			fmt.Printf("%v:%v\n", k, v)
		}
```
	- é¡ºåºéå†
		- Mapçš„è¿­ä»£é¡ºåºæ˜¯ä¸ç¡®å®šçš„ï¼Œå¹¶ä¸”ä¸åŒçš„å“ˆå¸Œå‡½æ•°å®ç°å¯èƒ½å¯¼è‡´ä¸åŒçš„éå†é¡ºåº
		- æ¯æ¬¡éƒ½ä½¿ç”¨éšæœºçš„éå†é¡ºåºå¯ä»¥å¼ºåˆ¶è¦æ±‚ç¨‹åºä¸ä¼šä¾èµ–å…·ä½“çš„å“ˆå¸Œå‡½æ•°å®ç°
		- å¦‚æœè¦æŒ‰é¡ºåºéå†key/valueå¯¹ï¼Œå¿…é¡»æ˜¾å¼åœ°å¯¹keyè¿›è¡Œæ’åºï¼Œå¯ä»¥ä½¿ç”¨sortåŒ…çš„Stringså‡½æ•°å¯¹å­—ç¬¦ä¸²sliceè¿›è¡Œæ’åº
```go
			import "sort"
			
			names := make([]string, 0, len(ages))
			for name := range ages {
				names = append(names, name)
			}
			sort.Strings(names)
			for _, name := range names {
				fmt.Printf("%s\t%d\n", name, ages[name])
			}
```


- å‡½æ•°ä¸­çš„åº”ç”¨
	- mapä½œä¸ºå‡½æ•°å‚æ•°
		- mapæ˜¯ä¸€ç§æŒ‡é’ˆï¼Œæ‰€ä»¥å°†mapä¼ é€’ç»™å‡½æ•°ï¼Œä»…ä»…åªæ˜¯å¤åˆ¶è¿™ä¸ªæŒ‡é’ˆï¼Œæ‰€ä»¥å‡½æ•°å†…éƒ¨å¯¹mapçš„æ“ä½œä¼šç›´æ¥ä¿®æ”¹å¤–éƒ¨çš„map
```go
			a := map[int]string{1: "a", 2: "b", 3: "c"}
			func(map[int]string) {
				delete(a, 1)
			}(a)
```
	- mapå€¼ä¸ºå‡½æ•°
```go
		op := map[string]func(x, y int) int{
			"+": func(x, y int) int {
				return x + y
			},
			"-": func(x, y int) int {
				return x - y
			},
			"*": func(x, y int) int {
				return x * y
			},
			"/": func(x, y int) int {
				return x / y
			},
		}
		fmt.Println(op["+"](1, 2))
		fmt.Println(op["-"](1, 2))
```
	- slice ä½œä¸º map çš„key
		- æœ‰æ—¶å€™éœ€è¦ä¸€ä¸ª map æˆ– set çš„ key æ˜¯ sliceç±»å‹ï¼Œä½†æ˜¯ map çš„ key å¿…é¡»æ˜¯å¯æ¯”è¾ƒçš„ç±»å‹ï¼Œsliceå¹¶ä¸æ»¡è¶³è¿™ä¸ªæ¡ä»¶
		- å¯ä»¥é€šè¿‡ä¸¤ä¸ªæ­¥éª¤ç»•è¿‡è¿™ä¸ªé™åˆ¶
			- å®šä¹‰ä¸€ä¸ªè¾…åŠ©å‡½æ•°kï¼Œå°†sliceè½¬ä¸ºmapå¯¹åº”çš„stringç±»å‹çš„keyï¼Œç¡®ä¿åªæœ‰xå’Œyç›¸ç­‰æ—¶k(x) == k(y)æ‰æˆç«‹
			- åˆ›å»ºä¸€ä¸ªkeyä¸ºstringç±»å‹çš„mapï¼Œåœ¨æ¯æ¬¡å¯¹mapæ“ä½œæ—¶å…ˆç”¨kè¾…åŠ©å‡½æ•°å°†sliceè½¬åŒ–ä¸ºstringç±»å‹
```go
				var m = make(map[string]int)
				func k(list []string) string { return fmt.Sprintf("%q", list) }
				func Add(list []string)       { m[k(list)]++ }
				func Count(list []string) int { return m[k(list)] }
```

- å­˜åœ¨é—®é¢˜ Goè¯­è¨€ä¸­åŸç”Ÿçš„mapçº¿ç¨‹ä¸å®‰å…¨
	- è§£å†³æ–¹æ¡ˆä¸€: åŠ é”
```go
		type concurrentMap struct {
			sync.RWMutex
			mp map[int]int
		}
		func (c *concurrentMap) Set(key int, value int) {
			// è·å–å†™é”
			c.Lock()
			c.mp[key] = value
			c.Unlock()
		}
		func (c *concurrentMap) Get(key int) int {
			// è·å–è¯»é”
			c.RLock()
			res := c.mp[key]
			c.RUnlock()
			return res
		}
		c := concurrentMap{
			mp: (map[int]int{}),
		}
		// å†™mapçš„goroutine
		go func() {
			for i := 0; i < 10000; i++ {
				c.Set(i, i)
			}
		}()
		// è¯»mapçš„goroutine
		go func() {
			for i := 0; i < 10000; i++ {
				res := c.Get(i)
				fmt.Printf("[cmap.get][%d=%d]\n", i, res)
			}
		}()
		time.Sleep(20 * time.Second)
```
	- è§£å†³æ–¹æ¡ˆäºŒ: ä½¿ç”¨ `sync.map`
		- go 1.9å¼•å…¥çš„å†…ç½®æ–¹æ³•ï¼Œå¹¶å‘çº¿ç¨‹å®‰å…¨çš„map
		- sync.Map å°† keyå’Œ value æŒ‰ç…§ interface{}å­˜å‚¨
		- æŸ¥è¯¢å‡ºæ¥åè¦ç±»å‹æ–­è¨€ x.(int) x.(string)
		- éå†ä½¿ç”¨Range() æ–¹æ³•ï¼Œéœ€è¦ä¼ å…¥ä¸€ä¸ªåŒ¿åå‡½æ•°ä½œä¸ºå‚æ•°ï¼ŒåŒ¿åå‡½æ•°çš„å‚æ•°ä¸ºk,v interface{}ï¼Œæ¯æ¬¡è°ƒç”¨åŒ¿åå‡½æ•°å°†ç»“æœè¿”å›
		- sync.map æ€§èƒ½å¯¹æ¯”
			- https://studygolang.com/articles/27515
			- æ€§èƒ½å¯¹æ¯”ç»“è®º
				- åªè¯»åœºæ™¯: sync.map > rwmutex >> mutex
				- è¯»å†™åœºæ™¯(è¾¹è¯»è¾¹å†™): rwmutex > mutex >> sync.map
				- è¯»å†™åœºæ™¯(è¯»80% å†™20%): sync.map > rwmutex > mutex
				- è¯»å†™åœºæ™¯(è¯»98% å†™2%): sync.map > rwmutex >> mutex
				- åªå†™åœºæ™¯: sync.map >> mutex > rwmutex
			- sync.Mapä½¿ç”¨åœºæ™¯çš„å»ºè®®
				- è¯»å¤š: ç»™å®šçš„key-våªå†™ä¸€æ¬¡ï¼Œä½†æ˜¯è¯»äº†å¾ˆå¤šæ¬¡ï¼Œåªå¢é•¿çš„ç¼“å­˜åœºæ™¯
				- keyä¸ç›¸äº¤: è¦†ç›–æ›´æ–°çš„åœºæ™¯æ¯”å°‘
				- ç»“æ„ä½“å¤æ‚çš„caseå¤šä¸ç”¨sync.Map
	- è§£å†³æ–¹æ¡ˆä¸‰: åˆ†ç‰‡é” å¹¶å‘map github.com/orcaman/concurrent-map

- ç¤ºä¾‹ 
	- ä½¿ç”¨mapç»Ÿè®¡ "I have a dream" ä¸­ï¼Œå„å­—æ¯å‡ºç°æ¬¡æ•°
```go
		article := `
			I have a dream
			...
			`
		stats := map[rune]int{}
	
		for _, ch := range article {
			if ch >= 'a' && ch <= 'z' || ch >= 'A' && ch <= 'Z' {
				stats[ch]++
			}
		}
		for ch, cnt := range stats {
			fmt.Printf("%c, %v\n", ch, cnt)
		}
```
	- Setçš„å®ç°
```go
		type Set struct {
			sync.RWMutex
			Mset map[interface{}]interface{}
		}

		func NewSet(item ...interface{}) *Set {
			s := &Set{}
			s.Mset = make(map[interface{}]interface{})
			s.Add(item...)

			return s
		}

		// Add æ·»åŠ å…ƒç´ 
		func (s *Set) Add(items ...interface{}) error {
			s.Lock()
			defer s.Unlock()

			for _, item := range items {
				s.Mset[item] = item
			}

			return nil
		}

		// Delete åˆ é™¤å…ƒç´ 
		func (s *Set) Delete(items ...interface{}) error {
			s.Lock()
			defer s.Unlock()

			for _, item := range items {
				delete(s.Mset, item)
			}

			return nil
		}

		// Modify ä¿®æ”¹å…ƒç´ 
		func (s *Set) Modify(items ...interface{}) error {
			s.Lock()
			defer s.Unlock()

			for _, item := range items {
				_, ok := s.Mset[item]
				if !ok {
					continue
				}

				switch value := item.(type) {
				case string:
					s.Mset[item] = value + "modify"
				case int:
					s.Mset[item] = value + 10
				case bool:
					s.Mset[item] = true
				case float64:
					s.Mset[item] = value + 3.1415926535
				}
			}

			return nil
		}

		// Contains åŒ…å«&&æŸ¥è¯¢
		func (s *Set) Contains(item interface{}) bool {
			s.RLock()
			defer s.RUnlock()

			_, ok := s.Mset[item]

			return ok
		}

		// Size å®¹é‡
		func (s *Set) Size() int {
			s.RLock()
			defer s.RUnlock()

			return len(s.Mset)
		}

		// Clear æ¸…é™¤
		func (s *Set) Clear() {
			s.Lock()
			defer s.Unlock()

			s.Mset = make(map[interface{}]interface{})
		}

		// Equel æ¯”è¾ƒ
		func (s *Set) Equel(other *Set) bool {
			// å¦‚æœä¸¤è€…Sizeä¸ç›¸ç­‰ï¼Œè¿”å›false
			if s.Size() != other.Size() {
				return false
			}

			// è¿­ä»£æŸ¥è¯¢éå†
			for key := range s.Mset {
				// è‹¥ä¸å­˜åœ¨è¿”å›false
				if !other.Contains(key) {
					return false
				}
			}

			return true
		}

		// IsSubset å­é›†
		func (s *Set) IsSubset(other *Set) bool {
			// sçš„sizeé•¿äºotherï¼Œè¿”å›false
			if s.Size() > other.Size() {
				return false
			}

			// è¿­ä»£éå†
			for key := range s.Mset {
				if !other.Contains(key) {
					return false
				}
			}

			return true
		}
```
	- k8s-deploymentçš„å®ç°
```go
		/*
		- interface
		- map
		- å‘å¸ƒç³»ç»Ÿï¼Œèƒ½å‘å¸ƒk8s node(jtypeå­—æ®µ) ä¸åŒçš„ç±»å‹çš„ä»»åŠ¡
		- å¢é‡æ›´æ–°ï¼šå¼€å¯æ–°çš„ï¼Œåœæ‰æ—§çš„
		- åŸæœ‰çš„æ˜¯a,b,c ï¼Œb,c,d --> å¼€å¯d, åœæ‰a
		*/

		type jobManager struct {
			jobMutex sync.RWMutex
			// å¢é‡æ›´æ–°
			activeJobs map[string]deployJob
		}

		func NewJobManager() *jobManager {
			return &jobManager{
				jobMutex:   sync.RWMutex{},
				activeJobs: map[string]deployJob{},
			}
		}

		func (jm *jobManager) sync(jobs []deployJob) {
			// ***å¢é‡æ›´æ–°
			jb := make(map[string]deployJob)

			for _, v := range jobs {
				jb[v.GetName()] = v
			}

			jm.jobMutex.Lock()
			defer jm.jobMutex.Unlock()
			for k, jmv := range jm.activeJobs {
				if jbv, ok := jb[k]; ok && jmv.GetKind() == jbv.GetKind() {
					delete(jb, k)
				} else {
					go jm.activeJobs[k].stop()
				}
			}
			for k, v := range jb {
				jm.activeJobs[k] = v
				go jm.activeJobs[k].start()
			}
		}

		type deployJob interface {
			start()
			stop()
			SetFlag(b bool)
			GetName() string
			GetFlag() bool
			GetKind() string
		}

		type k8sD struct {
			Name string
			Flag bool
			Kind string
		}

		func NewK8sD(name string) *k8sD {
			return &k8sD{
				Name: name,
				Kind: "K8sD",
			}
		}

		func (k *k8sD) start() {
			k.SetFlag(true)
			log.Printf("Pod %s å¼€å§‹è¿è¡Œ \n", k.Name)
			count := 0
			for {
				if k.Flag {
					count++
					log.Printf("Pod %s æ­£åœ¨è¿è¡Œ %d ç§’\n", k.Name, count)
					time.Sleep(1 * time.Second)
				} else {
					log.Printf("Pod %s é€€å‡ºè¿è¡Œ \n", k.Name)
					break
				}
			}
		}

		func (k *k8sD) stop() {
			k.SetFlag(false)
			log.Printf("Pod %s é€€å‡ºè¿è¡Œ \n", k.Name)
		}

		func (k *k8sD) SetFlag(b bool) {
			k.Flag = b
		}

		func (k *k8sD) GetName() string {
			return k.Name
		}

		func (k *k8sD) GetFlag() bool {
			return k.Flag
		}

		func (k *k8sD) GetKind() string {
			return k.Kind
		}

		type host struct {
			Name string
			Flag bool
			Kind string
			// Pod  []k8sD
		}

		func NewHost(name string) *host {
			return &host{
				Name: name,
				Kind: "Host",
			}
		}

		func (h *host) start() {
			h.SetFlag(true)
			log.Printf("Host %s å¼€å§‹è¿è¡Œ \n", h.Name)
			count := 0
			for {
				count++
				if h.Flag {
					log.Printf("Host %s æ­£åœ¨è¿è¡Œ %d ç§’\n", h.Name, count)
					time.Sleep(1 * time.Second)
				} else {
					log.Printf("Host %s é€€å‡ºè¿è¡Œ \n", h.Name)
					break
				}
			}
		}

		func (h *host) stop() {
			h.SetFlag(false)
			log.Printf("Host %s é€€å‡ºè¿è¡Œ \n", h.Name)
		}

		func (h *host) SetFlag(b bool) {
			h.Flag = b
		}

		func (h *host) GetName() string {
			return h.Name
		}

		func (h *host) GetFlag() bool {
			return h.Flag
		}

		func (h *host) GetKind() string {
			return h.Kind
		}
```
	- å¸¦è¿‡æœŸæ—¶é—´çš„map
		- mapåšç¼“å­˜ç”¨çš„ åƒåœ¾å †ç§¯k1ã€k2 
		- å¸Œæœ›ç¼“å­˜å­˜æ´»æ—¶é—´ 5åˆ†é’Ÿ
		- å°†åŠ é”çš„æ—¶é—´æ§åˆ¶åœ¨æœ€ä½
		- è€—æ—¶çš„æ“ä½œåœ¨åŠ é”å¤–ä¾§åš
```go
			type item struct {
				value interface{} // å€¼
				ts    int64       // æ—¶é—´æˆ³ï¼Œitemè¢«åˆ›å»ºå‡ºæ¥çš„æ—¶é—´ï¼Œæˆ–è€…è¢«æ›´æ–°çš„æ—¶é—´
			}

			func NewItem(i interface{}) *item {
				return &item{
					value: i,
					ts:    time.Now().Unix(),
				}
			}

			// å¸¦è¿‡æœŸç¼“å­˜çš„map
			type Cache struct {
				sync.RWMutex
				mp map[string]*item
			}

			func NewCache() *Cache {
				return &Cache{
					mp: make(map[string]*item),
				}
			}

			func (c *Cache) Get(key string) *item {
				c.RLock()
				defer c.RUnlock()

				return c.mp[key]
			}

			func (c *Cache) Set(key string, value *item) {
				c.Lock()
				defer c.Unlock()

				c.mp[key] = value
			}

			// GC å…ˆåŠ è¯»é” -> æ£€æŸ¥ç¡®å®æœ‰éœ€è¦å›æ”¶çš„æ•°æ® -> åˆå¹¶å†™é”å›æ”¶
			func (c *Cache) Gc(timeDelta int64) {
				for {
					toDelKeys := make([]string, 0)
					now := time.Now().Unix()
					c.RLock()

					// éå†ç¼“å­˜ä¸­çš„é¡¹ç›®ï¼Œå¯¹æ¯”æ—¶é—´æˆ³ï¼Œè¶…è¿‡ timeDelta å°±åˆ é™¤è¯¥é¡¹ç›®
					for k, v := range c.mp {
						if now-v.ts > timeDelta {
							log.Printf("[é¡¹ç›®å·²è¿‡æœŸ][key %s]", k)
							toDelKeys = append(toDelKeys, k)
						}
					}
					c.RUnlock()

					c.Lock()
					for _, k := range toDelKeys {
						delete(c.mp, k)
					}
					c.Unlock()

					time.Sleep(5 * time.Second)
				}
			}

			c := NewCache()
			// å¼‚æ­¥æ‰§è¡Œï¼Œåˆ é™¤è¿‡æœŸé¡¹ç›®çš„ä»»åŠ¡
			go c.Gc(10)

			// å†™å…¥æ•°æ®
			for i := 0; i <= 10; i++ {
				key := fmt.Sprintf("key_%d", i)
				item := NewItem(i)

				// è®¾ç½®ç¼“å­˜
				log.Printf("[è®¾ç½®é¡¹ç›®ç¼“å­˜[key:%s][v:%v]", key, item)
				c.Set(key, item)
			}

			time.Sleep(15 * time.Second)

			for i := 0; i < 5; i++ {
				key := fmt.Sprintf("key_%d", i)
				item := NewItem(i + 2)

				// æ›´æ–°ç¼“å­˜
				log.Printf("[æ›´æ–°é¡¹ç›®ç¼“å­˜][key:%s][v:%v]", key, item)
				c.Set(key, item)
			}

			time.Sleep(10 * time.Second)
```
	- å¸¦è¿‡æœŸæ—¶é—´çš„ç¼“å­˜ github.com/patrickmn/go-cache
```go
		var (
			defaultInterval = time.Second * 30
			UserCache       = cache.New(defaultInterval, defaultInterval)
		)

		type user struct {
			Name  string
			Email string		
			Phone int64
		}

		// HttpGetUser åˆå§‹åŒ–userå¯¹è±¡
		func HttpGetUser(name string) user {
			u := user{
				Name:  name,
				Email: "qq.com",
				Phone: time.Now().Unix(),
			}

			return u
		}

		func GetUser(name string) user {
			res, found := UserCache.Get(name)
			if found {
				u := res.(user)
				log.Printf("[found_user_in_cache][name:%s][value:%v]", name, u)

				return u
			} else {
				res := HttpGetUser(name)
				// ç»™æ¯ä¸ªkey å•ç‹¬è®¾ç½®è¶…æ—¶æ—¶é—´
				UserCache.Set(name, res, defaultInterval)
				log.Printf("[not_found_user_in_cache][query_by_http][name:%s][value:%v]", name, res)

				return res
			}
		}
```


### 4. ç»“æ„ä½“ struct
- å®šä¹‰
	- ç»“æ„ä½“æ˜¯ç”±ä¸€äº›åˆ—å±æ€§ç»„æˆçš„å¤åˆæ•°æ®ç±»å‹ï¼Œæ¯ä¸ªå±æ€§éƒ½å…·æœ‰åç§°ã€ç±»å‹å’Œå€¼ï¼Œç»“æ„ä½“å°†å±æ€§ç»„åˆåœ¨ä¸€èµ·ç”±ç¨‹åºè¿›è¡Œå¤„ç†
	- ç»“æ„ä½“å®šä¹‰ä½¿ç”¨ struct æ ‡è¯†ï¼Œéœ€è¦æŒ‡å®šå…¶åŒ…å«çš„å±æ€§(åå’Œç±»å‹)ï¼Œåœ¨å®šä¹‰ç»“æ„ä½“æ—¶å¯ä»¥ä¸º ç»“æ„ä½“æŒ‡å®šç»“æ„ä½“å(å‘½åç»“æ„ä½“)ï¼Œç”¨äºåç»­å£°æ˜ç»“æ„ä½“å˜é‡ä½¿ç”¨
```go
		type struct_variable_type struct {
			member definition
			...
		}
```

- å£°æ˜
	- å£°æ˜ç»“æ„ä½“å˜é‡åªéœ€è¦å®šä¹‰å˜é‡ç±»å‹ä¸ºç»“æ„ä½“åï¼Œå˜é‡ä¸­çš„æ¯ä¸ªå±æ€§è¢«åˆå§‹åŒ–ä¸ºå¯¹åº”ç±»å‹çš„é›¶å€¼ `var struct_name struct_variable_type`
	- å¯ä»¥å£°æ˜ç»“æ„ä½“æŒ‡é’ˆå˜é‡ï¼Œæ­¤æ—¶å˜é‡è¢«åˆå§‹åŒ–ä¸º nil `var struct_name *struct_variable_type`
	
- åˆå§‹åŒ–
	- ä½¿ç”¨ç»“æ„ä½“åˆ›å»ºçš„å˜é‡å«åšå¯¹åº”ç»“æ„ä½“çš„å®ä¾‹æˆ–è€…å¯¹è±¡
	- ä½¿ç”¨ç»“æ„ä½“é›¶å€¼åˆå§‹åŒ–ç»“æ„ä½“å€¼å¯¹è±¡
```go
		var struct_name struct_variable_type = struct_variable_type{}
```
	- ä½¿ç”¨ç»“æ„ä½“å­—é¢é‡åˆå§‹åŒ–ç»“æ„ä½“å€¼å¯¹è±¡
```go
		var struct_name struct_variable_type = struct_variable_type{
			...
		}
		struct_name := struct_variable_type{a: 123, c: 789...}    //åˆå§‹åŒ–éƒ¨åˆ†
```
	- ä½¿ç”¨ new å‡½æ•°è¿›è¡Œåˆå§‹åŒ–ç»“æ„ä½“æŒ‡é’ˆå¯¹è±¡
```go
		var struct_name *struct_variable_type = new(struct_variable_type)
```
	- ä½¿ç”¨ç»“æ„ä½“å­—é¢é‡åˆå§‹åŒ–ç»“æ„ä½“æŒ‡é’ˆå¯¹è±¡
```go
		var struct_name *struct_variable_type = &struct_variable_type{
			...
		}
		struct_name := &struct_variable_type{a: 123, c: 789...}
```
	
- å±æ€§çš„è®¿é—®å’Œä¿®æ”¹ 
	- é€šè¿‡ç»“æ„ä½“å¯¹è±¡å/ç»“æ„ä½“æŒ‡é’ˆå¯¹è±¡.å±æ€§åçš„æ–¹å¼æ¥è®¿é—®å’Œä¿®æ”¹å¯¹è±¡çš„å±æ€§å€¼ `struct_name.a`
	
- åŒ¿åç»“æ„ä½“
	- åœ¨å®šä¹‰å˜é‡æ—¶å°†ç±»å‹æŒ‡å®šä¸ºç»“æ„ä½“çš„ç»“æ„ï¼Œæ­¤æ—¶å«åŒ¿åç»“æ„ä½“
	- åŒ¿åç»“æ„ä½“å¸¸ç”¨äºåˆå§‹åŒ–ä¸€æ¬¡ç»“æ„ä½“å˜é‡çš„åœºæ™¯ï¼Œä¾‹å¦‚é¡¹ç›®é…ç½®
```go
		a := struct{
			a1 int
			a2 string
			...
		}{1, "aa"}
```

- å‘½ååµŒå…¥
	- ç»“æ„ä½“å‘½ååµŒå…¥æ˜¯æŒ‡ç»“æ„ä½“ä¸­çš„å±æ€§å¯¹åº”çš„ç±»å‹ä¹Ÿæ˜¯ç»“æ„ä½“
```go
		type Address struct{
			region string
			street string
			num    string
		}
		type User struct{
			name string
			tel  string
			addr Address
		}
```
	- å£°æ˜&&åˆå§‹åŒ– 
```go
		var u1 User
		var a1 Address = Address{
			"æµ™æ±Ÿçœæ­å·å¸‚",
			"è½¬å¡˜è¡—é“",
			"001",
		}
		var u2 User = User{"atlantis", "18100000000", a1}
		u3 := User{
			name: "lywq",
			tel: "18600000000",
			addr: Address{
				"å®‰å¾½çœåˆè‚¥å¸‚",
				"æœ›æ±Ÿè¥¿è·¯",
				"001",
			},
		}
```
	- å±æ€§çš„è®¿é—®å’Œä¿®æ”¹
```
		u3.addr.num = "002"
```

- åŒ¿ååµŒå…¥
	- ç»“æ„ä½“åŒ¿ååµŒå…¥æ˜¯æŒ‡å°†å·²å®šä¹‰çš„ç»“æ„ä½“åç›´æ¥å£°æ˜åœ¨æ–°çš„ç»“æ„ä½“ä¸­ï¼Œä»è€Œå®ç°å¯¹ä»¥åå·²æœ‰ç±»å‹çš„æ‰©å±•å’Œä¿®æ”¹
```go
		type Employee struct {
			User
			salary float64
			title  string
		}	
```
	- å£°æ˜å’Œåˆå§‹åŒ–
		- åœ¨åˆå§‹åŒ–åŒ¿ååµŒå…¥çš„ç»“æ„ä½“å¯¹è±¡æ—¶éœ€è¦éµå¾ªæ ‘çŠ¶å£°æ˜çš„ç»“æ„ï¼Œå¯¹äºåŒ¿ååµŒå…¥çš„ç»“æ„ä½“å¯ä»¥ä½¿ç”¨ç»“æ„ä½“åæ¥æŒ‡å®šåˆå§‹åŒ–å‚æ•°
	- å±æ€§çš„è®¿é—®å’Œä¿®æ”¹	
		- åœ¨è®¿é—®å’Œä¿®æ”¹åµŒå…¥ç»“æ„ä½“çš„å±æ€§å€¼æ—¶ï¼Œå¯ä»¥é€šè¿‡å¯¹è±¡å.ç»“æ„ä½“åç§°.å±æ€§åçš„æ–¹å¼è¿›è¡Œè®¿é—®å’Œä¿®æ”¹ï¼Œç»“æ„ä½“åç§°å¯ä»¥çœç•¥ï¼ˆåŒ¿åæˆå‘˜æœ‰ä¸€ä¸ªéšå¼çš„åç§°ï¼‰ï¼Œå› æ­¤ä¸èƒ½åµŒå¥—ä¸¤ä¸ªç›¸åŒåç§°çš„ç»“æ„ä½“
		- å½“è¢«åµŒå…¥ç»“æ„ä½“å’ŒåµŒå…¥ç»“æ„ä½“æœ‰ç›¸åŒçš„å±æ€§åæ—¶ï¼Œåœ¨è®¿é—®å’Œä¿®æ”¹åµŒå…¥ç»“æ„ä½“æˆå‘˜çš„å±æ€§å€¼æ—¶ä¸èƒ½çœç•¥ç»“æ„ä½“åç§°
 
- æŒ‡é’ˆç±»å‹åµŒå…¥
	- ç»“æ„ä½“åµŒå…¥(å‘½å&åŒ¿å)ç±»å‹ä¹Ÿå¯ä»¥ä¸ºç»“æ„ä½“æŒ‡é’ˆ
```go
		type PUser *struct{              // å‘½ååµŒå…¥ç»“æ„ä½“æŒ‡é’ˆ
			name string
			tel  string
			addr *Address
		}
		type PEmployee struct {          // åŒ¿ååµŒå…¥ç»“æ„ä½“æŒ‡é’ˆ
			*PUser
			salary float64
			title  string
		}
```
	- å£°æ˜&&åˆå§‹åŒ–
```go
		puser := PUser{"atlantis", "18100000000", &a1}
		pemployee := PEmployee{
			PUser:  &puser,
			salary: 25000,
			title:  "aa",
		}
```

- å±æ€§çš„è®¿é—®å’Œä¿®æ”¹	
	- ä½¿ç”¨å±æ€§ä¸ºæŒ‡é’ˆç±»å‹åº•å±‚å…±äº«æ•°æ®ç»“æ„ï¼Œå½“åº•å±‚æ•°æ®å‘ç”Ÿå˜åŒ–ï¼Œæ‰€æœ‰å¼•ç”¨éƒ½ä¼šå‘ç”Ÿå½±å“
 
- ç©ºç»“æ„ä½“
	- `struct{}`
		- struct{} æ˜¯ä¸€ä¸ªæ— å…ƒç´ çš„ç»“æ„ä½“ç±»å‹ï¼Œé€šå¸¸åœ¨æ²¡æœ‰ä¿¡æ¯å­˜å‚¨æ—¶ä½¿ç”¨
		- ä¼˜ç‚¹æ˜¯å¤§å°ä¸º0ï¼Œä¸éœ€è¦å†…å­˜æ¥å­˜å‚¨ struct{}ç±»å‹çš„å€¼
	- `struct{}{}`
		- struct{}{} æ˜¯ä¸€ä¸ªå¤åˆå­—é¢é‡ï¼Œå®ƒæ„é€ äº†ä¸€ä¸ª struct{}ç±»å‹çš„å€¼ï¼Œè¯¥å€¼ä¹Ÿæ˜¯ç©º `var empty = struct{}{}`

- å¯è§æ€§
	- ç»“æ„ä½“åé¦–å­—æ¯å¤§å†™åˆ™åŒ…å¤–å¯è§(å…¬å¼€çš„)ï¼Œå°å†™åˆ™ä»…åŒ…å†…å¯è®¿é—®(å†…éƒ¨çš„)
	- ç»“æ„ä½“å±æ€§åé¦–å­—æ¯å¤§å†™åŒ…å¤–å¯è§(å…¬å¼€çš„)ï¼Œå°å†™åˆ™ä»…åŒ…å†…å¯è®¿é—®(å†…éƒ¨çš„)
		- ç»“æ„ä½“åé¦–å­—æ¯å¤§å†™ï¼Œå±æ€§åå¤§å†™: ç»“æ„ä½“å¯åœ¨åŒ…å¤–ä½¿ç”¨ï¼Œä¸”è®¿é—®å…¶å¤§å†™çš„å±æ€§å
		- ç»“æ„ä½“åé¦–å­—æ¯å¤§å†™ï¼Œå±æ€§åå°å†™: ç»“æ„ä½“å¯åœ¨åŒ…å¤–ä½¿ç”¨ï¼Œä¸”ä¸èƒ½è®¿é—®å…¶å°å†™çš„å±æ€§å
		- ç»“æ„ä½“åé¦–å­—æ¯å°å†™ï¼Œå±æ€§åå¤§å†™: ç»“æ„ä½“åªèƒ½åœ¨åŒ…å†…ä½¿ç”¨ï¼Œå±æ€§è®¿é—®åœ¨ç»“æ„ä½“åµŒå…¥æ—¶ç”±è¢«åµŒå…¥ç»“æ„ä½“(å¤–å±‚)å†³å®šï¼Œè¢«åµŒå…¥ç»“æ„ä½“åé¦–å­—æ¯å¤§å†™æ—¶å±æ€§ååŒ…å¤–å¯è§ï¼Œå¦è€…åªèƒ½åœ¨åŒ…å†…ä½¿ç”¨
		- ç»“æ„ä½“åé¦–å­—æ¯å°å†™ï¼Œå±æ€§åå°å†™: ç»“æ„ä½“åªèƒ½åœ¨åŒ…å†…ä½¿ç”¨(å¯ä»¥ä½¿ç”¨å‡½æ•°è¿”å›é¦–å­—æ¯å°å†™çš„ç»“æ„ä½“ï¼Œä»¥è¾¾åˆ°æ§åˆ¶è®¿é—®çš„ä½œç”¨)


- ç»“æ„ä½“æ–¹æ³•
	- ç»“æ„ä½“çš„è¡Œä¸ºï¼Œéœ€è¦ç”¨æ–¹æ³•æ‰èƒ½å®Œæˆ
	- Goè¯­è¨€ä¸­çš„æ–¹æ³•æ˜¯ä½œç”¨åœ¨æŒ‡å®šçš„æ•°æ®ç±»å‹ä¸Šçš„(å’ŒæŒ‡å®šçš„æ•°æ®ç±»å‹ç»‘å®š)
	- è‡ªå®šä¹‰ç±»å‹éƒ½å¯ä»¥æœ‰æ–¹æ³•ï¼Œä¸ä»…ä»…æ˜¯ç»“æ„ä½“ 
	- æ–¹æ³•çš„å£°æ˜ä¸è°ƒç”¨
```go
		type A struct {
			Name string  
		}  
		func (a A) say(){           // è¡¨ç¤ºç»“æ„ä½“Aæœ‰ä¸€ä¸ªæ–¹æ³•ï¼Œåç§°ä¸ºsay
			fmt.Println(a.Name)     // (a A) ä½“ç°say æ–¹æ³•ä¸A ç±»å‹ç»‘å®š  
		}
```	


## å…­ã€å¼•ç”¨ç±»å‹

### 1. æŒ‡é’ˆ
- æŒ‡é’ˆä¸å˜é‡
	- å˜é‡æ˜¯ä¸€ç§ä½¿ç”¨æ–¹ä¾¿çš„å ä½ç¬¦ï¼Œç”¨äºå¼•ç”¨è®¡ç®—æœºå†…å­˜åœ°å€
	- å¯ä»¥é€šè¿‡`&`è¿ç®—ç¬¦è·å–å˜é‡åœ¨å†…å­˜ä¸­çš„å­˜å‚¨ä½ç½®ï¼ŒæŒ‡é’ˆæ˜¯ç”¨æ¥å­˜å‚¨å˜é‡åœ°å€çš„å˜é‡
	- æœ¬è´¨ -> å†…å­˜åœ°å€ï¼Œæ²¡æœ‰æ•°æ®ç±»å‹ï¼Œå  8bytes

- å£°æ˜åˆå§‹åŒ–ä¸èµ‹å€¼
	- æŒ‡é’ˆå£°æ˜éœ€è¦æŒ‡å®šå­˜å‚¨åœ°å€ä¸­å¯¹åº”æ•°æ®çš„ç±»å‹ï¼Œå¹¶ä½¿ç”¨`*`ä½œä¸ºç±»å‹å‰ç¼€
```go
		var ip *int        // æŒ‡å‘æ•´å‹
		var fp *float32    // æŒ‡å‘æµ®ç‚¹å‹
```
	- æŒ‡é’ˆå˜é‡å£°æ˜åä¼šè¢«åˆå§‹åŒ–ä¸º nilï¼Œè¡¨ç¤ºç©ºæŒ‡é’ˆ
	- ä½¿ç”¨ new å‡½æ•°åˆå§‹åŒ–åï¼Œnew å‡½æ•°æ ¹æ®æ•°æ®ç±»å‹ç”³è¯·å†…å­˜ç©ºé—´å¹¶ä½¿ç”¨é›¶å€¼å¡«å……ï¼Œå¹¶è¿”å›ç”³è¯·ç©ºé—´åœ°å€
```go
		var a *int = new(int)
		fmt.Println(a)       // 0xc000014330
		fmt.Println(*a)      // 0
```
	- æŒ‡é’ˆèµ‹å€¼
```go
		var a *int = new(int)
		*a = 10 
		fmt.Println(a, *a)   // 0xc000014330, 10
```
	- æŒ‡é’ˆè¿ç®—
		- `&` è·å–å˜é‡çš„æŒ‡é’ˆ `b := &a è·å–å˜é‡aåœ¨å†…å­˜ä¸­çš„å­˜å‚¨ä½ç½®ï¼Œå³ å–å¼•ç”¨ - å–åœ°å€`
		- `*` è·å–æŒ‡é’ˆæŒ‡å‘çš„å€¼ `*b æŒ‡é’ˆå˜é‡å­˜å‚¨åœ°å€ä¸­çš„å€¼ï¼Œå³ è§£å¼•ç”¨ - è¿”å›å†…å­˜åœ°å€ä¸­å¯¹åº”çš„å¯¹è±¡ - å–å€¼`

- å¤šç»´æŒ‡é’ˆ
	- ç”¨æ¥å­˜å‚¨æŒ‡é’ˆå˜é‡åœ°å€çš„å˜é‡å«åšæŒ‡é’ˆçš„æŒ‡é’ˆ
```go
		var a ****int
		v := 10
		p1 := &v                        // *int
		p2 := &p1                       // **int    &p1ï¼Œå³æŒ‡é’ˆå˜é‡æœ¬èº«çš„å†…å­˜åœ°å€
		p3 := &p2                       // ***int
		a = &p3                         // ****int
		fmt.Println(v, p1, p2, p3, a)
```

### 2. å…¶ä»–
- sliceã€mapã€channel æ˜¯Goè¯­è¨€é‡Œçš„3ç§å¼•ç”¨ç±»å‹ï¼Œéƒ½å¯ä»¥é€šè¿‡makeå‡½æ•°è¿›è¡Œåˆå§‹åŒ–(ç”³è¯·åˆ†é…å†…å­˜)ï¼Œå› ä¸ºå…¶åŒ…å«ä¸€ä¸ªæŒ‡å‘åº•å±‚æ•°æ®ç»“æ„çš„æŒ‡é’ˆï¼Œæ‰€ä»¥ç§°ä¸º"å¼•ç”¨"ç±»å‹

- å¼•ç”¨ç±»å‹æœªåˆå§‹åŒ–æ—¶éƒ½æ˜¯nilï¼Œå¯ä»¥å¯¹å®ƒä»¬æŒ‡å‘len()å‡½æ•°ï¼Œè¿”å›0

- æ·±æµ…æ‹·è´
	- å®šä¹‰&&åŒºåˆ«
		- æ·±æ‹·è´ copyçš„æ˜¯æ•°æ®æœ¬èº«
			- å¤åˆ¶çš„æ—¶å€™ä¼šåˆ›å»ºä¸€ä¸ªæ–°çš„å¯¹è±¡
			- æŒ‡å‘å®Œå…¨ä¸åŒçš„å†…å­˜åœ°å€
			- ä¿®æ”¹äº’ä¸å½±å“
		- æµ…æ‹·è´ å¤åˆ¶çš„æ˜¯å¯¹è±¡çš„æŒ‡é’ˆï¼Œ
			- æ–°è€å¯¹è±¡æŒ‡å‘åŒä¸€å—å†…å­˜åŒºåŸŸ
			- aä¿®æ”¹å­—æ®µï¼Œbä¸­çš„å­—æ®µä¹Ÿä¸€åŒè¢«ä¿®æ”¹
			- å†…å­˜æ¶ˆè€—æ˜¯ä¸€è‡´çš„
	- ç±»å‹
		- å€¼ç±»å‹çš„éƒ½æ˜¯æ·±æ‹·è´ `intã€floatã€boolã€arrayã€struct`
		- å¼•ç”¨ç±»å‹éƒ½æ˜¯æµ…æ‹·è´ `sliceã€mapã€function`

- newå’Œmakeå¯¹æ¯”
	- new å¼€è¾Ÿä¸€ä¸ªç±»å‹å¯¹åº”çš„å†…å­˜ç©ºé—´ï¼Œè¿”å›ä¸€ä¸ªå†…å­˜ç©ºé—´çš„åœ°å€ï¼›ä¸”åªèƒ½åˆ†é…åœ°å€ï¼Œä¸€èˆ¬ç”¨äºåŸºç¡€ç±»å‹çš„åˆå§‹åŒ–ï¼›
	- `make{makeslice, makemap, makechannel}` makeè¿”å›åˆ›å»ºå¯¹è±¡çš„å†…å­˜åœ°å€  
	ä»¥sliceä¸ºä¾‹ï¼Œunsafe.Pointer --> slince struct --- {member: pointer ---> array}  è¡¨ç°ä¸º: []int  
	
	|å‡½æ•°ç±»å‹ |é€‚ç”¨èŒƒå›´|è¿”å›å€¼|å¡«å……ç±»å‹|
	|:------:|:------:|:------:|:------:|
	|new|newå¯ä»¥å¯¹æ‰€æœ‰ç±»å‹è¿›è¡Œåˆ†é…|newè¿”å›æŒ‡é’ˆ|newå¡«å……é›¶å€¼|
	|make|makeåªèƒ½åˆ›å»ºç±»å‹(sliceã€mapã€channel)|makeè¿”å›å¼•ç”¨|makeå¡«å……éé›¶å€¼|  


