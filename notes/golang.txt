##Golang基础
一、基础语法
1、Golang简介
 - Go语言中将数据类型分为四类: 基础类型、复合类型、引用类型和接口类型
 	- 基础类型，包括: 数字、字符串和布尔型
 	- 复合数据类型，包括: 数组和结构体，即通过组合简单类型，来表达更加复杂的数据结构
 	- 引用类型，包括指针、切片、字典、函数、通道，虽然数据种类很多，但它们都是对程序中一个变量或状态的间接引用，这意味着对任一引用类型数据的修改都会影响所有该引用的拷贝
 	- 接口类型
 - Go语言的编译
 	- 决定语法正确的是: 底层编译器
 	- 编译的基础单位: Lexical Token (词法标记)，如 `go/token` 包
 - Go语言的注释 
	- `// 单行注释`
	- `/* 多行注释 */`
	- 特定场景注释: 构建注释，如: windows，linux  
	- 包注释，包文件开头注释等 

2、程序结构
 - 内置常量: true、false、nil、iota
 - 内置类型: bool、byte、rune、int、int8、int16、int32、int64、uint、uint8、unit16、unit32、unit64、uintptr、float32、float64、complex64、complex128、string、error
 - 空白标识符: _  // 使用空白标识符，则无需引用
 - 内置函数: make、len、cap、new、append、copy、close、delete、complex、real、imag、panic、recover
 - 其他
	- 各数据类型所占字节大小
		in8			: 1byte
		int64/uint64  : 8bytes 2^64
		rune   		: 4bytes
		string 		: 16bytes(4 * 4)   // string = 2*int64 = 2*8bytes  []byte(string)
		slice  		: 24bytes          // 切片的本质是一个slice结构体指针，指针为一个uint64内存地址，默认值为0，长度为24
	- 数据单位
		1Word(字) = 2Bytes(字节)
		1Byte = 8bit(位)  // 2^8
		1KB   = 1024B
		1MB   = 1024KB
		1GB   = 1024Mb
		1TB   = 1024GB
	- new和make对比
		new 开辟一个类型对应的内存空间，返回一个内存空间的地址；且只能分配地址，一般用于基础类型的初始化；
		make{makeslice,makemap,makechannel} make返回创建对象的内存地址 // 以slice为例，unsafe.Pointer --> slince struct --- {member: pointer ---> array}  表现为: []int
		对比表格
			函数类型   适用范围                                返回值         填充类型
			new        new可以对所有类型进行分配               new返回指针    new填充零值 
			make       make只能创建类型(slice、map、channel)   make返回引用   make填充非零值
 - 25 关键字
	- Go语言中类似if和switch的关键字有25个
	- 关键字不能用于自定义名字，只能在特定语法结构中使用
		- 引用包: import、package
		- 实体声明和定义: const、var、type、func、interface、map、struct、chan
		- 流程控制: break、case、continue、default、defer、else、fallthrough、for、go、goto、if、range、return、select、switch
	- 在声明变量时，如果初始化表达式被省略，那么将用零值初始化该变量
		- 数值类型变量对应的零值是0
		- 布尔类型变量对应的零值是false
		- 字符串类型对应的零值是空字符串
		- 接口或引用类型(包括slice、map、chan和函数)变量对应的零值是nil
		- 数组或结构体等聚合类型对应的零值是每个元素或字段都是对应该类型的零值
	- 初始化表达式可以是字面量或任意的表达式
		- 在包级别声明的变量会在main入口函数执行前完成初始化
		- 局部变量将在声明语句被执行到的时候完成初始化

4、操作符
 - 算术运算符: +、-、*、/、%、++、--        // i++ 为表达式，非语句，无法赋值给变量
 - 关系运算符: >、>=、<、<=、==、!=         // 判断A 与 B的关系，结构: 布尔值，函数不可以比较
 - 逻辑运算符: &&、||、!                    // &&对应逻辑乘法，||对应逻辑加法，乘法比加法优先级要高
 - 位运算符: &、|、^、<<、>>、&^
 - 赋值运算符: =、+=、-=、*=、/=、%=、&=、|=、^=、<<=、>>=   // 值可能是数据，也可能是地址
 - 其他运算符: &(单目)、*(单目)、.(点)、-(单目)、…、<-    // 单目运算符优先级最高
 - 占位符: _   //    /dev/null 1B<>,_ 就是丢弃值

5、分割符
 - 小括号()  中括号[]  大括号{}  分号;  逗号,

6、指针
 - 指针与变量
	- 变量是一种使用方便的占位符，用于引用计算机内存地址。
	- 可以通过&运算符获取变量在内存中的存储位置，指针是用来存储变量地址的变量
	- 本质 -> 内存地址，没有数据类型，占8bytes
 - 声明初始化与赋值
	- 指针声明需要指定存储地址中对应数据的类型，并使用*作为类型前缀。 
		- var ip *int        // 指向整型
		- var fp *float32    // 指向浮点型
	- 指针变量声明后会被初始化为 nil，表示空指针
	- 使用 new 函数初始化: new 函数根据数据类型申请内存空间并使用零值填充，并返回申请空间地址 
		var a *int = new(int)
		fmt.Println(a)       // 0xc000014330
		fmt.Println(*a)      // 0
	- 指针赋值
		var a *int = new(int)
		*a = 10 
		fmt.Println(a, *a)   // 0xc000014330, 10
	- 指针运算
		- & 获取变量的指针              // b := &a 获取变量a在内存中的存储位置，即 取引用-取地址
		- * 获取指针指向的值            // *b 指针变量存储地址中的值，即 解引用-返回内存地址中对应的对象-取值 
 - 多维指针
	- 用来存储指针变量地址的变量叫做指针的指针
		var a ****int
		v := 10
		p1 := &v                        // *int
		p2 := &p1                       // **int    &p1，即指针变量本身的内存地址
		p3 := &p2                       // ***int
		a = &p3                         // ****int
		fmt.Println(v, p1, p2, p3, a)
		
7、基本注解
	// 当前程序的包名, main包表示入口包, 是编译构建的入口
	package main
	// 导入其他包
	import "fmt"
	// 常量定义
	const PI = 3.1415
	// 全局变量声明和赋值       变量本质: 内存地址; 值: 数据; 变量赋值: 修改值空间里存储的数据; 变量的声明: 强类型 -> 变量指向的值空间，存储的数据，受到类型的限制; 作用: 复用、配置、简洁易读
	var name = "fly"
	// 定义"别名"，counter类型实际还是int，比如 rune 为 int32； byte 为 uint8
	type counter = int
	// 一般类型声明
	type newType int
	// 函数声明
	type myFun func(x, y int) int
	// 结构体声明
	type student struct{}
	// 接口声明
	type reader interface{}
	// 程序入口
	func main() {
			fmt.Println("hello world, this is my first golang program!")
	}

二、输入输出
1、标准输入
1).函数种类
 - Print:   输出到控制台，不接受任何格式化操作
 - Println: 输出到控制台并换行
 - Printf : 只可以打印出格式化的字符串；只可以直接输出字符串类型的变量(不可以输出别的类型)
 - Sprintf: 格式化并返回一个字符串而不带任何输出
 - Fprintf: 来格式化并输出到 io.Writers 而不是 os.Stdout     // func fmt.Fprintf(w io.Writer, format string, a ...interface{}) (n int, err error)
2).占位符
 - 类型
	%v : 变量的自然形式(natural format)
		%+v : 类似%v，但输出结构体时会添加字段名  // 类型+值对象
		%#v : 相应值的Go语法表示                  // 输出字段名和字段值形式
	%T : 相应值的类型的Go语法表示，变量的类型
	%% : 百分号，字面上的%，非占位符含义
 - 字符串
	%s : 字符串类型                               // %ns 打印字符前空n个宽度，默认+，右对齐；若-，左对齐
	%q : 双引号围绕的字符串
	%x : 十六进制，小写字母，每字节两个字符
	%X : 十六进制，大写字母，每字节两个字符
 - 整型
	%t : bool类型
	%c : 相应Unicode码点所表示的字符                        // rune: Unico de co de point
	%q : 带单引号 的字符                                    
	%b : 二进制                                             
	%o : 八进制                                             // %#o 带 0 的前缀
	%d : 十进制                                             
	%x 、 %X : 十六进制                                     // %#x(%# 带 0x(0X) 的前缀
	%U : Unicode 字符, Unicode格式: 123，等同于 "U+007B"    // %#U 带字符的 Unicode 码点
		%d : 十进制 
			%+d  表示 对正整数 带 符号
			%nd  表示 最小 占位 n 个宽度且右对齐
			%-nd 表示 最小 占位 n 个宽度且左对齐
			%0nd 表示 最小 占位 n 个宽度且右对齐 空字符使用 0 填充
			"%d|%+d|%10d|%-10d|%010d|%+-10d|%+010d"
 - 浮点型
	%f 、 %F : 十进制表示法                                 // %n.mf 表示最小占 n 个宽度并且保留 m 位小数
	%e 、 %E : 科学记数法表示
	%g 、 %G : 自动选择 最 紧凑的表示 方法 %e(E%) 或 %f(F%)
 - 指针
	%v : 指针变量访问位置中存储的值                         // %#v接口的类型
	%q : 指针变量访问位置中存储的值(unicode 中文)
	%p : 十六进制表示，前缀 0x                              // 默认情况下，指针是已16进制存在的
 - 特殊字符: 
	\: 反斜线
	': 单引号                                               // '' 只可以定义单一字符
	": 双引号                                               // "" 可解析的字符串
	``: 原始字符串/多行字符串
	\a: 响铃
	\b: 退格
	\f: 换页
	\n: 换行
	\r: 回车
	\t: 制表符
	\v: 垂直制表符
	\ooo: 3 个 8 位数字给定的八进制码点的 Unicode 字符(不能超过\377)
	\uhhhh: 4 个 16 位数字给定的十六进制码点的 Unicode 字符
	\Uhhhhhhhh: 8 个 32 位数字给定的十六进制码点的 Unicode 字符
	\xhh: 2 个 8 位数字给定的十六进制码点的 Unicode 字符

2、标准输出 
1).函数种类 
 - go doc fmt | grep -Ei "func [FS]*Scan"   
 - Scan家族: 从标准输入os.Stdin中读取数据，包括Scan()、Scanf()、Scanln()   // 需要使用指针 Scan(&name) scan会直接将输入的值存入指针所指的内存地址的值
 - SScan家族: 从字符串中读取数据，包括Sscan()、Sscanf()、Sscanln()         // 即从字符串扫描到变量 func fmt.Sscan(str string, a ...interface{}) (n int, err error) 
 - Fscan家族: 从io.Reader中读取数据，包括Fscan()、Fscanf()、Fscanln()      // 即从文件扫描到变量 func fmt.Fscan(r io.Reader, a ...interface{}) (n int, err error)
2).注意事项
 - Scanln、Sscanln、Fscanln在遇到换行符的时候停止
 - Scan、Sscan、Fscan将换行符当作空格处理
 - Scanf、Sscanf、Fscanf根据给定的format格式读取，就像Printf一样
 - Scan家族函数从标准输入读取数据时，以空格做为分隔符分隔标准输入的内容，并将分隔后的各个记录保存到给定的变量中

3、流结束
 - EOF: 用于标识 流(io stream)结束 
	- parser/parser.go 会重复解析声明到文件的最后
		for p.tok != token.EOF {
			decls = append(decls, p.parseDecl(declStart))
		}

4、格式转换
 - strconv包
	- 提供了字符串与简单数据类型之间的类型转换功能，可以将简单类型转换为字符串，也可以将字符串转换为其它简单类型  // import "strconv"
	- int转string   ->   strconv.Itoa()
		str := strconv.Itoa(100)
		fmt.Printf("type %v, value: %s\n", reflect.TypeOf(str), str)
	- string转int   ->   strconv.Atoi()
		i, err := strconv.Atoi("100x")
		fmt.Printf("type %v, value: %d, err: %v\n", reflect.TypeOf(i), i, err)
	- string转bool  ->  strconv.ParseBool()
		b, err := strconv.ParseBool("true")
	- string转float ->  strconv.ParseFloat()
		f, err := strconv.ParseFloat("3.1", 64)
	- string转int   ->  func ParseInt(s string, base int, bitSize int) (i int64, err error)
		i, err := strconv.ParseInt("11111111", 2, 16)
	- string转uint  ->  func ParseUint(s string, base int, bitSize int) (uint64, error)
		u, err = strconv.ParseUint("4E2D", 16, 16)
	- bool转string  ->  strconv.FormatBool(true)
	- float转string ->  strconv.FormatFloat(3.1415, 'E', -1, 64)  // func FormatFloat(f float64, fmt byte, prec, bitSize int) string
	- int转string   ->  strconv.FormatInt(255, 10)
	- uint转string  ->  strconv.FormatUint(255, 16) 


三、流程控制
1、条件语句 - if语句
 - 对于条件语句必须有if 语句，可以有 0 个或多个 else if 语句 ，最多有 1 个 else 语句
 - if嵌套
	if bool1 {
		/* bool1 = true */
	} else {
		if bool2 {
			/* bool2 = true */
		} else {
			if bool3 {
			/* bool3 = true */
			} else {
				/* bool3 = false */
				}
			}
		}
 - 多重判断
	if bool1 {
		/* bool1 = true */
	} else if bool表达式2 {
		/* bool2 = true */
	} else if bool表达式3 {
		/* bool3 = true */
	} else {
		/* bool = false */
	}

2、选择语句 - switch
 - 对于选择语句可以有0个或多个case语句，最多有1个default语句选择条件为true的case语句块开始执行并退出
 - 若所有条件为false，则执行default语句块并退出
 - 可以通过fallthrough修改执行退出行为，继续执行下一条的case或default语句块
	switch var1 {
	case var2 :
		...
		fallthrough  // 只要执行成功，就无视case2的条件，强制执行下一个语句
	case var3 :
		...
	case var4,var5 :
		...
		if(...){
			break
		}
		fallthrough // 此时switch会执行case3和case4，但是如果满足if条件，则只执行case3
	case var6 :
		...
	default:
		...
	}

3、循环语句 - for
 - 基本用法
	- 基本表达式
		for init; condition; post { 
			...
		}
		- init:  一般为赋值表达式，给控制变量赋初值
		- condition:  关系表达式或逻辑表达式，循环控制条件
		- post:  一般为赋值表达式，给控制变量增量或减量
		- 执行顺序为
			a) 初始化子语句 init
			b) 条件子语句   condition
			c) 语句块
			d) 后置子语句   post
			e) b -->c -->d
			f) 直到条件子语句为 false 结束循环
	- break     用于跳出循环，当条件满足则结束循环
	- continue  用于跳过循环，当条件满足这跳过本次循环进行后置或条件子语句执行
 - 类while
	- for子语句可以只保留条件子语句，此时类似于其他语言中的 while 循环
		for condition { 
			...
		}
 - 无限循环
	- for i := 0;;i++
	- for ;; { }
	- for true { }
	- for { }
	- for子语句全部省略，则为无限循环(死循环)，常与 break 结合使用
 - for-range 
	- 用于遍历 可迭代对象中的每个元素，例如字符串，数组，切片，映射，通道 等
	- 针对包含Unicode 字符的字符串遍历是需要使用 for range
	- range 返回两个元素分别为字节索引index 和 rune 字符，可通过空白标识符_ 忽略需要接收的变量
		for index,value := range iterable {
			...
		}
 - label 与 goto
	- 通过 goto 语句任意跳转到当前函数指定的 label 位置
 - 嵌套循环
	for [condition |  ( init; condition; increment ) | Range] {
		for [condition |  ( init; condition; increment ) | Range]{
			statement(s);
		}
		statement(s);
	}

4、示例
1).乘法口诀表
 - 正三角
	for i := 1; i < 10; i++ {
		for j := 1; j <= i; j++ {
				fmt.Printf("%-2d * %-2d = %-2d\t", j, i, i*j)
		}
		fmt.Println()
	}
 - 倒三角
	for i := 1; i < 10; i++ {
		for j := 1; j < i; j++ {
			var n string
			fmt.Printf("%-2s   %-2s   %-2s\t", n, n, n)
		}
		for j := i; j < 10; j++ {
			fmt.Printf("%-2d * %-2d = %-2d\t", j, i, i*j)
		}
		fmt.Println()
	}
2).求100以内素数的和
	var sum int
	i := 2
	var isP bool
	for i < 101 {
			isP = true
			j := 2
			for j <= (i / j) {
					if i%j == 0 {
							// fmt.Printf("%d不是素数\n",i)
							isP = false
							break
					}
					j++
			}
			if isP {
					fmt.Printf("%d是素数\n", i)
					sum += i
			}
			i++
	}
	fmt.Println(sum)
	}
	
四、复合数据类型
1、数组 array    // 占用内存空间 = length * 数据类型的字节大小
1).定义
 - 数组是具有相同数据类型的数据项组成的一组长度固定的序列，数据项叫做数组的元素，数组的长度必须是非负整数的常量，长度也是类型的一部分
 - 当在Go中声明一个数组之后，会在内存中开辟一段固定长度的、连续的空间存放数组中的各个元素，这些元素的数据类型完全相同，可以是内置的简单数据类型(int、string等)，也可以是自定义的struct类型
	- 固定长度: 这意味着数组不可增长、不可缩减，想要扩展数组，只能创建新数组，将原数组的元素复制到新数组
	- 连续空间: 这意味可以在缓存中保留的时间更长，搜索速度更快，是一种非常高效的数据结构，同时还意味着可以通过数值index的方式访问数组中的某个元素
	- 数据类型: 意味着限制了每个block中可以存放什么样的数据，以及每个block可以存放多少字节的数据
2).声明&&初始化
 - 指定数组长度 var name [length]type = [length]type{v1, v2, …,vlength}
 - 使用初始化元素数量推到数组长度 name := [...]type{v1, v2, …,vlength}
 - 对指定位置元素进行初始化 var name [length]type = [length]type{im:vm, …, sin:in}
3).指针数组
 - 声明一个指针类型的数组，这样数组中就可以存放指针
 - 指针的默认初始化值为nil
	a := [4]*int{0: new(int), 3: new(int)}   // [0xc00011a300 <nil> <nil> 0xc00011a308]
	a[1] = new(int)                          // 空指针直接赋值会报错
	*a[1] = 10                               // [0xc00011a300 0xc00011a310 <nil> 0xc00011a308]
	b := a                                   // [0xc00011a300 0xc00011a310 <nil> 0xc00011a308]
4).遍历数组
	for i := 0; i < len(name); i++ {
			fmt.Println(i, name[i])
	}
	for i, j := range name {
			fmt.Printf("%d %q\n", i, j)
	}
4).多维数组
 - 声明&&初始化
	var name [vlength][vvlength]type = [vlength][vvlength]type{{v1,v2, …,vvlength}, {v1,v2, …,vvlength}, …,{vlength,vvlength}}
	name := [...][vvlength]type{{v1,v2, …,vvlength}, {v1,v2, …,vvlength}, …,{vlength,vvlength}}  // 多维数组只有第一维长度可使用变量数量推测
	name := [vlength][vvlength]type{0:{0:v1,3:v2},5:{2:v1,5:v2, …,m:v3}, …,n:{6:v1,m:vvlength}}
 - 遍历
	for i := 0; i < len(name); i++ {
			for j := 0; j < len(name[i]); j++ {
					fmt.Printf("[%d ,%d]: %q\n", i, j, name[i][j]) 
			}
	}
	for i, line := range name {
			for n, m := range line {
					fmt.Printf("[%d ,%d]: %q\n", i, n, m)
			}
	}

2、切片 slice
1).定义
 - 切片是长度可变的数组，即 具有相同数据类型的数据项组成的一组长度可变的序列 ，切片由三部分组成
	- 指针(array): 指向 第一个slice元素对应的底层数组元素的地址，要注意的是slice的第一个元素并不一定就是数组的第一个元素
	- 长度(length): 切片元素的数量
	- 容量(capacity): 切片开始到结束位置(可容纳)元素的数量
 - Go语言中的slice依赖于数组，它的底层就是数组，所以数组具有的优点，slice都有
	// runtime/slice.go
	type slice struct {
		array unsafe.Pointer // 数组指针
		len   int // 长度 
		cap   int // 容量
	}
 - Go语言中的slice支持通过append向slice中追加元素，长度不够时会动态扩展，通过再次slice切片，可以得到得到更小的slice结构，可以迭代、遍历等
	- 切片共享底层数组，若某个切片元素发生变化，则数组和其他有共享元素的切片也会发生变化
	- 切片底层是一个长度和数据类型固定的数组，只有在切片的长度大于底层数组的长度后，该切片的底层才会在内存中更换新的数组
2).声明&&初始化
 - 使用字面量初始化空切片       []type{}   // 初始化为零值 nil
 - 使用字面量初始化             var name []type = []type{v1, v2, …,vn}
 - 指定长度和容量字面量初始化   []type{im:vm, in:vn, ilength:vlength]
 - 使用make函数初始化           make([]type, len)/make([]type, len, cap)    通过 make 函数创建长度为 len，容量为 cap 的切片，且 len 必须小于等于 cap
 - 使用数组切片操作初始化 
	array[start:end]            // end <= src_cap ; 新创建切片长度和容量计算: new_len: end-start, new_cap: src_cap-start ;
	array[start:end:end_cap]    // 用于限制新切片的容量值(end<=cap<=src_cap)；新创建切片长度和容量计算 new_len: end-start, new_cap: end_cap-start
3).遍历切片                     // 同数组
4).增加元素 
 - 使用append函数对切片增加一个或多个元素并返回修改后切片，当长度在容量范围内时只增加长度，容量和底层数组不变。
 - 当长度超过容量范围则会创建一个新的底层数组并对容量进行智能运算(元素数量<1024时，约按原容量1倍增加，>1024时约按原容量0.25倍增加)
	append(slice, 1, 2, ...,n)  // 移除元素 append(slince[:n-1], slince[n+1]...)
5).复制切片
	copy(drc_slice, src_slice)  // 移除元素 copy(slice[3:], slice[4:])
6).应用
 - 用切片实现队列
	queue := []int{}
	queue = append(queue, 1)
	queue = append(queue, 2)
	queue = queue[1:]
 - 用切片实现堆栈
	stack := []int{}
	stack = append(stack, 1)	
	stack = append(stack, 2)
	stack = stack[:len(stack)-1]
5).多维切片
 - 声明&&初始化
	var name [][]type = [][]type{{v1,v2, …,vvlength}, {v1,v2, …,vvlength}, …,{vlength,vvlength}}
	name := [][]type{0:{0:v1,3:v2},5:{2:v1,5:v2, …,m:v3}, …,n:{6:v1,m:vvlength}}
 - append
	slice = append(slice, []int{1, 2, 3})
	slice[0] = append(point[0], 1)
 - copy
	slice2 := [][]int{{}, {}}
	copy(slice2, slice)
6).其他
 - 字节切片    // bytes包
	[]byte{string}
	string([]byte{})
 - rune切片
	[]rune{string}
	string([]rune{})

3、映射map
1).定义
 - 映射是存储一系列无序的 key/value 对，通过 key 来对 value 进行操作，即 增、删、改、查
2).声明&&初始化
 - map声明需要指定组成元素key和value的类型，在声明后，会被初始化为nil，表示暂不存在的映射 
 - nil map，它将不会做任何初始化，不会指向任何数据结构；而直接赋值会报空指针，map类型实际上就是一个指针, 具体为 *hmap
 - 初始化
	- 使用字面量初始化 map[ktype]vtype{k1:v1, k2:v2, …, kn:vn}  // key -> string、int、bool、array
	- 使用字面量初始化空映射 map[ktype]vtype{}                  // 若不加{}，则初始化为nil，即无法添加key
	- 使用make函数初始化 make(map[ktype]vtype)，通过make函数创建映射，它会先创建好底层数据结构，然后再创建map，并让map指向底层数据结构
 - 判断是否存在
	- 通过key访问元素时可接收两个值，第一个值为value，第二个值为bool类型表示元素是否存在，若存在为true，否则为false
		map_01, ok := map[1]
		fmt.Printf("%t, %v\n", ok, map_01)
 - 修改&增加
	- 使用key对映射赋值时当key存在则修改key对应的value，若key不存在则增加key和value
 - 删除
	- 使用delete函数删除映射中已经存在的key
		delete(map, 3)
		delete(map[2], "XX")
3).多维映射
	map := map[int]map[string]string{1: map[string]string{"name": "aa", "tel": "123"}, 2: map[string]string{"name": "bb", "tel": "456"}}
4).遍历映射
	for k, v := range map {
		fmt.Printf("%v:%v\n", k, v)
	}
5).使用
 - Go语言中只要是可比较的类型都可以作为 key。除开 slice，map，functions 这几种类型，其他类型都是 OK 的 
	- 具体包括: 布尔值、数字、字符串、指针、通道、接口类型、结构体、只包含上述类型的数组
	- 这些类型的共同特征是支持 == 和 != 操作符，k1 == k2 时，可认为 k1 和 k2 是同一个 key 
	- 如果是结构体，则需要它们的字段值都相等，才被认为是相同的 key
	- key和map本身都可以被哈希(类似漏斗，可以把很大一部分数据，筛选成一小部分特征，又叫散列)
 - map为引用类型，使用时需要注意初始化，否则空指针nil 会报错
	- 如在结构体中新增map字段，在后面的引用代码中需要添加make初始化map
 - 开销: 稀疏型数据结构，牺牲空间换取时间
	- 相对而言的数组，完整型数据结构
 - map删除数据时存在延迟，所以最好不作为内存存储
6).函数中的应用
 - map作为函数参数
	- map是一种指针，所以将map传递给函数，仅仅只是复制这个指针，所以函数内部对map的操作会直接修改外部的map
		a := map[int]string{1: "a", 2: "b", 3: "c"}
		func(map[int]string) {
			delete(a, 1)
		}(a)
 - map值为函数
	op := map[string]func(x, y int) int{
		"+": func(x, y int) int {
			return x + y
		},
		"-": func(x, y int) int {
			return x - y
		},
		"*": func(x, y int) int {
			return x * y
		},
		"/": func(x, y int) int {
			return x / y
		},
	}
	fmt.Println(op["+"](1, 2))
	fmt.Println(op["-"](1, 2))
7).示例 - 使用map统计 "I have a dream" 中，各字母出现次数
    article := `
		I have a dream
		...
		`
    stats := map[rune]int{}

    for _, ch := range article {
            if ch >= 'a' && ch <= 'z' || ch >= 'A' && ch <= 'Z' {
                    stats[ch]++
            }
    }
    for ch, cnt := range stats {
            fmt.Printf("%c, %v\n", ch, cnt)
    }
8).Go语言中原生的map线程不安全
 - 解决方案一: 加锁
	type concurrentMap struct {
		sync.RWMutex
		mp map[int]int
	}
	func (c *concurrentMap) Set(key int, value int) {
		// 获取写锁
		c.Lock()
		c.mp[key] = value
		c.Unlock()
	}
	func (c *concurrentMap) Get(key int) int {
		// 获取读锁
		c.RLock()
		res := c.mp[key]
		c.RUnlock()
		return res
	}
	c := concurrentMap{
		mp: (map[int]int{}),
	}
	// 写map的goroutine
	go func() {
		for i := 0; i < 10000; i++ {
			c.Set(i, i)
		}
	}()
	// 读map的goroutine
	go func() {
		for i := 0; i < 10000; i++ {
			res := c.Get(i)
			fmt.Printf("[cmap.get][%d=%d]\n", i, res)
		}
	}()
	time.Sleep(20 * time.Second)
	
 - 解决方案二: 使用sync.map
	- go 1.9引入的内置方法，并发线程安全的map
	- sync.Map 将key和value 按照interface{}存储
	- 查询出来后要类型断言 x.(int) x.(string)
	- 遍历使用Range() 方法，需要传入一个匿名函数作为参数，匿名函数的参数为k,v interface{}，每次调用匿名函数将结果返回
	- sync.map 性能对比   // https://studygolang.com/articles/27515
		- 性能对比结论
			只读场景: sync.map > rwmutex >> mutex
			读写场景(边读边写): rwmutex > mutex >> sync.map
			读写场景(读80% 写20%): sync.map > rwmutex > mutex
			读写场景(读98% 写2%): sync.map > rwmutex >> mutex
			只写场景: sync.map >> mutex > rwmutex
		- sync.Map使用场景的建议
			- 读多: 给定的key-v只写一次，但是读了很多次，只增长的缓存场景
			- key不相交: 覆盖更新的场景比少
			- 结构体复杂的case多不用sync.Map
			
 - 解决方案三: 分片锁 并发map github.com/orcaman/concurrent-map
9).带过期时间的map
 - map做缓存用的 垃圾堆积k1、k2 
 - 希望缓存存活时间 5分钟，
 - 将加锁的时间控制在最低，
 - 耗时的操作在加锁外侧做
		type item struct {
			value int   // 值
			ts    int64 // 时间戳，item被创建出来的时间,或者被更新的时间
		}
		
		type Cache struct {
			sync.RWMutex
			mp map[string]*item
		}
		
		func (c *Cache) Get(key string) *item {
			c.RLock()
			defer c.RUnlock()
			return c.mp[key]
		}
		
		func (c *Cache) Set(key string, value *item) {
			c.Lock()
			defer c.Unlock()
			c.mp[key] = value
		}
		
		func (c *Cache) Gc(timeDelta int64) {
			// GC 先加读锁 -> 检查确实有需要回收的数据 -> 合并写锁回收。
			for {
				toDelKeys := make([]string, 0)
				now := time.Now().Unix()
				c.RLock()
		
				// 变量缓存中的项目，对比时间戳，超过 timeDelta的删除
				for k, v := range c.mp {
					if now-v.ts > timeDelta {
						log.Printf("[这个项目过期了][key %s]", k)
						toDelKeys = append(toDelKeys, k)
					}
				}
				c.RUnlock()
		
				c.Lock()
				for _, k := range toDelKeys {
					delete(c.mp, k)
				}
				c.Unlock()
				time.Sleep(5 * time.Second)
			}
		}
		
		c := Cache{
			mp: make(map[string]*item),
		}
		// 让删除过期项目的任务，异步执行，
		go c.Gc(30)
		
		// 写入数据 从mysql读取
		for i := 0; i < 10; i++ {
			key := fmt.Sprintf("key_%d", i)
			ts := time.Now().Unix()
			im := &item{
				value: i,
				ts:    ts,
			}
			//设置缓存
			log.Printf("[设置缓存][项目][key:%s][v:%v]", key, im)
			c.Set(key, im)
		}
		time.Sleep(31 * time.Second)
		for i := 0; i < 5; i++ {
			key := fmt.Sprintf("key_%d", i)
			ts := time.Now().Unix()
			im := &item{
				value: i + 1,
				ts:    ts,
			}
			log.Printf("[更新缓存][项目][key:%s][v:%v]", key, im)
			c.Set(key, im)
		}
		select {} // 阻塞main
10).带过期时间的缓存 github.com/patrickmn/go-cache 

五、函数
1、定义
 - 函数用于对代码块的逻辑封装，提供代码复用的最基本方式, Go中有3种函数:
	- 普通函数
	- 匿名函数(没有名称的函数)
	- 方法(定义在struct上的函数)
 - Go实现了一级函数(first-class functions)，Go中的函数是高阶函数(high-order functions)。这意味着: 
	- 函数是一个值，可以将函数赋值给变量，使得这个变量也成为函数
	- 函数可以作为参数传递给另一个函数
	- 函数的返回值可以是一个函数
 - 定义语句
	- 签名
		func function_name( [parameter list] ) [return_types] {
			函数体
		}
	- func: 函数由 func 开始声明
	- function_name: 函数名称，函数名和参数列表一起构成了函数签名(signature)
	- parameter list: 参数列表，参数就像一个占位符，当函数被调用时，可以将值传递给参数，这个值被称为实际参数。参数列表指定的是参数类型、顺序、及参数个数。参数是可选的，也就是说函数也可以不包含参数
	- return_types: 返回类型，函数返回一列值。return_types 是该列值的数据类型；有些功能不需要返回值，这种情况下 return_types 不是必须的
	- 函数体: 函数定义的代码集合。
	
2、参数
 - 形参&&入参
	- 形参 定义函数时的参数
	- 入参 传递给函数的变量
 - 类型合并
	- 在声明函数中若存在多个连续形参类型相同可只保留最后一个参数类型名
		func sum(x, y int) int {}
 - 可变参数
	- 某些情况下函数需要处理形参数量可变，需要运算符 ARGS...TYPE 的方式声明可变参数函数或在调用时传递可变参数
	- 可变参数只能定义一个且只能在参数列表末端。在调用函数后，可变参数则被初始化为对应类型的切片(名为ARGS的slice,参数的数据类型都是TYPE)
		func max(a, b int, args ...int) int {}
	- 在调用函数时，也可以使用运算符 ... 将切片解包传递到可变参数函数中
		max(1, 2, slice[3:]...)
 - 值传递
	- 函数如果使用参数，该变量可称为函数的形参，形参就像定义在函数体内的局部变量
	- 值传递是指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数
	- 默认情况下，Go语言使用的是值传递(则先拷贝参数的副本，再将副本传递给函数)，即在调用过程中不会影响到实际参数
 - 引用传递
	- 引用传递是指在调用函数时将实际参数的地址传递到函数中，那么在函数中对参数进行的修改，将影响到实际参数
	- 由于引用类型(slice、map、interface、channel)自身就是指针，所以这些类型的值拷贝给函数参数，函数内部的参数仍然指向它们的底层数据结构
 - 值类型&引用类型     
	- 值类型和引用类型的差异在于赋值同类型新变量后，对新变量进行修改是否能够影响原来的变量，若不能影响则为值类型，若能影响则为引用类型
	- 值类型: 数值、布尔、字符串、指针、数组、结构体等
    - 引用类型: 切片、映射、接口等
	- 针对值类型可以借助指针修改原值
	- 针对值类型和引用类型在赋值后新旧变量的地址并不相同，只是引用类型在底层共享数据结构(其中包含指针类型元素)
 - 补充
	- 变量是一个地址，也是一个引用
	- 引用表达的是关系，指针表达的是类型；  
	- A --> B 是引用关系，而 A 是指针
	
3、返回值
 - 多返回值 
	func calcReturn(x, y int) (int, int, int, int) {
		return x + y, x - y, x * y, x / y
	}
 - 命名返回值
	func calcReturnNamecalc(x, y int) (sum, difference, product, quotient int) {
		sum, difference, product, quotient = x + y, x - y, x * y, x / y
		return
	}
 - 补充
	- return关键字中指定了参数时，返回值可以不用名称。如果return省略参数，则返回值部分必须带名称。
	- 但即使返回值命名了，return中也可以强制指定其它返回值的名称，也就是说return的优先级更高。
	- return中可以有表达式，但不能出现赋值表达式，这和其它语言可能有所不同。例如return a+b是正确的，但return c=a+b是错误的。

4、递归
1).定义
 - 函数内部调用函数自身的函数称为递归函数
	- 退出条件: 退出条件基本上都使用退出点来定义，退出点常常也称为递归的基点，是递归函数的最后一次递归点，或者说没有东西可递归时就是退出点。
	- 递归函数很可能会产生一大堆的goroutine(其它编程语言则是出现一大堆的线程、进程)，也很可能会出现栈空间内存溢出问题。
	- 在其它编程语言可能只能设置最大递归深度或改写递归函数来解决这个问题，在Go中可以使用channel+goroutine设计的"lazy evaluation"来解决。
2).阶乘          // n*(n-1)*...*3*2*1
	func factorial(n int) int {
		if n <= 0 {
				return -1
		} else if n == 1 { 
				return 1                    // 判断退出点
		} else {
				return n * factorial(n-1)   // 递归表达式
		}
	}
3).斐波那契数列  // f(n)=f(n-1)+f(n-2)且f(2)=f(1)=1
	func fib(n int) int {
		if n == 1 || n == 2 {
				return 1
		}
		return fib(n-1) + fib(n-2)
	}
4).汉罗塔
 - 将所有a柱上的圆盘借助b柱移动到c柱，在移动过程中保证每个柱子的上面圆盘比下面圆盘小
 - a -> 开始 ; b -> 借助 ; c -> 终止 
 - n: a -> c(b) ; 
 - n = 1 :  a -> c ; 
 - n > 1 : n - 1 (a -> b(c)) 、 a -> c ; n - 1 (b -> c(a))
	func tower(a, b, c string, layer int) {
        if layer <= 0 {
                return
        }
        if layer == 1 {
                fmt.Printf("%s - > %s\n", a, c)
				return
        }
        tower(a, c, b, layer-1)
        fmt.Printf("%s - > %s\n", a, c)
        tower(b, a, c, layer-1)
	}
	tower("A", "B", "C", 3)
5).递归一个目录
 - 它的递归基点是文件，只要是文件就返回，只要是目录就进入
 
5、函数类型
 - 函数也可以赋值给变量，存储在数组、切片、映射中，也可作为参数传递给函数或作为函数返回值进行返回
 - 声明&初始化&调用
	var callback func(n1, n2 int) (r1, r2, r3, r4 int)  // 定义函数类型变量，并使用零指nil进行初始化
	callback = calcReturn                               // 赋值为函数calcReturn
	callback(5, 2)                                      // 调用函数calcReturn
	- 声明函数类型变量f 为函数Add
		var f func(int, int) int = Add
		fmt.Println(f(4, 2)) // 6
	- 声明函数切片
		var fs []func(int, int) int
		fs = append(fs, Add, Sub, Mul, Div)
		fmt.Printf("%T;\n%#v\n", fs, fs)    // []func(int, int) int;
											// []func(int, int) int{(func(int, int) int)(0xb6ef20), (func(int, int) int)(0xb6ef20), (func(int, int) int)(0xb6ef40), (func(int, int) int)(0xb6ef60)}
		for _, f := range fs{
			fmt.Println(f(4,2))
		}
	- 返回值为函数
		func genFunc() func() {
			if rand.Int()%2 == 0 {
				return sayHi
			} else {
				return sayHolle
			}
		}
		rand.Seed(time.Now().Unix())
		genFunc()
 - 声明&调用参数类型为函数的函数 -> 高阶函数
	func printResult(pf func(...string), list ...string) {   // 定义接收函数类型作为参数的函数
		pf(list...)
	}
	func line(list ...string) {                              // 回调函数 作为参数被传递的函数
		fmt.Print("|")
		for _, e := range list {
			fmt.Print(e)
			fmt.Print("\t|")
		}
		fmt.Println()
	}
	names := []string{"aa", "bb", "cc"}
	printResult(line, names...)
 - 自定义函数类型&调用参数类型为自定义函数类型的函数&赋值变量并调用
	type addFunc func(x, y int) int                // 声明函数类型addFunc
	func asArg(fn addFunc) int {                   // 创建函数asArg使用声明函数类型addFunc作为参数
		return fn(2, 2) * 2
	}
	ret := asArg(func(x, y int) int {          // 调用函数asArg并使用匿名函数传参
		return x + y
	}

6、匿名函数与闭包
1).匿名函数
 - 不需要定义名字的函数叫做匿名函数，常用做帮助函数在局部代码块中使用或作为其他函数的参数
	- 声明匿名函数并直接执行
		func(args){
		//
		}(parameters)
	- 使用匿名函数作为printResult的参数
		printResult(func(list ...string) {
			for i, v := range list{
				fmt.Printf("%d: %s", i, v)
			}
		}, name...)
	- 声明自定义匿名函数类型
		type Callback func() error                      // 声明自定义匿名函数类型
		callback := map[string]Callback{}               // 赋值给map类型变量
		callback["add"] = func(int string) error {      // 初始化为具体的匿名函数
			fmt.Println("add")
			return nil
		}
		callback["add"]()
2).闭包
  - 闭包，匿名函数的一种，是指在函数内定义的匿名函数引用外部函数的变量(没有使用传参的方式)，只要匿名函数继续使用则外部函数赋值的变量不被自动销毁
	- 变量生成周期(内存中存在的时间)发生了变化 ，闭包不仅仅包含函数，还包含函数定义域和函数变量
		func addBase(base int) func(int) int {  // 定义闭包函数，返回一个匿名函数用于计算于base元素的和
			return func (num int) int {
				return base + num
			}
		}
		base2 := addBase(2)    // 使用闭包函数
		fmt.Println(base2(3))
		
7、错误处理
1).error 接口
 - error类型是个接口
	type error interface {
		Error() string
	}
 - 函数调用时判断返回值
	- if err != nil { ... }
		for _, v := range [...]int{0, 1, 2, 3} {           // 处理函数返回的错误
				if r, err := division(6, v); err != nil {
						fmt.Println(err)
				} else {
						fmt.Println(r)
				}
		}
 - Go语言通过 error 接口 实现错误处理的标准模式，通过使用函数返回值列表中的最后一个值返回错误信息，将错误的处理交由程序员主动进行处理
 - error接口的初始化方法:
	- 通过 errors 包的 New 方法创建 errors.New()
		func division(n1, n2 int) (int, error){            // 定义除法函数，若除数为0则使用error返回错误信息
			if n2 == 0 {
					return 0, errors.New("除数为0")
			}
			return n1/n2 , nil
		}
	- 通过通过fmt.Errorf方法创建方法创建
		err1, err2 := errors.New("error: 1"), fmt.Errorf("error: %d", 2)
		fmt.Printf("%T, %T, %v, %v", err1, err2, err1, err2)                // *errors.errorString, *errors.errorString, error: 1, error: 2
2).复杂的错误类型
 - 以os包举例，其提供了 LinkError、PathError、SyscallError 的错误类型
 - 上述error都是实现了error接口的错误类型
 - 可以用switch err.(type)判断类型
 - 例如:
	file, err := os.Stat("test.txt")
	if err != nil {
		switch err.(type) {
		case *os.PathError:
			log.Printf("PathError")
		case *os.LinkError:
			log.Printf("LinkError")
		case *os.SyscallError:
			log.Printf("SyscallError")
		default:
			log.Printf("unknow error")
		}
	} else {
		fmt.Println(file)
	}
3).自定义error
 - errors.New() 独立的error，基础的error
 - 自定义结构体 -> 原始错误的基础上再封自己的错误信息
 - 弊端 要定义很多 error结构体
 - 例如:
	type MyError struct {
		err error
		msg string // 自定义的error字符串
	}
	
	func (e *MyError) Error() string {
		return e.err.Error() + e.msg
	}
	err := errors.New("原始的错误 ")
	newErr := MyError{
		err: err,
		msg: "自定义的错误",
	}
	fmt.Println(newErr.Error())
4).Error Wrapping 错误嵌套   // golang 1.13
 - 目的: 扩展error信息
 - 使用 fmt.ErrorF(newErrorStr %w,e)
 - 长处 不需要像上面一样定义结构体
 - 例如: 
	e := errors.New("原始的错误")
	w := fmt.Errorf("Wrap了一个新的错误: %w", e)
5).defer
 - defer 用户声明函数，不论函数是否发生错误都在函数执行最后执行(return之前);若使用defer声明多个函数，则按照声明的顺序，先声明后执行(堆)常用来做资源释放，记录日志等工作
 - defer的本质是，当在某个函数中使用了defer关键字，则创建一个独立的defer栈帧，并将该defer语句压入栈中，同时将其使用的相关变量也拷贝到该栈帧中(值拷贝的);因为栈是LIFO方式，所以先压栈的后执行
	- 因为是独立的栈帧，所以即使调用者函数已经返回或报错，也一样能在它们之后进入defer栈帧去执行
6).panic与 recover 函数
 - panic
	- panic和recover函数用于处理运行时错误，当调用panic抛出错误，可以中断原有的控制流程，常用于不可修复性错误
	- 触发场景
		- 运行时错误会导致panic，比如数组越界、除0
		- 程序主动调用panic(error)
	- 执行顺序
		- 逆序执行当前goroutine的defer链(recover从这里介入)
		- 打印错误信息和调用堆栈
		- 调用exit(2)结束整个进程
 - recover
	- recover函数用于终止错误处理流程，仅在defer语句的函数中有效，用于截取错误处理流程 recover 只能捕获到最后一个错误。
		- 当未发生panic，且不存在panic，则recover函数得到的结果为nil
		- 当未发生panic，且存在panic，则recover函数得到的结果为panic传递的参数
		- recover只能获取到最后一次的panic的信息
			defer func() {
				fmt.Println(recover())
			}()
			var x, y *int
			sum(x, y)
			}
		- 在并发的场景中，需要在goroutine的启动函数里面专门编写recover，用于捕获当前goroutine的异常

六、包
1、定义
 - 包是函数和数据的集合，将有相关特性的函数和数据放在统一的文件目录进行管理，每个包都可以作为独立的单元维护并提供给其他项目进行使用
 - 声明所在包，包名告知编译器哪些是包的源代码用于编译库文件，其次包名用于限制包内成员对外的可见性，最后包名用于在包外对公开成员的访问
 - 在源文件中加上`package xxx`就可以声明xxx的包
 
2、成员可见性
 - Go 语言使用名称首字母大小写来判断对象(常量、变量、函数、类型、结构体、方法等)的访问权限，首字母大写标识包外可见(公开的)，否者仅包内可访问(内部的);

3、main 包与 main 函数
 - main包用于声明告知编译器 将包编译为二进制 可执行文件
 - main包中的 main 函数是程序的入口，无返回值，无参数

4、init 函数
 - init函数是初始化包使用，无返回值，无参数。建议每个包只定义一个； 
 - init函数在import包时自动被调用(const -->var -->init)。

5、标准包
 - Go提供了大量标准包，可查看 https://golang.google.cn/pkg/ &&  https://godoc.org 
	- go list std 查看所有标准包
	- go doc packagename 查看包的帮助信息
	- go doc packagename.element 查看包内成员 帮助信息

6、包的维护
 - 包的提供者 -> 打tag  -> git tag
 - 包的使用者 -> 改版本 -> go mod

7、关系说明
 - import 导入的是路径，而非包名
 - 包名和目录名不强制一致，但推荐一致
 - 在代码中引用包的成员变量或者函数时，使用的包名不是目录名
 - 在同一目录下，所有的源文件必须使用相同的包名
 	- Multiple packages in directory: pk2, pk3 
 - 文件名不限制，但不能有中文

8、设置 go mod 和 go proxy
 - 设置两个环境变量 // go env -w 
	- GO111MODULE=on
	- GOPROXY=https://goproxy.io,direct

9、创建git，发布到github
 - 项目目录下 go mod init github.com/ahwhy/myGolang
 - git init 
 - 添加 .gitignore 文件去掉一些和代码无关的文件/文件夹
 - git add . && git commit -m "Record me learning golang"
 - github上新建一个仓库
 - 推送到远程
	git remote add origin https://github.com/ahwhy/myGolang.git
	git branch -M main
	git push -u origin main
	
七、结构体
1、定义
 - 结构体是由一些列属性组成的复合数据类型，每个属性都具有名称、类型和值，结构体将属性组合在一起由程序进行处理
 - 结构体定义使用 struct 标识，需要指定其包含的属性(名和类型)，在定义结构体时可以为 结构体指定结构体名(命名结构体)，用于后续声明结构体变量使用
	type struct_variable_type struct {
		member definition
		...
	}
	
2、声明
 - 声明结构体变量只需要定义变量类型为结构体名，变量中的每个属性被初始化为对应类型的零值
	var struct_name struct_variable_type
 - 可以声明结构体指针变量，此时变量被初始化为 nil
	var struct_name *struct_variable_type
	
3、初始化
 - 使用结构体创建的变量叫做对应结构体的实例或者对象
 - 使用结构体零值初始化结构体值对象
	var struct_name struct_variable_type = struct_variable_type{}
 - 使用结构体字面量初始化结构体值对象
	var struct_name struct_variable_type = struct_variable_type{
		...
	}
	struct_name := struct_variable_type{a: 123, c: 789...}    //初始化部分
 - 使用 new 函数进行初始化结构体指针对象
	var struct_name *struct_variable_type = new(struct_variable_type)
 - 使用结构体字面量初始化结构体指针对象
	var struct_name *struct_variable_type = &struct_variable_type{
		...
	}
	struct_name := &struct_variable_type{a: 123, c: 789...}
	
4、属性的访问和修改 
 - 通过结构体对象名/结构体指针对象.属性名的方式来访问和修改对象的属性值
	struct_name.a
	
5、匿名结构体
 - 在定义变量时将类型指定为结构体的结构，此时叫匿名结构体
 - 匿名结构体常用于初始化一次结构体变量的场景，例如项目配置
	a := struct{
		a1 int
		a2 string
		...
	}{1, "aa"}
	
6、命名嵌入
1).定义 
 - 结构体命名嵌入是指结构体中的属性对应的类型也是结构体
	type Address struct{
		region string
		street string
		num    string
	}
	type User struct{
		name string
		tel  string
		addr Address
	}
2).声明&&初始化 
	var u1 User
	var a1 Address = Address{
		"浙江省杭州市",
		"转塘街道",
		"001",
	}
	var u2 User = User{"atlantis", "18100000000", a1}
	u3 := User{
		name: "lywq",
		tel: "18600000000",
		addr: Address{
			"安徽省芜湖市",
			"赤铸山西路",
			"001",
		},
	}
3).属性的访问和修改
	u3.addr.num = "002"
	
7、匿名嵌入
1).定义
 - 结构体匿名嵌入是指将已定义的结构体名直接声明在新的结构体中，从而实现对以后已有类型的扩展和修改
	type Employee struct {
		User
		salary float64
		title  string
	}		
2).声明和初始化
 - 在初始化匿名嵌入的结构体对象时需要遵循树状声明的结构，对于匿名嵌入的结构体可以使用结构体名来指定初始化参数
3).属性的访问和修改	
 - 在访问和修改嵌入结构体的属性值时，可以通过对象名.结构体名称.属性名的方式进行访问和修改，结构体名称可以省略（匿名成员有一个隐式的名称），因此不能嵌套两个相同名称的结构体
 - 当被嵌入结构体和嵌入结构体有相同的属性名时，在访问和修改嵌入结构体成员的属性值时不能省略结构体名称
 
8、指针类型嵌入
1).定义
 - 结构体嵌入(命名&匿名)类型也可以为结构体指针
	type PUser *struct{              // 命名嵌入结构体指针
		name string
		tel  string
		addr *Address
	}
	type PEmployee struct {         // 匿名嵌入结构体指针
		*PUser
		salary float64
		title  string
	}
2).声明&&初始化
	puser := PUser{"atlantis", "18100000000", &a1}
	pemployee := PEmployee{
		PUser:  &puser,
		salary: 25000,
		title:  "aa",
	}
3).属性的访问和修改	
 - 使用属性为指针类型底层共享数据结构，当底层数据发生变化，所有引用都会发生影响
 
9、空结构体
1).struct{}
 - struct{} 是一个无元素的结构体类型，通常在没有信息存储时使用
 - 优点是大小为0，不需要内存来存储struct {}类型的值
2).struct{}{}
 - struct{}{} 是一个复合字面量，它构造了一个 struct{} 类型的值，该值也是空
	var empty = struct{}{}
	
10、可见性
 - 结构体名首字母大写则包外可见(公开的)，小写则仅包内可访问(内部的)
 - 结构体属性名首字母大写包外可见(公开的)，小写则仅包内可访问(内部的)
	- 组合
		结构体名首字母大写，属性名大写: 结构体可在包外使用，且访问其大写的属性名
		结构体名首字母大写，属性名小写: 结构体可在包外使用，且不能访问其小写的属性名
		结构体名首字母小写，属性名大写: 结构体只能在包内使用，属性访问在结构体嵌入时由被嵌入结构体(外层)决定，被嵌入结构体名首字母大写时属性名包外可见，否者只能在包内使用
		结构体名首字母小写，属性名小写: 结构体只能在包内使用
		- 可以使用函数返回首字母小写的结构体，以达到控制访问的作用

11、深浅拷贝
1).定义&&区别
 - 深拷贝 copy的是数据本身
	- 复制的时候会创建一个新的对象
	- 指向完全不同的内存地址
	- 修改互不影响
 - 浅拷贝 复制的是对象的指针，
	- 新老对象指向同一块内存区域
	- a修改字段，b中的字段也一同被修改
	- 内存消耗是一致的
2).类型
 - 值类型的都是深拷贝
	int、float、bool、array、struct
 - 引用类型都是浅拷贝
	slice、map、function
	
12、结构体方法
 - 结构体的行为,需要用方法才能完成;
 - Go中的方法是作用在指定的数据类型上的(和指定的数据类型绑定)
 - 因此 ***自定义类型都可以有方法,不仅仅是结构体***; 
 - 方法的声明与调用:  
	type A struct {
		Name string  
	}  
	func (a A) say(){  
	fmt.Println(a.Name)   
	}
	- func(a A) say() {} 表示结构体A有一个方法,名称为say
	- (a A) 体现say 方法与A 类型绑定  

八、方法
1、定义
 - 方法是 为特定类型定义，只能由该类型调用的函数
 - 方法是 添加了接收者的函数，接收者必须是自定义的类型
	func (t Type) method(parameters) returns {
		...
	}
 - 示例
	type User struct {
		name string
	}
	// 为结构体User定义方法
	func (user User) Call(){   
		fmt.Println(user.name)
	}		
	func (user User) SetName(name string) {
		user.name = name
	}
	
2、调用
 - 调用方法通过自定义类型的 对象.方法名 进行调用，在调用过程中对象传递(赋值)给方法的接收者(值类型，拷贝)
	user := User{"aa"}  // 初始化结构体对象
	user.Call()         // 调用结构体对象Call方法
	user.SetName("bb")
	user.Call()         // 返回 aa，值传递
	
3、指针接收者
1).声明
	func (user *User) PSetName(name string) {
		user.name = name
	}
2).调用
 - 示例
	(&user).PSetName("bb")  // 调用结构体指针对象的PSetName
	
	user2 := &User{"cc"}
	(*user2).Call()
	- 当使用结构体指针对象调用值接收者的方法时，Go编译器会自动将指针对象"解引用"为值调用方法   // GO语法糖
	- 当使用结构体对象调用指针接收者的方法时，Go编译器会自动将值对象取引用为指针调用方法
 - 补充
	- 取引用和解引用发生在接收者中，对于函数方法的参数必须保持变量类型一一对应
	- 该使用值接收者还是指针接收者，取决于是否现需要修改原始结构体
		- 若不需要修改则使用值，若需要修改则使用指针
		- 若存在指针接收者，则所有方法使用指针接收者
	- 对于接收者为指针类型的方法，需要注意在运行时若接收者为nil时会发生错误
	
4、匿名嵌入
 - 若结构体匿名嵌入带有方法的结构体时，则在外部结构体可以调用嵌入结构体的方法，并且在调用时只有嵌入的字段会传递给嵌入结构体方法的接收者
 - 当被嵌入结构体与嵌入结构体具有相同名称的方法时，则使用 对象.方法名 调用被嵌入结构体方法
	- 若想要调用嵌入结构体方法，则使用 对象.嵌入结构体名.方法
	
5、方法值&&方法表达式
1).使用
 - 方法也可以赋值给变量，存储在数组、切片、映射中，也可作为参数传递给函数或作为函数
 - 返回值进行返回方法有两种，一种是使用 对象/对象指针 调用的(方法值)，另一种是使用 类型/类型指针 调用的(方法表达式)
2).方法值
 - 在方法值对象赋值时若方法接收者为值类型，则在赋值时会将值类型拷贝
 - 若调用为指针则自动 解引用拷贝
	method01 := user.Call
	method02 := user.SetName
	method03 := user2.Call
	method04 := user2.PSetName
2).方法表达式
 - 方法表达式在赋值时
	- 针对接收者为 值类型的方法   使用 类型名或类型指针 访问，go自动为指针变量生成隐式的指针类型接收者方法
		method05 := User.Call 
			method05(&user)
			method05(user2)
	- 针对接收者为 指针类型的方法 使用 类型指针         访问，同时在调用时需要根据参数传递对应的值对象或指针对象
		method06 := (*User).PSetName
			method06(&user, "bb")  // (*User).PSetName(&user, "bb")
			method06(user2, "bb")  // (*User).PSetName(user2, "bb")
3).自动生成指针接收者方法  // 具体见课件
 - 为何会根据接收者为值类型生成对应指针类型接收者方法，而不根据接收者为指针类型生成对应值接收者方法
	- 接收者为 值类型 的方法
		func (user User) SetName(name string) {
			user.name = name
		}
		/* 隐式
		- func (user *User) SetName(name string) { user.name = name }
		- (*user).SetName("bb")
		- 获取user地址的值，并拷贝调用SetId；只影响拷贝(*user)的值，并不影响调用者的值
		- 与(user User) SetName方法 行为一致
		- 使用 值和指针都不改变调用者，行为一致
		*/
	- 接收者为 指针类型 的方法
		func (user *User) PSetName(name string) {
			user.name = name
		}
		/* 隐式
		func (user User) PSetName(name string) { user.name = name }
		- (&user).SetName("bb")
		- user为值接收者，先拷贝值，再调用(&user).SetName只会影响接收者(user)的值，并不影响调用者的值
		- 与(user *User) PSetName方法 行为不一致
		- 使用 值 不改变调用者，使用指针改变调用者，行为不一致
		*/
 - 使用反射获取 User 对象和 *User 对象结构
	type User struct{
		Fields(1): 
			name string,
			
		Methods(2):
			func Call(objs.User) {},
			func SetName(objs.User, string) {},
	}
	*{
		type User struct{
			Fields(1): 
				name string,
				
			Methods(2):
				func Call(objs.User) {},
				func SetName(objs.User, string) {},
		}
		Methods(3)
				func Call(*objs.User) {},
				func SetName(*objs.User, string) {},
				func PSetName(*objs.User, string) {},
	}

九、接口
1、定义
 - 接口是自定义类型，是对是其他类型行为的抽象
 - 鸭子类型(duck typing)，动态类型的一种风格
	- 在这种风格中，一个对象有效的语义，不是由继承自特定的类或实现特定的接口，而是由"当前方法和属性的集合"决定
	- 一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟可以被称为鸭子
	- 在鸭子类型中，关注点在于对象的行为，能作什么；而不是关注对象所属的类型
 - 接口定义使用interface标识，声明了一系列的函数签名(函数名、函数参数、函数返回值)
 - 在定义接口时可以指定接口名称，在后续声明接口变量时使用
	type interfaceName interface {
		方法签名                        // 方法名，参数(数量，顺序，类型)，返回值(数量，顺序，类型)匹配
	}
	- 示例
		type Useritf interface{
			Call()
			SetName(name string)
			PSetName(name string)
		}	

2、声明
 - 声明接口变量只需要定义变量类型为接口名，此时变量值被初始化为nil，类型也为nil
	var name interfaceName 

3、赋值
1).使用
 - 接口无法实例化，即不能直接通过接口类型创建变量，只能由其他实现了接口的对象进行赋值
	var useritf Useritf = &User{"aa"}
	useritf.Call()
	useritf.SetName("bb")
	useritf.PSetName("bb")
2).类型对象
 - 当自定义类型实现了接口类型中声明的所有函数时，则该类型的对象可以赋值给接口变量，并使用接口变量调用实现的接口    // 由接口赋值的变量，无法调用结构体中的属性，也无法调用没有在接口中定义的其他方法，只能调用接口定义的方法行为
	- 方法接收者全为值类型的方法
	- 方法接收者全为指针类型的方法
	- 方法接收者既有值类型又有指针类型的方法
3).接口对象
 - 当接口(A)包含另外一个接口(B)中声明的所有函数时(A接口函数是B接口函数的父集，B是A的子集)，则接口(A)的对象也可以赋值给其子集的接口(B)变量
 - 若两个接口声明同样的函数签名，则者两个接口完全等价
 - 当类型和父集接口赋值给接口变量后，只能调用接口变量定义接口中声明的函数(方法)
 
4、类型断言&&查询
 - 使用
	- 当父集接口或者类型对象赋值给接口变量后，需要将接口变量重新转换为原来的类型，需要使用类型断言/查询
 - 断言
	- 语法: 接口变量.(Type) i.(T)
	- v, ok := i.(T)
 - 查询
	- 通过 switch-case + 接口变量.(type)查询变量类型，并选择对应的分支块
	
5、接口匿名嵌入
 - 接口之中也可以嵌入已存在的接口，从而实现接口的扩展
	type Useritf2 interface{
		Useritf
	}
	
6、匿名接口
 - 在定义变量时将类型指定为接口的函数签名的接口，此时叫匿名接口。匿名接口常用于初始化一次接口变量的场景
	// 通过匿名接口声明接口变量
	var closer interface {
		Close() error
	}
	closer.Close()
	
7、空接口
1).定义
 - 不包含任何函数签名的接口叫空接口，空接口声明的变量可以赋值为任何类型的变量任意接口
 - 语法: interface{}
2).声明
 - 直接声明空接口并使用
	type User struct {
		Name string
		Password string
	}
	
	var empty interface {}
	empty = 1
	empty = "aa"
	empty = User{"aa", "123456"}
	
	if u, ok := empty.(User); ok {
		fmt.Println(u.Name, u.Password)    // aa 123456
	}
	fmt.Printf("%T %v\n", empty, empty)    // main.User {aa 123456}
3).使用 场景
 - 常声明函数参数类型为 interface{} ，用于接收任意类型的变量
 - 示例
	func printType(vs ...interface{}) {
		for _, v := range vs {
			switch v.(type) {                           // 类型查询
			case nil:                                   // - 使用switch时，若符合多个case项，则匹配最近的一个，因此勿将default放在最上方
				fmt.Println("nil")                      // - 语法: 接口变量.(Type) 只能用在switch语句中，是类型查询的特定语法，无法直接 Println 打印
			case int:                                   // - 或者在switch语句中直接赋值 data := v.(type)
				fmt.Println("int")
			case bool:
				fmt.Println("bool")
			case string:
				fmt.Println("string")
			case [5]int:
				fmt.Println("[5]int")
			case []int:
				fmt.Println("[]int")
			case map[string]string:
				fmt.Println("map[string]string")
			default:
				fmt.Println("unknow")
			}
		}
	}
	
十、反射
1、定义
 - 反射是指在运行时动态的访问和修改任意类型对象的结构和成员
 - 为什么使用反射
	- 两个经典场景
		- 编写的一个函数，还不知道传给函数的类型具体是什么，可能是还没约定好，也可能是传入的类型很多
		- 希望通过用户的输入来决定调用按个函数(根据字符串调用方法)，动态执行函数
 - python中的反射 
	- 根据字符串执行函数
	- 根据字符串导入包
 - go中的反射
	- go是静态语言。反射就是go提供一种机制，在编译时不知道类型的情况下，可以做如下的事情:
		- 更新变量
		- 运行时查看值
		- 调用方法
		- 对他们的布局进行操作
	- 在go语言中提供reflect包提供反射的功能 ，每一个变量都有两个属性: 类型(Type)和值(Value)
		- reflect包提供 ValueOf和Typeof
		- reflect.ValueOf: 获取输入接口中数据的值，如果为空返回 0
		- reflect.Typeof: 获取输入接口中值的类型，如果为空返回 nil
		- Typeof传入所有类型，因为所有的类型都实现了空接口
		
2、Type
1).定义
 - reflect.Type 是一个接口类型，用于获取变量类型的信息，可通过 reflect.TypeOf 函数获取某个变量的类型信息
2).通用方法
 - Name(): 类型名
 - PkgPath(): 包路径
 - Kind(): 类型枚举值
 - String(): Type字符串
 - Comparable(): 是否可进行比较
 - ImplementsType(): 是否实现某接口
 - AssignableTo(Type): 是否可赋值给某类型
 - ConvertibleTo(Type): 是否可转换为某类型
 - NumMethod(): 方法个数
 - Method(int): 通过索引获取方法类型
		- Method结构体常用属性: 
			Name: 方法名
			Type: 函数类型
			Func: 方法值 Value)
 - MethodByName(string): 通过方法名字获取方法类型
3).特定类型方法
 - reflect.Int*, reflect.UInt*, reflect.Float*k, reflect.Complex*
	Bits(): 获取占用字节位数
 - reflact.Array
	Len(): 获取数组长度
	Elem(): 获取数据元素类型
 - reflect.Slice
	Elem(): 获取切片元素类型
 - reflect.Map
	Key(): 获取映射键类型
	Elem(): 获取映射值类型
 - reflect.Ptr
	Elem(): 获取指向值类型
 - reflect.Func
	IsVariadic(): 是否具有可变参数
	NumIn(): 参数个数
	In(int): 通过索引获取参数类型
	NumOut : 返回值 个数
	Out(int): 通过索引获取返回值类型
 - reflect.Struct
	NumField : 属性个数
	Field(int): 通过索引获取属性
		StructField 结构体常用属性
			Name: 属性名
			Anonymous: 是否为匿名
			Tag: 标签
				StructTag 常用方法:
					Get(string)
					Lookup(string)
	FieldByName(string): 通过属性名获取属性
	
3、Value
1).定义
 - reflect.Value 是一个结构体类型，用于获取变量值的信息，可通过 reflect.ValueOf 函数获取某个变量的值信息
2).创建方法
 - reflect.ValueOf
3).通用方法
 - Type(): 获取值类型
 - CanAddr(): 是否可获取地址
 - Addr(): 获取地址
 - CanInterface(): 是否可以获取接口的
 - InterfaceData():
 - Interface(): 将变量转换为 interface{}
 - CanSet(): 是否可更新
 - isValid(): 是否初始化为零值
 - Kind(): 获取值 类型枚举值
 - NumMethod(): 方法个数
 - Method(int): 通过索引获取方法值
 - MethodByName(string): 通过方法名字获取方法值
 - ConvertType(): 转换为对应类型的值
4).修改方法
 - Set/Set*: 设置变量值
5).调用方法
 - Call()
 - CallSlice()
6).特定类型方法
 - reflect.Int*, reflect.Uint*
	Int(): 获取对应类型值
	Unit(): 获取对应类型值
 - reflect.Float*
	Float(): 获取对应类型值
 - reflect.Complex*
	Complex 获取对应类型值
 - reflact.Array
	Len(): 获取数组长度
	Index(int): 根据索引获取元素
	Slice(int, int): 获取切片
	Slice3(int, int, int): 获取切片
 - reflect.Slice
	IsNil(): 判断是否为
	Len(): 获取元素数量
	Cap(): 获取容量
	Index(int): 根据索引获取元素
	Slice(int, int): 获取切片
	Slice3(int, int, int): 获取切片
 - reflect.Map
	IsNil(): 判断是否为
	Len(): 获取元素数量
	MapKeys(): 获取所有键
	MapIndex(Value): 根据键获取值
	MapRange 获取键值组成的可迭代对象
 - reflect.Ptr
	Elem(): 获取指向值类型(解引用)
 - reflect.Func
	IsVariadic(): 是否具有可变参数
	NumIn(): 参数个数
	In(int): 通过索引获取参数类型
	NumOut: 返回值个数
	Out(int): 通过索引获取返回值类型
 - reflect.Struct
	NumField : 属性个数
	Field(int): 通过索引获取属性
		StructField 结构体常用属性
			Name: 属性名
			Anonymous: 是否为匿名
			Tag标签:
				StructTag 常用方法:
					Get(string)
					Lookup(string)
	FieldByName(string): 通过属性名获取属性
	
4、应用
1).内置类型的测试
	var s interface{} = "abc"
	// TypeOf会返回模板的对象
	reflectType := reflect.TypeOf(s)
	reflectValue := reflect.ValueOf(s)
	log.Printf("[typeof:%v]", reflectType)
	log.Printf("[valueof:%v]", reflectValue)
2).自定义struct的反射
 - 生成的举例，对未知类型的进行 遍历 探测它的Field，抽象成一个函数
 - Go语言里面struct成员变量小写，在反射的时候直接panic
 - 结构体方法名小写不会panic，反射时也不会被查看到
 - 指针方法不能被反射查看到
	> 对于成员变量
		1. 先获取intereface的reflect.Type，然后遍历NumField
		2. 再通过reflect.Type的Field获取字段
		3. 最后通过Field的interface获取对应的value
	> 对于方法
		1. 先获取intereface的reflect.Type，然后遍历NumMethod
		2. 再分别通过reflect.Type的t.Method获取真实的方法
		3. 最后通过Name和Type获取方法的类型和值
 - 示例
	type Person struct {
		Name string
		Age  int
	}
	type Student struct {
		Person     // 匿名结构体嵌套
		StudentId  int
		SchoolName string
		IsBaoSong  bool // 是否保送
		Hobbies    []string
		// panic: reflect.Value.Interface: cannot return value obtained from unexported field or method
		// hobbies    []string
		Labels map[string]string
	}
	
	// func (s *Student) goHome() {
	// 		log.Printf("[回家][sid:%d]", s.StudentId)
	// }
	func (s *Student) GoHome() {
		log.Printf("[回家][sid:%d]", s.StudentId)
	}
	func (s Student) GotoSchool() {
		log.Printf("[去上学][sid:%d]", s.StudentId)
	}
	func (s Student) Baosong() {
		log.Printf("[竞赛保送][sid:%d]", s.StudentId)
	}
	func reflectProbeStruct(s interface{}) {
		// 获取目标对象
		t := reflect.TypeOf(s)
		log.Printf("[对象的类型名称: %s]", t.Name())
		// 获取目标对象的值类型
		v := reflect.ValueOf(s)
		// 遍历获取成员变量
		for i := 0; i < t.NumField(); i++ {
			// Field 代表对象的字段名
			key := t.Field(i)
			value := v.Field(i).Interface()
			//
			if key.Anonymous {
					log.Printf("[匿名字段][第:%d个字段][字段名:%s][字段的类型:%v][字段的值:%v]", i+1, key.Name, key.Type, value)
			} else {
					log.Printf("[命名字段][第:%d个字段][字段名:%s][字段的类型:%v][字段的值:%v]", i+1, key.Name, key.Type, value)
			}
		}
		// 打印方法
		for i := 0; i < t.NumMethod(); i++ {
			m := t.Method(i)
			log.Printf("[第:%d个方法][方法名称:%s][方法的类型:%v]", i+1, m.Name, m.Type)
		}
	}
    s := Student{
		Person:     Person{Name: "xiaoyi", Age: 9900},
		StudentId:  123,
		SchoolName: "五道口皇家男子职业技术学院",
		IsBaoSong:  true,
		Hobbies:    []string{"唱", "跳", "Rap"},
		//hobbies:    []string{"唱", "跳", "Rap"},
		Labels: map[string]string{"k1": "v1", "k2": "v2"},
    }
    p := Person{
		Name: "李逵",
		Age:  124,
    }
    reflectProbeStruct(s)
    reflectProbeStruct(p)
 - 执行结果
	2021/07/16 17:09:30 [对象的类型名称: Student]
	2021/07/16 17:09:30 [匿名字段][第:1个字段][字段名:Person][字段的类型:main.Person][字段的值:{xiaoyi 9900}]
	2021/07/16 17:09:30 [命名字段][第:2个字段][字段名:StudentId][字段的类型:int][字段的值:123]
	2021/07/16 17:09:30 [命名字段][第:3个字段][字段名:SchoolName][字段的类型:string][字段的值:五道口皇家男子职业技术学院]
	2021/07/16 17:09:30 [命名字段][第:4个字段][字段名:IsBaoSong][字段的类型:bool][字段的值:true]
	2021/07/16 17:09:30 [命名字段][第:5个字段][字段名:Hobbies][字段的类型:[]string][字段的值:[唱 跳 Rap]]
	2021/07/16 17:09:30 [命名字段][第:6个字段][字段名:Labels][字段的类型:map[string]string][字段的值:map[k1:v1 k2:v2]]
	2021/07/16 17:09:30 [第:1个方法][方法名称:Baosong][方法的类型:func(main.Student)]
	2021/07/16 17:09:30 [第:2个方法][方法名称:GotoSchool][方法的类型:func(main.Student)]
	2021/07/16 17:09:30 [对象的类型名称: Person]
	2021/07/16 17:09:30 [命名字段][第:1个字段][字段名:Name][字段的类型:string][字段的值:李逵]
	2021/07/16 17:09:30 [命名字段][第:2个字段][字段名:Age][字段的类型:int][字段的值:124]
3).反射修改值
 - 必须是指针类型
 - pointer.Elem().Setxxx()
 - 示例
    var num float64 = 3.14
    log.Printf("[num原始值:%f]", num)
    // 通过reflect.ValueOf获取num中的value
    // 必须是指针才可以修改值
    pointer := reflect.ValueOf(&num)
    newValue := pointer.Elem()
    // 赋值
    newValue.SetFloat(5.6)
    log.Printf("[num新值:%f]", num)

    pointer = reflect.ValueOf(num)
    // reflect: call of reflect.Value.Elem on float64 Value
    newValue = pointer.Elem()
4).反射调用方法
 - 示例
	type Person struct {
		Name   string
		Age    int
		Gender string
	}
	func (p Person) ReflectCallFuncWithArgs(name string, age int) {
		log.Printf("[调用的是带参数的方法][args.name:%s][args.age:%d][[p.name:%s][p.age:%d]",
			name,
			age,
			p.Name,
			p.Age,
		)
	}
	func (p Person) ReflectCallFuncWithNoArgs() {
		log.Printf("[调用的是不带参数的方法]")
	}
	p1 := Person{
		Name:   "小乙",
		Age:    18,
		Gender: "男",
	}
	// 1. 首先通过 reflect.ValueOf(p1)获取 得到反射值类型
	getValue := reflect.ValueOf(p1)
	// 2. 带参数的方法调用
	methodValue := getValue.MethodByName("ReflectCallFuncWithArgs")
	// 参数是reflect.Value的切片
	args := []reflect.Value{reflect.ValueOf("李逵"), reflect.ValueOf(30)}
	methodValue.Call(args)
	// 3. 不带参数的方法调用
	methodValue = getValue.MethodByName("ReflectCallFuncWithNoArgs")
	// 参数是reflect.Value的切片
	args = make([]reflect.Value, 0)
	methodValue.Call(args)
 - 过程说明
	1. 首先reflect.ValueOf(p1)获取 得到反射类型对象
	2. reflect.ValueOf.MethodByName ，需要传入准确的方法名称，MethodByName代表注册
		- 名称错误 会panic: reflect: call of reflect.Value.Call on zero Value
	3. []reflect.Value，这是最终需要调用方法的参数，无参数传空切片
5).结构体标签和反射
 - json的标签解析json
 - yaml的标签解析yaml
 - xorm gorm的标签 标识db字段
 - 自定义标签
 - 原理是t.Field.Tag.Lookup("标签名")
 - 混合的例子如下:
	type Person struct {
		Name string `json:"name" yaml:"yaml_name" mage:"name"`
		Age  int    `json:"age"  yaml:"yaml_age"  mage:"age"`
		City string `json:"-" yaml:"yaml_city" mage:"-"`
	}
	//json解析
	func jsonWork() {
		// 对象marshal成字符串
		p := Person{
			Name: "xiaoyi",
			Age:  18,
			City: "北京",
		}
		data, err := json.Marshal(p)
		if err != nil {
			log.Printf("[json.marshal.err][err:%v]", err)
			return
		}
		log.Printf("[person.marshal.res][res:%v]", string(data))
	
		// 从字符串解析成结构体
		p2Str := `
	{
		"name":"李逵",
		"age":28,
		"city":"山东"
	}
		var p2 Person
		err = json.Unmarshal([]byte(p2Str), &p2)
		if err != nil {
			log.Printf("[json.unmarshal.err][err:%v]", err)
			return
		}
		log.Printf("[person.unmarshal.res][res:%v]", p2)
	}
	// yaml读取文件
	func yamlWork() {
		filename := "a.yaml"
		content, err := ioutil.ReadFile(filename)
		if err != nil {
			log.Printf("[ioutil.ReadFile.err][err:%v]", err)
			return
		}
		p := &Person{}
		//err = yaml.Unmarshal(content, p)                         // func yaml.Unmarshal(in []byte, out interface{}) (err error)
		err = yaml.UnmarshalStrict(content, p)                     // func yaml.UnmarshalStrict(in []byte, out interface{}) (err error)
		if err != nil {
			log.Printf("[yaml.UnmarshalStrict.err][err:%v]", err)
			return
		}
		log.Printf("[yaml.UnmarshalStrict.res][res:%v]", p)
	}
	// 自定义标签
	func jiexizidingyibiaoqian(s interface{}) {
		// typeOf type类型
		r := reflect.TypeOf(s)
		value := reflect.ValueOf(s)
		for i := 0; i < r.NumField(); i++ {
			field := r.Field(i)
			key := field.Name
			if tag, ok := field.Tag.Lookup("mage"); ok {
				if tag == "-" {
					continue
				}
				log.Printf("[找到了mage标签][key:%v][value:%v][标签: mage=%s]",
					key,
					value.Field(i),
					tag,
				)
			}
		}
	}
	jsonWork()
	yamlWork()
	p := Person{
		Name: "xiaoyi",
		Age:  18,
		City: "北京",
	}
	jiexizidingyibiaoqian(p)

5、弊端
1).代码可读性变差
2).隐藏的错误躲过编译检查
 - Go语言为静态语言，编译器能发现类型的错误
 - 但是对于反射代码无能为力，可能运行很久才会panic
 - 反射调用方法的副作用，将 float64 参数传成 int
	panic: reflect: Call using float64 as type int
3).Go语言反射性能问题
 - 反射比正常的代码要慢1-2个数据量级，如果是追求性能的关键模块应减少反射
 - 示例
	type := reflect.value(obj)
	fieldValue := type_.FieldByName("xx")
	- 它是一个具体的值，不是一个可复用的对象
	- 每次取出的fieldValue类型是reflect.value
	- 每次反射都要malloc这个reflect.Value结构体，还有GC

十一、并发
1、定义
 - 并发编程开发，将一个过程按照 并行算法 拆分为多个可以独立执行的代码块，从而充分利用多核和多处理器提高系统吞吐率
	- Go采用的并发编程思想是CSP(Communicating Sequential Process，通讯顺序进程)，CSP有着精确的数学模型，其思想的核心是同步通讯
	- Goroutine 和 Channel 分别对应 CSP 中的实体和传递信息的媒介，Goroutine 之间会通过 Channel 传递数据
	- Channel遵循了先进先出的设计(FIFO)，具体规则如下
		- 先从 Channel 读取数据的 Goroutine 会先接收到数据
		- 先向 Channel 发送数据的 Goroutine 会得到先发送数据的权利
		- 因此可以把channel当作队列来使用，这也是Goroutine的通信方式
 - 顺序、并发与并行
	- CPU调度
		- CPU是支持分时调度的, 以时间片的形式来跑指令集
		- OS层面操作系统会轮换调度进程(运行中的程序)的一部分指令集给CPU运行
		- 硬件(CPU)是串行进行处理的，但是进程在OS层面是并发的
	- 顺序 指所有的指令都是以串行的方式执行，在相同的时刻有且仅有一个CPU在顺序执行程序的指令
	- 并发 指同一时间应对(dealing with)多件事情的能力，并发更关注的是程序的设计层面
		- 并发程序通信方式
			- 共享数据 -> 同步
				- 多个并发程序需要对同一个资源进行访问，则需要先申请资源的访问权限，同时再使用完成后释放资源的访问权
				- 当资源被其他程序已申请访问权后，程序应该等待访问权被释放并被申请到时进行访问操作
				- 同一时间资源只能被一个程序访问和操作
			- 管道 -> 异步
				- 数据处理者处理完数据后将数据放入缓冲区中，数据接收者从缓冲区中获取数据，处理者不用等待接收者是否准备好处理数据
	- 并行 指同一时间动手(doing)做多件事情的能力，并行更关注的是程序的运行层面
		- 任何语言的并行，到操作系统层面，都是内核线程的并行
		- 并行架构
			- 位级(bit-level)并行，比如寄存器从32位升级到64位
			- 指令级(instruction-level)并行，比如CPU指令流水线，乱序执行和猜测执行
			- 数据级(data-level)并行，比如CPU的SIMD指令以及GPU向量计算指令
			- 任务级(task-level)并行，比如多处理器架构以及分布式系统架构
		- 并发与并行
			- 并发是问题域中的概念，程序需要被设计成能够处理多个同时(或者几乎同时)发生的事情
			- 而并行则是方法域中的概念，通过将问题中的多个部分并行执行来加速解决问题

2、协程(goroutine)
 - 进程&&线程
	- 进程: 资源分配的基本单位
		- 独占资源: 地址空间、网络、内存地址、文件句柄
		- 进程是操作系统资源分配的最小单元
		- 所有的进程都是由操作系统的内核管理的
		- 每个进程之间是独立的，每一个进程都会有自己单独的内存空间以及上下文信息
		- 一个进程挂了不会影响其他进程的运行
		- 进程通过内核的ipc进行通信
		- 操作系统进程并发的模型
			- Master/Worker模型
			- 缺点 -> 每次创建进程的结构都需要复制一遍(Fork), 开销很大
	- 线程: CPU调度的基本单位
		- 独占资源: 栈、局部变量、程序计数器
		- 线程更加轻量级，创建和销毁的成本都很低
		- 线程之间通信以及共享内存非常方便
		- 多进程相比开销要小得多，但频繁的创建和销毁线程，仍然是不小的负担
		- 线程池
			- 创建一大批线程放入线程池当中，需要用的时候拿出来使用，用完了再放回
			- 优点: 复用线程，回收和领用代替了创建和销毁两个操作，大大提升了性能
			- 缺点: 资源的共享，由于线程之间资源共享更加频繁，所以在一些场景当中需要加上锁等设计，避免并发带来的数据紊乱
		- 每个系统级线程都会有一个固定大小的栈(一般默认可能是2MB)，这个栈主要用来保存函数递归调用时参数和局部变量
 - 协程
	- Goroutine 轻量级线程
		- 协程最大优势在于"轻量级"，可以轻松创建上百万个而不会导致系统资源衰竭
			- 线程和进程通常最多也不能超过1万
		- 创建Goroutine时为其分配4k堆栈，随着程序的执行自动增长删除
			- 当遇到深度递归导致当前栈空间不足时，Goroutine会根据需要动态地伸缩栈的大小(主流实现中栈的最大值可达到1GB)
			- 创建线程时必须指定堆栈且是固定的，通常以M为单位
		- goroutine是由Go runtime负责管理的，创建和销毁的消耗非常小，是用户级
			- Thread创建和销毀会有巨大的消耗，要和操作系统打交道，是内核级的
			- 通常解决的办法就是线程池
		- goroutines 切换只需保存三个寄存器，约200纳秒
			- 线程切换时需要保存各种寄存器状态，以便恢复，约1000-1500纳秒
		- go的协程是非抢占式的，由Go runtime主动交出控制权(对于开发者而言是抢占式的)
			- 线程在时间片用完后，由 CPU 中断任务强行将其调度走，这时就必须多保存很多信息
		- 从进程到线程再到协程，其实是一个不断共享，不断减少切换成本的过程
	- 协程的调度不是基于操作系统的而是基于用户空间的程序的
		- 一般由库或者程序的运行时提供调度
		- 根据具体函数只保存必要的寄存器，切换的代价要比系统线程低得多
	- Go语言中的MPG模型
		- 协程调度器，其将协程调度给操作系统的线程运行，由Go的Runtime实现
		- 调度
			- 名词定义
				- G(Goroutine)
					- Goroutine协程
					- 本质上是一种轻量级的线程
				- P(Processor)
					- 虚拟处理器
					- 代表M所需的上下文环境，是处理用户级代码逻辑的处理器
					- P的数量由环境变量中的GOMAXPROCS决定，默认情况下就是核数
					- 所有的P都在程序启动时创建，并保存在数组中，最多有GOMAXPROCS(可配置)个
				- M(Machine)
					- M对应一个内核线程(Thread)，并且这个对应关系是确定的
					- 线程想运行任务就得获取P，从P的本地队列获取G
					- P队列为空时，M也会尝试从全局队列拿一批G放到P的本地队列或从其他P的本地队列偷一半放到自己P的本地队列
					- M运行G，G执行之后，M会从P获取下一个G，不断重复下去
					- M进入系统调用时，会抛弃P，P被挂到其他M上，然后继续执行G队列
					- 系统调用返回后，相应的G进入全局的可运行队列(runqueue)中，P会周期性扫描全局的runqueue，使上面的G得到执行
				- 全局队列(Global Queue)
					- 存放等待运行的G
				- P的本地队列
					- 同全局队列类似，存放的也是等待运行的G，但存的数量有限，不超过 256 个
					- 新建G’时，G’优先加入到P的本地队列，如果队列满了，则会把本地队列中一半的G移动到全局队列
			- 流程
				- 创建Goroutine
				- 调度器将Goroutine调度入队(本地队列或者全局队列)
				- M获取G执行(绑定的P的队列, 全局队列, 其他P的队列)
				- M 循环的调度 G 执行
				- 如果M阻塞, 创建一个M或者从休眠的M队列中挑选一个M来服务于该P
				- G执行完成, 销毁G, 返回, 此时M空闲, 放入休眠中的M队列
		- 创建
			- go + 语句
			- main函数也是由一个协程来启动执行，这个协程称为主协程，其他协程叫工作协程
				- 主协程结束后工作协程也会随之销毁，即主协程不等待工作协程的结束
				- 无从属关系，只是两种协程类型
				- 使用 sync.WaitGroup(计数信号量)来维护执行协程执行状态
					func printChars(prefix string, group *sync.WaitGroup) {
						defer group.Done()                      // 通过信号量通知执行结束  等待信号量 -1
						for ch := 'A'; ch <= 'Z'; ch++ {
							fmt.Printf("%s:%c\n", prefix, ch)
							runtime.Gosched()                   // 让出CPU的调度 同time.Sleep(1 * time.Microsecond)
						}
					}
					group := &sync.WaitGroup{}                  // 定义信号量  启动协程之前 +1，协程结束时 -1
					n := 10
					group.Add(n)                                // 定义信号量 10
			
					for i := 0; i < n; i++ {                    // 创建协程
						go printChars(fmt.Sprintf("gochars%0d\n", i), group)
					}
					group.Wait()                                // 等待所有协程执行结束
					fmt.Println("over")
					- 通过 runtime包中的GoSched让协程主动让出CPU，或通过 time.Sleep让协程休眠从而让出CPU
		- 过程分析
			- Go语言中提供trace工具，用于分析程序的运行过程
				- 执行程序后，会生成trace.out文件，再运行go tool trace trace.out  
					// 创建trace文件
					f, err := os.Create("trace.out")
					if err != nil {
						panic(err)
					}
					defer f.Close()
					// 启动trace goroutine
					err = trace.Start(f)
					if err != nil {
						panic(err)
					}
					defer trace.Stop()
					// 启动goroutine
					asyncRun()
					wg.Wait()
			- go run或go build时添加-race参数检查资源竞争
		- 闭包陷阱
			- 闭包使用函数外变量，当协程执行时，外部变量已经发生变化，导致打印内容不正确，可使用在创建协程时通过函数传递参数(值拷贝)方式避免
				wg := &sync.WaitGroup{}
				wg.Add(10)
				for i := 0; i < 10; i++ {
						go func() {
								fmt.Println(i)        //  全部打印10
								wg.Done()
						}()
				}
				wg.Wait()
				fmt.Println("-----------------------")
				wg.Add(10)
				for i := 0; i < 10; i++ {
						go func(i int) {
								fmt.Println(i)        //  打印0 ~ 9
								wg.Done()
						}(i)
				}
				wg.Wait()

3、管道(channel) 
 - 定义
	- go语言中可以通过 chan 来定义管道
	- 通过操作符 <- 对管道进行读取和写入操作，通过管道维护协程状态
 - 本质
	- 一个 mutex 锁加上一个环状缓存、一个发送方队列和一个接收方队列
		- 管道底层是一个环形队列(先进先出)，send(插入) 和 recv(取走) 从同一个位置沿同一个方向顺序执行
		- sendx 表示最后一次插入的元素
		- recvx 表示最后一次取走元素的位置
			// src/runtime/chan.go
			type hchan struct {
				qcount   uint           // 队列中的所有数据数
				dataqsiz uint           // 环形队列的大小
				buf      unsafe.Pointer // 指向大小为 dataqsiz 的数组
				elemsize uint16         // 元素大小
				closed   uint32         // 是否关闭
				elemtype *_type         // 元素类型
				sendx    uint           // 发送索引
				recvx    uint           // 接收索引
				recvq    waitq          // recv 等待列表，即（ <-ch ）
				sendq    waitq          // send 等待列表，即（ ch<- ）
				lock mutex
			}
			type waitq struct { // 等待队列 sudog 双向队列
				first *sudog
				last  *sudog
			}
	- 发送过程包含三个步骤
		- 持有锁
		- 入队，拷贝要发送的数据
			- 找到是否有正在阻塞的接收方，是则直接发送
			- 找到是否有空余的缓存，是则存入
			- 阻塞直到被唤醒
		- 释放锁
	- 接收过程包含三个步骤
		- 上锁
		- 从缓存中出队，拷贝要接收的数据
			- 如果 Channel 已被关闭，且 Channel 没有数据，立刻返回
			- 如果存在正在阻塞的发送方，说明缓存已满，从缓存队头取一个数据，再复始一个阻塞的发送方
			- 否则，检查缓存，如果缓存中仍有数据，则从缓存中读取，读取过程会将队列中的数据拷贝一份到接收方的执行栈中
			- 没有能接受的数据，阻塞当前的接收方 Goroutine
		- 解锁
 - 声明
	- 管道是声明需要指定管道存放数据的类型，管道可以存放任何类型，但只建议用于存放值类型或者只包含值类型的结构体
	- 在管道声明后，会被初始化为 nil
		var channel chan int
		fmt.Printf("%T %v", channel, channel)  // chan int <nil>
 - 初始化
	- 使用 make函数初始化chan并分配内存
		- make(chan type)      不带 len参数创建无缓存区的管道
			- 无缓冲管道(unbuffered channel)特点
				- sender端向channel中send一个数据，然后阻塞，直到receiver端将数据receive
				- receiver端一直阻塞，直到sender端向channel发送了一个数据
				- 无缓冲管道是阻塞的，常用于同步通信模式
				- channel的死锁问题
					- Channel满了，就阻塞写；Channel空了，就阻塞读
					- 阻塞之后会交出cpu，去执行其他协程，希望其他协程能帮自己解除阻塞
					- 如果阻塞发生在main协程里，并且没有其他子协程可以执行，那就可以确定"希望永远等不来"，自已把自己杀掉，报一个fatal error: deadlock出来
					- 如果阻塞发生在子协程里，就不会发生死锁，因为至少main协程是一个值得等待的"希望"，会一直等下去
		- make(chan type, len) 使用 len参数创建指定缓冲区长度的管道
			- 带缓冲管道(buffered channel )
				- 会创建一个环形缓冲队列，队列满时send操作会阻塞或fatal error
				- buffered channel有两个属性: 容量(capacity)和长度(length)
					- capacity: 表示bufffered channel最多可以缓冲多少个数据
					- length: 表示buffered channel当前已缓冲多少个数据
				- 特点
					- 未满之前是非阻塞，异步模式
					- 填满之后是阻塞的，同步模式
		- 示例
			channel = make(chan int)           // %T chan int;    %v 0xc00001e0c0; len 0
			channel2 := make(chan string, 10)  // %T chan string; %v 0xc00005c180; len 0
 - 读取和写入
	- 通过操作符 <- 对管道进行读取和写入操作
		- send: 当ch出现在<-的左边 ch<-
		- recv: 当ch出现在<-的右边 <-ch
	- 当写入 无缓冲区管道 或 缓冲区管道 已满时，写入则会阻塞，直到管道中元素被其他协程读取
	- 当管道中无元素时，读取也会阻塞，直到管道被其他协程写入元素
		- 只有在协程中读取才会阻塞
		- 在main会直接报错 fatal error，非panic 不能通过recover捕获
			channel2 <- "1"
			fmt.Println(<-channel2)
	- channel <- struct{}{} 起通知作用
		- 空结构体变量的内存占用为0，因此struct{}类型的管道比bool类型的管道还要省内存
	- 只读&&只写
		- 在函数参数时声明管道
			- chan<- 表示管道只写
				- var wchannel chan<- int
				- func Write(cl chan<- rune) { }
			- <-chan 表示管道只读
				- var rchannel <-chan int
				- func Read(cl <-chan rune) { }
 - 关闭管道
	- 通过close函数关闭管道
		- 关闭channel后，send操作将导致painc
		- channel不能重复close，否则会panic
		- 关闭channel后，recv操作将返回对应类型的0值以及一个状态码false
		- 使用close()时，建议加上defer，只在sender端上显式使用close()关闭channel
	- 当读取到最后一个元素后可通过读取的第二个参数用于判断是否结束
		- e, ok := <-channel2
			- ok == true代表管道还没有关闭
			- 读取到最后一个元素返回false
 - for-range 遍历管道
	- 只有当管道关闭时，才能通过range遍历管道里的数据，否则会发生fatal error
		channel03 := make(chan int)
		go func() {
			for e := range channel03 {
					fmt.Println(e)
			}
			channel <- 0                     // 利用chan的特性进行阻塞
		}()
		go func() {
			for i := 0; i < 100; i++ {
					channel03 <- i
			}
			close(channel03)
		}()
		<-channel
 - Go语言time包实现了Tick函数，可以用于实现定时机制，Tick函数返回一个只读管道
	- func Tick(d Duration) <-chan Time
	- 示例
		for now := range time.Tick(3 * time.Second) {
			fmt.Println(time.Now())      // 每隔3s打印一次时间
		}

4、多路复用 -> select-case语句
1).定义
 - I/O模型
	- 操作系统级的I/O模型有
		- 阻塞I/O
		- 非阻塞I/O
		- 信号驱动I/O
		- 异步I/O
		- 多路复用I/O
			- select系统调用可同时监听1024个文件描述符的可读或可写状态
			- poll用链表存储文件描述符，摆脱了1024的上限
			- 各操作系统实现了自己的I/O多路复用函数，如epoll、evport和kqueue 等
			- go语言中多路复用函数以netpoll为前缀，针对不同的操作系统做了不同的封装，以达到最优的性能
				- 在编译go语言时会根据目标平台选择特定的分支进行编译
 - 文件描述符
	- Linux下，一切皆文件，包括普通文件、目录文件、字符设备文件(键盘、鼠标)、块设备文件(硬盘、光驱)、套接字socket等等
	- 文件描述符(File descriptor，FD)是访问文件资源的抽象句柄，读写文件都要通过它
	- 文件描述符就是个非负整数，每个进程默认都会打开3个文件描述符: 0标准输入、1标准输出、2标准错误
	- 由于内存限制，文件描述符是有上限的，可通过ulimit –n查看，文件描述符用完后应及时关闭
2).使用
 - 若需要同时对多个管道进行监听(写入或读取)，则可以使用select-case 语句
	- select的行为模式主要是对channel是否可读进行轮询
		- 如果所有的case语句块评估时都被阻塞，则阻塞直到某个语句块可以被处理
		- 如果多个case同时满足条件，则随机选择一个进行处理
			- 对于这一次的选择，其它的case都不会被阻塞，而是处理完被选中的case后进入下一轮select(如果select在循环中)或者结束select(如果select不在循环中或循环次数结束)
		- 如果存在default且其它case都不满足条件，则执行default
			- default必须要可执行而不能阻塞
	- select会被return、break关键字中断: return是退出整个函数，break是退出当前select
	- 当所有case都失败，则执行default语句
	- defalut语句是可选的，不允许fall through行为，但允许case语句块为空块
		select {
		case v, ok := <-channel:
			fmt.Println("channel", v, ok)
		case v, ok := <-channel02:
			fmt.Println("channel02", v, ok)
		default:
			fmt.Println("default")
		}
3).超时机制
 - 通过select-case 实现对执行操作超时的控制
	- select-case语句监听每个case语句中管道的读取，当某个case语句中管道读取成功则执行对应子语句
		var timeout chan int           
		go func() {
			time.Sleep(3 * time.Second)
			close(timeout)                         // 设定3s后关闭管道
		}()
		select {
		case v, ok := <-channel:
			fmt.Println("success:", r)
		case <-timeout:                            // 3s后关闭管道，读取timeout成功
			fmt.Println("timeout")
		}
 - Go语言中的标准库 "time" 实现了After函数，可以用于实现超时机制，After函数返回一个只读管道
	- func After(d Duration) <-chan Time
	- 示例
		select {
		case v, ok := <-channel:
			fmt.Println("success:", r)
		case <-time.After(3 * time.Second):    // 3s后关闭管道，读取管道成功
			fmt.Println("timeout")
		}
 - Go语言中的标准库 "context" 实现了timeout
	- context包常用函数
		func WithCancel(parent Context) (ctx Context, cancel CancelFunc)
		func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc)
			type CancelFunc func()    // CancelFunc会告诉操作放弃它的工作
			type Context interface{ 
				Deadline() (deadline time.Time, ok bool)
				Done() <-chan struct{}
				Err() error
				Value(key interface{}) interface{}
			}
	- 调用cancel()将关闭ctx.Done()对应的管道
		ctx, cancel := context.WithCancel(context.Background())
	- 调用cancel()或到达超时时间都将关闭ctx.Done()对应的管道
		ctx, cancel := context.WithTimeout(context.Background (),time.Microsecond*100)
		ctx.Done()   // 管道关闭后读操作将立即返回

5、共享数据
1).定义
 - 多个协程对同一个内存资源进行修改，未对资源进行同步限制，导致修改数据混乱
 - 临界区
	- 如果一部分程序会被并发访问或修改，为了避免并发访问导致的意向不到的结果，则这部分程序需要被保护起来
	- 如果多个线程同时访问或操作临界区，会造成访问错误
		- 此时需要限定临界区，在同一时间只能有1个线程持有，保证操作的顺序
			- 当临界区由一个线程持有的时候，其它线程如果想进入这个临界区，就会返回失败，或者是等待
			- 直到持有的线程退出临界区，这些等待线程中的某一个才有机会接着持有这个临界区
 - 锁
	- 用于解决隔离性的一种机制
	- 某个协程(线程)在访问某个资源时先锁住，防止其它协程的访问，等访问完毕解锁后其他协程再来加锁进行访问
	- Go语言中的锁
		- 互斥锁
			- 互斥锁加锁失败后，线程会释放 CPU，给其他线程
		- 自旋锁
			- 自旋锁加锁失败后，线程会忙等待，直到它拿到锁
		- 读写锁
2).sync包 -> 互斥锁&&读写锁
 - sync.Mutex 互斥锁，用于对资源加锁和释放锁提供对资源同步方式访问
	- 获取到锁的任务，阻塞其他任务; 意味着同一时间只有一个任务可以获取锁
		var HcMutex sync.Mutex
		HcMutex.Lock()    // 获取锁
		HcMutex.UnLock()  // 释放锁
 - sync.RWMutex 读写锁 
	- 写锁阻塞所有锁(所有读锁和写锁)，目的是修改时其他人不要读取，也不要修改
	- 读锁阻塞写锁，读锁可以同时施加多个，目的是不要让修改数据影响读取结果 
		- 同时多个读任务，可以施加多个读锁，阻塞写锁
		- 同时多个写任务，只可以施加一个写锁，阻塞其他所有锁，并且退化成互斥锁
		- 读写混合: 若有写锁，等待释放后能施加 读或写
		- 读写混合: 若有读锁，只能再施加读锁，阻塞写锁
			var rwMutex sync.RWMutex
			rwMutex.Lock      // 获取写入锁
			rwMutex.Unlock    // 释放写入锁 
			rwMutex.RLock     // 获取读取锁
			rwMutex.RUnlock   // 释放读取锁 	
 - sync.Map 
	- go 1.9引入的内置方法，并发线程安全的map
	- sync.Map 将key和value 按照interface{}存储
	- 查询出来后要类型断言 x.(int) x.(string)
	- 遍历使用Range() 方法，需要传入一个匿名函数作为参数，匿名函数的参数为k,v interface{}，每次调用匿名函数将结果返回
		m := sync.Map{}
		m.Store(k,v)  // 读
		m.Load(k)     // 写
		m.Delete(k)   // 删除
		m.Range(func(k,v interface{}bool{   // 遍历
			k := k.(string)
			v := v.(string)
			log.Printf("[找到了][%s=%d]", key, value)
			return true
		})
		m.LoadOrstore(k,v)   // 若没有key，则添加
		m.LoadAndDelete("key")  // 加载并删除
3).原子操作
 - 原子操作是指过程不能中断的操作
 - CAS函数(Compare And Swap)
	- sync/atomic包中提供了五类原子操作函数，其操作对象为整数型或整数指针
		- Add*: 增加/减少
		- Load*: 载入
		- Store*: 存储
		- Swap*: 更新
		- CompareAndSwap*: 比较第一个参数引用值是否与第二个参数值相同，若相同则将第一个参数值更新为第三个参数

6、CSP并发设计模式
 - Go语言是采用CSP编程思想的典范，它将CSP发挥到了极致，而Goroutine和Channel 就是这种思想的体现
 - Go语言的设计者 Rob Pike: Do not communicate by sharing memory; instead, share memory by communicating.
	- 即 不要使用共享内存通信，而是应该使用通信去共享内存
		- Thread1 -> Memory -> Thread2
		- Goroutine1 -> Channel -> Goroutine2
		- 使用发送消息来同步信息相比于直接使用共享内存和互斥锁是一种更高级的抽象，使用更高级的抽象能够为程序设计上提供更好的封装，让程序的逻辑更加清晰
		- 消息发送在解耦方面与共享内存相比也有一定优势，将线程的职责分成生产者和消费者，并通过消息传递的方式将它们解耦，不需要再依赖共享内存
 - 基于CSP的常见设计模式
	- Barrier 模式
		- barrier 屏障模式是一种屏障，用来阻塞直到聚合所有 goroutine 返回结果
		- 使用 channel 来实现
		- 使用场景
			- 多个网络请求并发，聚合结果
			- 粗粒度任务拆分并发执行，聚合结果
		- 示例 网页爬虫
			var (
				client = http.Client{
					Timeout: time.Duration(1 * time.Second),
				}
			)
			type SiteResp struct {
				Err    error
				Resp   string
				Status int
				Cost   int64
			}
			// 构造请求
			func doSiteRequest(out chan<- SiteResp, url string) {
				res := SiteResp{}
				startAt := time.Now()
				defer func() {
					res.Cost = time.Since(startAt).Milliseconds()
					out <- res
				}()
				resp, err := client.Get(url)
				if resp != nil {
					res.Status = resp.StatusCode
				}
				if err != nil {
					res.Err = err
					return
				}
				// 暂不处理结果
				_, err = ioutil.ReadAll(resp.Body)
				defer resp.Body.Close()
				if err != nil {
					res.Err = err
					return
				}
				// res.Resp = string(byt)
			}
			func mergeResponse(resp <-chan SiteResp, ret *[]SiteResp, down chan struct{}) {
				defer func() {
					down <- struct{}{}
				}()
				count := 0
				for v := range resp {
					*ret = append(*ret, v)
					count++
					// 填充完成,  返回
					if count == cap(*ret) {
						return
					}
				}
			}
			func BatchSiteReqeust() {
				endpoints := []string{
					"https://www.baidu.com",
					"https://segmentfault.com/",
					"https://blog.csdn.net/",
					"https://www.jd.com/",
				}
				// 一个endpoints返回一个结果, 缓冲可以确定
				respChan := make(chan SiteResp, len(endpoints))
				defer close(respChan)
				// 并行爬取
				for _, endpoints := range endpoints {
					go doSiteRequest(respChan, endpoints)
				}
				// 聚合结果, 返回结束事件, 避免轮询
				down := make(chan struct{})
				ret := make([]SiteResp, 0, len(endpoints))
				go mergeResponse(respChan, &ret, down)
			
				// 等待结束
				<-down
				// 打印爬取信息
				for _, v := range ret {
					fmt.Println(v)
				}
			}
	- Pipeline 模式
		- 利用多核的优势把一段粗粒度逻辑分解成多个 goroutine 执行
		- 示例
			- 第一个函数getRandNum()用于生成随机整数，并将生成的整数放进第一个channel ch1中
			- 第二个函数addRandNum()用于接收ch1中的数据(来自第一个函数)，将其输出，然后对接收的值加1后放进第二个channel ch2中
			- 第三个函数printRes接收ch2中的数据并将其输出
			- 如果将函数认为是Linux的命令，则类似于下面的命令行：ch1相当于第一个管道，ch2相当于第二个管道
				// getRandNum | addRandNum | printRes
				var wg sync.WaitGroup
				func getRandNum(out chan<- int) {
					defer wg.Done()
					var random int
					// 总共生成10个随机数
					for i := 0; i < 10; i++ {
						// 生成[0,30)之间的随机整数并放进channel out
						random = rand.Intn(30)
						out <- random
					}
					close(out)
				}
				func addRandNum(in <-chan int, out chan<- int) {
					defer wg.Done()
					for v := range in {
						// 输出从第一个channel中读取到的数据
						// 并将值+1后放进第二个channel中
						fmt.Println("before +1:", v)
						out <- (v + 1)
					}
					close(out)
				}
				func printRes(in <-chan int) {
					defer wg.Done()
					for v := range in {
						fmt.Println("after +1:", v)
					}
				}
				func PipelineMode() {
					wg.Add(3)
					// 创建两个channel
					ch1 := make(chan int)
					ch2 := make(chan int)
					// 3个goroutine并行
					go getRandNum(ch1)
					go addRandNum(ch1, ch2)
					go printRes(ch2)
					wg.Wait()
				}
	- Producer/Consumer 模式
		- 生产者消费者模型，该模式主要通过平衡生产线程和消费线程的工作能力来提高程序的整体处理数据的速度
			- 即生产者生产一些数据，然后放到成果队列中，同时消费者从成果队列中来取这些数据
			- 让生产、消费变成了异步的两个过程、
		- 示例
			// 生产者: 生成 factor 整数倍的序列
			func Producer(factor int, out chan<- int) {
				maxCount := 0
				for i := 0; ; i++ {
					out <- i * factor
					// 最多生成10个
					maxCount++
					if maxCount > 10 {
						break
					}
				}
			}
			// 消费者
			func Consumer(in <-chan int) {
				for v := range in {
					fmt.Println(v)
				}
			}
			func ProducerConsumerMode() {
				ch := make(chan int, 64) // 成果队列
				go Producer(3, ch) // 生成 3 的倍数的序列
				go Producer(5, ch) // 生成 5 的倍数的序列
				go Consumer(ch)    // 消费 生成的队列
				// 运行一定时间后退出
				time.Sleep(5 * time.Second)
			}
	- Pub/Sub 模式
		- pub/sub 也就是发布订阅模型
			- 在这个模型中，消息生产者成为发布者(publisher)，而消息消费者则成为订阅者(subscriber)，生产者和消费者是M:N的关系
			- 在传统生产者和消费者模型中，是将消息发送到一个队列中，而发布订阅模型则是将消息发布给一个主题
		- 示例
			type (
				subscriber chan interface{}         // 订阅者为一个管道
				topicFunc  func(v interface{}) bool // 订阅者处理消息的函数, bool是方便判断是否处理成功, 这里不作retry实现
			)
			// 发布者对象
			type Publisher struct {
				m           sync.RWMutex             // 读写锁
				buffer      int                      // 订阅队列的缓存大小
				timeout     time.Duration            // 发布超时时间
				subscribers map[subscriber]topicFunc // 订阅者信息
			}
			// 构建一个发布者对象, 可以设置发布超时时间和缓存队列的长度
			func NewPublisher(publishTimeout time.Duration, buffer int) *Publisher {
				return &Publisher{
					buffer:      buffer,
					timeout:     publishTimeout,
					subscribers: make(map[subscriber]topicFunc),
				}
			}
			// 添加一个新的订阅者，订阅全部主题
			func (p *Publisher) Subscribe() chan interface{} {
				return p.SubscribeTopic(nil)
			}
			// 添加一个新的订阅者，订阅过滤器筛选后的主题
			func (p *Publisher) SubscribeTopic(topic topicFunc) chan interface{} {
				ch := make(chan interface{}, p.buffer)
				p.m.Lock()
				p.subscribers[ch] = topic
				p.m.Unlock()
				return ch
			}
			// 退出订阅
			func (p *Publisher) Evict(sub chan interface{}) {
				p.m.Lock()
				defer p.m.Unlock()
			
				delete(p.subscribers, sub)
				close(sub)
			}
			// 发布一个主题
			func (p *Publisher) Publish(v interface{}) {
				p.m.RLock()
				defer p.m.RUnlock()
			
				var wg sync.WaitGroup
				for sub, topic := range p.subscribers {
					wg.Add(1)
					go p.sendTopic(sub, topic, v, &wg)
				}
				wg.Wait()
			}
			// 关闭发布者对象，同时关闭所有的订阅者管道。
			func (p *Publisher) Close() {
				p.m.Lock()
				defer p.m.Unlock()
			
				for sub := range p.subscribers {
					delete(p.subscribers, sub)
					close(sub)
				}
			}
			// 发送主题，可以容忍一定的超时
			func (p *Publisher) sendTopic(
				sub subscriber, topic topicFunc, v interface{}, wg *sync.WaitGroup,
			) {
				defer wg.Done()
				if topic != nil && !topic(v) {
					return
				}
			
				select {
				case sub <- v:
				case <-time.After(p.timeout):
				}
			}
			p := NewPublisher(100*time.Millisecond, 10)
			defer p.Close()
			// 订阅所有
			all := p.Subscribe()
			// 通过过滤订阅一部分信息
			golang := p.SubscribeTopic(func(v interface{}) bool {
				if s, ok := v.(string); ok {
					return strings.Contains(s, "golang")
				}
				return false
			})
			// 发布者 发布信息
			p.Publish("hello,   python!")
			p.Publish("godbybe, python!")
			p.Publish("hello,   golang!")
			// 订阅者查看消息
			go func() {
				for msg := range all {
					fmt.Println("all:", msg)
				}
			}()
			// 订阅者查看消息
			go func() {
				for msg := range golang {
					fmt.Println("golang:", msg)
				}
			}()
			// 运行一定时间后退出
			time.Sleep(3 * time.Second)
	- Workers Pool 模式
		- Go语言中 goroutine 已经足够轻量，甚至 net/http server 的处理方式也是 goroutine-per-connection 的，所以比起其他语言来说可能场景稍微少一些
			- 每个 goroutine 的初始内存消耗在 2~8kb，当有大批量任务的时候，需要起很多goroutine来处理，这会给系统代理很大的内存开销和GC压力，这个时候就可以考虑一下协程池
		- 示例 -> 参考Go的老版调度实现一个任务工作队列
			- 有(最多)4个worker，每个worker是一个goroutine，它们有worker ID
			- 每个worker都从一个队列中取出待执行的任务(Task)，并发执行
			- 队列容量为10，即最多只允许10个任务进行排队
			- 任务的执行方式: 随机睡眠0-1秒钟，并将任务标记为完成
				// worker的数量，即使用多少goroutine执行任务
				const workerNum = 4
				var wg sync.WaitGroup
				type Task struct {
					ID         int
					JobID      int
					Status     string
					CreateTime time.Time
				}
				// Run 执行任务
				func (t *Task) Run() {
					sleep := rand.Intn(1000)
					time.Sleep(time.Duration(sleep) * time.Millisecond)
					t.Status = "Completed"
				}
				// 从buffered channel中读取任务，并执行任务
				func worker(in <-chan *Task, workID int) {
					defer wg.Done()
					for v := range in {
						fmt.Printf("Worker%d: recv a request: TaskID:%d, JobID:%d\n", workID, v.ID, v.JobID)
						v.Run()
						fmt.Printf("Worker%d: Completed for TaskID:%d, JobID:%d\n", workID, v.ID, v.JobID)
					}
				}
				// 将待执行任务放进buffered channel，共15个任务
				func produceTask(out chan<- *Task) {
					for i := 1; i <= 15; i++ {
						// fmt.Println(i)
						out <- &Task{
							ID:         i,
							JobID:      100 + i,
							CreateTime: time.Now(),
						}
					}
				}
				func RunTaskWithPool() {
					wg.Add(workerNum)
					// 创建容量为10的bufferd channel
					taskQueue := make(chan *Task, 10)
					// 激活goroutine，执行任务
					for workID := 1; workID <= workerNum; workID++ {
						go worker(taskQueue, workID)
					}
					// 生成消息
					produceTask(taskQueue)
					// 5秒后 关闭管道，通知所有worker退出
					time.Sleep(5 * time.Second)
					close(taskQueue)
					wg.Wait()
				}

7、并发注意事项
 - 协程泄漏
	- 原因
		- 协程阻塞，未能如期结束
		- 协程阻塞最常见的原因都跟channel有关
		- 由于每个协程都要占用内存，所以协程泄漏也会导致内存泄漏
	- 排查
		- go run对应程序
			import (
				"net/http"
				_ "net/http/pprof"
			)
			func main() {
				go func() {
					if err := http.ListenAndServe("localhost:8080", nil); err != nil {
						panic(err)
					}
				}()
			}
		- 在浏览器访问 127.0.0.1:8080/debug/pprof/goroutine?debug=1 
		- 在终端执行   go tool pprof http://0.0.0.0:8080/debug/pprof/goroutine
			- 通过list查看函数每行代码产生了多少协程  list + 对应函数
		- 通过traces打印调用堆栈 traces
			- 在pprof中输入web命令 web
		- 终端执行 go tool pprof --http=:8081 /Users/zhangchaoyang/pprof/pprof.goroutine.001.pb.gz  
			- 在source view下可看到哪行代码生成的协程最多
 - 控制并发数
	- Goroutine会以一个很小的栈启动(可能是2KB或4KB)，但是系统和调度器的能力总是有上限的，在面对大规模的并发请求时(千万或者亿)是要考虑goroutine的销毁成本的
	- 方法
		- 使用goroutine pool控制gotourine数量
		- 做好系统的限流与上限控制
		- 管理好goroutine的退出，不让goroutine泄露
 - 并发的安全退出
	- 有时候需要通知goroutine停止它正在干的事情，特别是当它工作在错误的方向上的时候
		func worker(wg *sync.WaitGroup, cancel chan bool) {
			defer wg.Done()
			for {
				select {
				default:
					fmt.Println("hello")
					time.Sleep(100 * time.Millisecond)
				case <-cancel:
					return
				}
			}
		}
		func CancelWithDown() {
			cancel := make(chan bool)
			var wg sync.WaitGroup
			for i := 0; i < 10; i++ {
				wg.Add(1)
				go workerv2(&wg, cancel)
			}
			time.Sleep(time.Second)
			// 发送退出信号
			close(cancel)
			// 等待goroutine 安全退出
			wg.Wait()
		}
 - 使用回调函数替代channel
	- 回调函数就是一个被作为参数传递的函数
	- 示例
		- 使用回调函数进行网页爬虫
			type SiteRespCallBack func(SiteResp)
			// 构造请求
			func doSiteRequest(cb SiteRespCallBack, url string) {
				res := SiteResp{}
				startAt := time.Now()
				defer func() {
					res.Cost = time.Since(startAt).Milliseconds()
					cb(res)
					wg.Done()
				}()
			
				resp, err := client.Get(url)
				if resp != nil {
					res.Status = resp.StatusCode
				}
				if err != nil {
					res.Err = err
					return
				}
			
				// 暂不处理结果
				_, err = ioutil.ReadAll(resp.Body)
				defer resp.Body.Close()
				if err != nil {
					res.Err = err
					return
				}
			
				// res.Resp = string(byt)
			}
			// 主函数完成回调处理逻辑
			func CallBackMode() {
				endpoints := []string{
					"https://www.baidu.com",
					"https://segmentfault.com/",
					"https://blog.csdn.net/",
					"https://www.jd.com/",
				}
			
				// 一个endpoints返回一个结果, 缓冲可以确定
				respChan := make(chan SiteResp, len(endpoints))
				defer close(respChan)
			
				ret := make([]SiteResp, 0, len(endpoints))
				cb := func(resp SiteResp) {
					ret = append(ret, resp)
				}
			
				// 并行爬取
				for _, endpoints := range endpoints {
					wg.Add(1)
					go doSiteRequest(cb, endpoints)
				}
			
				// 等待结束
				wg.Wait()
			
				for _, v := range ret {
					fmt.Println(v)
				}
			}
 - 使用守护进程优雅退出
	- 守护协程
		- 独立于控制终端和用户请求的协程，它一直存在，周期性执行某种任务或等待处理某些发生的事件
		- 伴随着main协程的退出，守护协程也退出
	- kill命令不是杀死进程，它只是向进程发送信号kill –s pid，s的默认值是15
	- 常见的终止信号
		- SIGINT   2   Ctrl + c触发
		- SIGKILL  9   无条件结束程序，不能捕获、阻塞或忽略
		- SIGTERM  15  结束程序，可以捕获、阻塞或忽略
	- 示例
		type Context interface {
			Deadline() (deadline time.Time, ok bool)
			Done() <-chan struct{}
		}
		func WithCancel(parent Context) (ctx Context, cancel CancelFunc)
		- 当Context的deadline到期或调用了CancelFunc后，Context的Done()管道会关闭，该管道上关联的读操作会解除阻塞，然后执行协程退出前的清理工作
 - 协程管理组件 github.com/x-mod/routine
	- 封装了常规的业务逻辑: 初始化、收尾清理、工作协程、守护协程、监听term信号
	- 封装了常见的协程组织形式: 并行、串行、定时任务、超时控制、重试、profiling

8、sync包
 - sync包提供了同步原语
 - 常用结构体
	- sync.Mutex:  互斥锁
	- sync.RWMutex: 读写锁
	- sync.Cond: 条件等待
	- sync.Once: 单次执行      // 多个Once也只执行一个，可以确保在高并发的场景下有些事情只执行一次，比如加载配置文件、关闭管道等
	- sync.Map: 协程安全映射
	- sync.Pool: 对象池
	- sync.WaitGroup: 组等待
	
9、runtime包
 - runtime包提供了与 Go运行时系统交互的操作
 - 常用函数
	- runtime.Gosched(): 当前 goroutine 让出时间片
	- runtime.GOROOT(): 获取 Go 安装路径
	- runtime.NumCPU(): 获取可使用的逻辑 CPU 数量
	- runtime.GOMAXPROCS(1): 设置当前进程可使用的逻辑 CPU 数量
	- runtime.NumGoroutine(): 获取当前进程中 goroutine 的数量

十二、数据结构
1、类型
 - 逻辑结构
	- 集合结构(离散结构)
	- 线性结构
		- 线性表、栈、队列
	- 非线性结构
		- 树结构
		- 图结构或网状结构
 - 存储结构
	- 顺序存储结构
	- 链式存储结构
	- 索引结构
	- 哈希结构
	
2、链表
 - 单向链表
	- 在底层结构上，单向链表通过指针将一组零散的内存块串联在一起
		- 内存块称为链表的"结点"(Node)
		- 为了将所有的结点串起来，每个链表的结点除了存储数据之外，还需要记录链上的下一个结点的地址
		- 这个记录下个结点地址的指针叫作后继指针 next
	- 实现代码
		// 定义节点
		type Node struct {
			// 需要存储的数据
			Value interface{}
			// 下一跳
			Next  *Node
		}
		// 定义链表结构
		type List struct {
			head *Node
		}
		func NewIntNode(v int) *Node {
			return &Node{Value: v}
		}
		func NewIntList(headValue int) *List {
			// 链表的头
			head := &Node{Value: headValue}
			return &List{
				head: head,
			}
		}
		func (l *List) AddNode(n *Node) {
			// 需要找到尾节点
			next := l.head.Next
			for next.Next != nil {
				next = next.Next
			}
			// 修改为节点
			next.Next = n
		}
		func (l *List) Traverse(fn func(n *Node)) {
			n := l.head
			for n.Next != nil {
				fn(n)                // func(n *list.Node){ fmt.Println(n) }
				n = n.Next
			}
			fn(n)
			fmt.Println()
		}
		func (l *List) InsertAfter(after, current *Node) error {
			// after --> current --> afterNext
			// 保存after的下一跳 
			afterNext := after.Next
			// 插入current，修改指向
			after.Next = current
			current.Next = afterNext
			return nil
		}
	- 缺陷
		- 单向链表的情况下(单方向的)，要获取之前Node 需要遍历整个List
		- 以下功能并没有在单向链表中实现
			- 插入到指定Node的前面
			- 删除链表中的元素
		- 要高效解决这个问题，需要一个Previos指针，直接知道前一个Node的信息，而不是遍历
 - 双向链表
	- 支持两个方向，每个结点除一个后继指针 next 指向后面的结点外，还有一个前驱指针 prev 指向前面的结点
		- 双向链表相比于单向链表需要额外增加一个空间来保存前驱结点的地址
		- 存储同样多的数据，双向链表要比单链表占用更多的内存空间
		- 可以支持双向遍历
	- 实现代码
		// 重新定义节点
		type Node struct {
			// 需要存储的数据
			Value interface{}
			// 下一跳
			Next *Node
			// 上一跳
			Prev *Node
		}
		func (l *List) AddNode(n *Node) {
			// 需要找到尾节点
			next := l.head
			for next.Next != nil {
				next = next.Next
			}
			// 修改为节点
			next.Next = n
			n.Prev = next
		}
		func (l *List) Len() int {
			len := 0
			n := l.head
			if n.Prev != nil {
				return -1
			}
			for n.Next != nil {
				n = n.Next
				len++
			}
			return len + 1
		}
		func (l *List) Get(idx int) interface{} {
			index := 0
			n := l.head
			for n.Next != nil {
				n = n.Next
				index++
				if index == idx {
					return n.Value
				}
			}
			return nil
		}
		func (l *List) InsertAfter(after, current *Node) error {
			// after --> current --> afterNext
			// 保存after的下一跳 
			afterNext := after.Next
			// 插入current，修改指向
			after.Next = current
			current.Next = afterNext
			// after <-- current <-- after_next
			current.Prev = after
			afterNext.Prev = current
			return nil
		}
		func (l *List) InsertBefore(before, current *Node) error {
			// beforePrev <-- current <-- before
			// 保存before的上一跳 
			beforePrev := before.Prev
			// 插入current，修改指向
			before.Prev = current
			current.Prev = beforePrev
			// beforePrev --> current --> before
			current.Next = before
			beforePrev.Next = current
			return nil
		}
		func (l *List) Remove(current *Node) error {
			// prev --> current --> next
			prev := current.Prev
			next := current.Next
			prev.Next, next.Prev = next, prev
			return nil
		}
	- 应用场景
		- LRU缓存淘汰 -> LRU(Least Recently Used)最近最少使用
			- 实现思路: 缓存的key放到链表中，头部的元素表示最近刚使用
				- 如果命中缓存，从链表中找到对应的key，移到链表头部
				- 如果没命中缓存
					- 如果缓存容量没超，放入缓存，并把key放到链表头部
					- 如果超出缓存容量，删除链表尾部元素，再把key放到链表头部
						cache = make(map[int]string, 10)
						lst = list.New()
						func read(key int) string {
							if v, exists := cache[key]; exists { //命中缓存
								head := lst.Front()
								notFound := false
								for {
									if head == nil {
										notFound = true
										break
									}
									// fmt.Printf("%v\n", notFound)
									if head.Value.(int) == key { //从链表里找到相应的key
										lst.MoveToFront(head) //把key移到链表头部
										break
									} else {
										head = head.Next()
									}
								}
								if !notFound { //正常情况下不会发生这种情况
									lst.PushFront(key)
								}
								return v
							} else { //没有命中缓存
								v = readFromDisk(key) //从磁盘中读取数据
								cache[key] = v        //放入缓存
								lst.PushFront(key) //放入链表头部
								if len(cache) > CAP { //缓存已满
									tail := lst.Back()
									delete(cache, tail.Value.(int)) //从缓存是移除很久不使用的元素
									lst.Remove(tail)                //从链表中删除最后一个元素
									fmt.Printf("remove %d from cache\n", tail.Value.(int))
								}
								return v
							}
						}
 - 循环链表 -> ring
	- 将头节点的前趋指针指向尾节点，将尾节点的后驱指针指向头节点
	- 它的表现为一个环(Ring), 可以正向转和反向转
	- 实现代码
		// ChangeToRing 将链表头尾相连成环
		func (l *List) ChangeToRing() {
			// 需要找到尾节点
			next := l.head
			for next.Next != nil {
				next = next.Next
			}
			head, tail := l.head, next
			// head  -->  tail
			head.Prev = tail
			// head  <--  tail
			tail.Next = head
		}
		func (l *List) Traverse(fn func(n *Node)) {
			loopCount := 1
			n := l.head
			for n.Next != nil {
				// 最多循环5轮
				if loopCount > 5 {
					return
				}
				fn(n)
				n = n.Next
				if n == l.head {
					loopCount++
				}
			}
			fn(n)
			fmt.Println()
		}
	- 应用场景 -> 基于滑动窗口的统计
		- 最近100次接口调用的平均耗时、最近10笔订单的平均值、最近30个交易日股票的最高点
		- ring的容量即为滑动窗口的大小，把待观察变量按时间顺序不停地写入ring即可
 - 数组和链表的比较
	- 数组简单易用，在实现上使用的是连续的内存空间
		- 可以借助 CPU 的缓存机制，预读数组中的数据，所以访问效率更高
		- 而链表在内存中并不是连续存储，	对 CPU 缓存不友好，没办法有效预读
	- 数组的缺点是大小固定，一经声明就要占用整块连续内存空间
		- 如果声明的数组过大，系统可能没有足够的连续内存空间分配给它，导致"内存不足(out of memory)"
		- 如果声明的数组过小，则可能出现不够用的情况
		- 这时只能再申请一个更大的内存空间，把原数组拷贝进去，非常费时
		- 链表本身没有大小的限制，支持动态扩容，这也是其与数组最大的区别
	- 应用场景
		- 频繁的插入和删除用list
		- 频繁的遍历查询选slice
 - Go语言中的标准库
	- contianer/list  双向链表
	- container/ring  循环链表

3、栈
 - 栈stack，一种运算受限的线性表
	- 限定仅在表尾进行插入和删除操作的线性表
	- 这一端被称为栈顶，另一端被称为栈底，是被封死的
 - FILO(First In Last Out)，先进后出
 - Go语言中的栈
	- 2个核心方法
		- Push
		- Pop
	- 实现代码 -> 使用slice
		// 定义需要存入的元素对象
		// 这里Item是范型, 指代任意类型
		type Item interface{}
		
		type Stack struct {
			items []Item
		}
		// 构建函数
		func NewStack() *Stack {
			return &Stack{
				items: []Item{},
			}
		}
		// Push adds an Item to the top of the stack
		func (s *Stack) Push(item Item) {
			s.items = append(s.items, item)
		}
		// Pop removes an Item from the top of the stack
		func (s *Stack) Pop() Item {
			if s.IsEmpty() {
				return nil
			}
			item := s.items[len(s.items)-1]
			s.items = s.items[0 : len(s.items)-1]
			return item
		}
		// Len 栈的大小 
		func (s *Stack) Len() int {
			return len(s.items)
		}
		// IsEmpty 判断是否为空 
		func (s *Stack) IsEmpty() bool {
			return len(s.items) == 0
		}
		// Peek 获取栈顶元素的值 Peek
		func (s *Stack) Peek() Item {
			if s.IsEmpty() {
				return nil
			}
			return s.items[len(s.items)-1]
		}
		// Clear 清空栈 
		func (s *Stack) Clear() {
			s.items = []Item{}
		}
		// Search 查询某个值 距离栈顶的距离 
		func (s *Stack) Search(item Item) (pos int, err error) {
			for i := range s.items {
				if item == s.items[i] {
					return i, nil
				}
			}
			return 0, fmt.Errorf("item %s not found", item)
		}
		// 遍历栈 ForEach
		func (s *Stack) ForEach(fn func(Item)) {
			for i := range s.items {
				fn(i)
			}
		}
		// Sort 插入排序 把stack的元素从大到小进行排序 插入排序
		func (s *Stack) Sort() {
			// 准备一个辅助的stack, 另一个容器
			orderdStack := NewStack()
		
			for !s.IsEmpty() {
				// 然后开始的排序流程
				current := s.Pop()
		
				// orderdStack顶端大于current，应该将orderdStack顶端移至s，直到orderdStack顶端小于current
				for !orderdStack.IsEmpty() && current.(int) > orderdStack.Peek().(int) {
					s.Push(orderdStack.Pop())
				}
		
				// 此时 当前current 一定是 <= orderdStack顶端
				orderdStack.Push(current)
			}
		
			// 倒过来
			for !orderdStack.IsEmpty() {
				s.Push(orderdStack.Pop())
			}
		}

		
4、堆
 - 定义
	- 树(Tree)
		- 树是n(n>=0)个结点的有限集
			- n=0时称为空树
				- 在任意一颗非空树中，有且仅有一个特定的称为根(Root)的结点
			- 当n>1时，其余结点可分为m(m>0)个互不相交的有限集T1、T2、......、Tn
				- 其中每一个集合本身又是一棵树，并且称为根的子树
		- 二叉树
			- 在计算机科学中，二叉树是每个结点最多有两个子树的树结构
				- 通常子树被称作"左子树"(left subtree)和"右子树"(right subtree)
			- 相关名词
				- 根节点: 一棵树最上方的节点称为根节点
				- 父节点、子节点: 如果一个节点下面连接多个节点，那么该节点称为父节点，它下面的节点称为子节点
				- 叶子节点: 没有任何子节点的节点称为叶子节点
				- 兄弟节点: 具有相同父节点的节点互称为兄弟节点
				- 节点度: 节点拥有的子树数
				- 树的深度: 从根节点开始(其深度为0)自顶向下逐层累加的
				- 树的高度: 从叶子节点开始(其高度为0)自底向上逐层累加的
					- 对于树中相同深度的每个节点来说，它们的高度不一定相同，这取决于每个节点下面的叶子节点的深度
			- 满二叉树
				- 一棵深度为k且有2^k - 1个结点的二叉树称为满二叉树
					- 除最后一层无任何子节点外，每一层上的所有节点都有两个子节点，最后一层都是叶子节点
					- 特点
						- 一颗树深度为h，最大层数为k，深度与最大层数相同，k=h
						- 叶子节点数(最后一层)为2k−1
						- 第 i 层的节点数是: 2i−1
						- 总节点数是: 2k-1，且总节点数一定是奇数
			- 完全二叉树
				- 一棵深度为k的有n个结点的二叉树，对树中的结点按从上至下、从左到右的顺序进行编号，如果编号为i(1≤i≤n)的结点与满二叉树中编号为i的结点在二叉树中的位置相同
				- 每一层都是紧凑靠左排列的, 上层排满了, 才能排下层, 每层先排满左节点，才能排右节点
	- 堆(Heap)
		- 堆通常是一个可以被看做一棵完全二叉树的数组对象
			- 堆是一个完全二叉树
			- 堆中每一个节点的值都必须大于等于(或小于等于)其子树中每个节点的值
				- 大顶堆: 堆中每一个节点的值都必须大于等于其子树中每个节点的值
				- 小顶堆: 堆中每一个节点的值都必须小于等于其子树中每个节点的值
		- 应用场景
			- 堆排序(Heapsort)是指利用堆这种数据结构所设计的一种排序算法
				- 构建堆O(n)
				- 删除堆顶O(nlogn)
			- 求集合中最大的K个元素
				- 用集合的前K个元素构建小根堆
				- 逐一遍历集合的其他元素，如果比堆顶小直接丢弃
				- 否则替换掉堆顶，然后向下调整堆
			- 把超时的元素从缓存中删除
				- 按key的到期时间把key插入小根堆中
				- 周期扫描堆顶元素，如果它的到期时间早于当前时刻，则从堆和缓存中删除，然后向下调整堆
			- Go语言中的堆
				- 使用数组(array)/切片(slice)进行存储，
					- 由于数组(array)/切片(slice)的特性，在时间和空间上都很高效
					- 节点在数组中的位置index 和它的父节点以及子节点的索引之间有一个映射关系
						parent(i) = floor((i - 1)/2)
						left(i)   = 2i + 1
						right(i)  = 2i + 2 // right(i) 就是简单的 left(i) + 1，左右节点总是处于相邻的位置
						- 示例
							array:  10    7    2    5     1
							index:  0     1    2    3     4
							level:  1     2    2    3     3
						- 二叉数，指定层可以容纳的元素是固定的，2^level这个是二叉数的特性决定的
						- 把数组按照2^n次方，切分成多层，每层放对应的元素，就实现了一维到二维的映射
				- 添加/删除元素
					- 添加元素 -> 将新的元素插入到数组的尾部 -> 重新计算修复堆属性
					- 删除元素 -> 弹出堆顶的元素 -> 将数组的尾部元素，填补堆顶位置 -> 重新计算修复堆属性
				- 实现堆
					- 堆化(Init)
					- 往堆里添加元素(Push)
					- 弹出堆顶的元素(Pop)
				- Go语言中，由container/heap包实现
					- 需要实现五个方法，来定义一个堆
						type Interface interface {
							sort.Interface
							Push(x interface{}) // add x as element Len()
							Pop() interface{}   // remove and return element Len() - 1.
						}
						// sort.Interface
						type Interface interface {
							Less(i, j int) bool
							Len() int		
							Swap(i, j int)
						}
					- 官方示例 /usr/local/go/src/container/heap/example_intheap_test.go
						type IntHeap []int
						func (h IntHeap) Len() int              { return len(h) }
						// func (h IntHeap) Less(i, j int) bool { return h[i] > h[j] }       // 大顶堆 
						func (h IntHeap) Less(i, j int) bool    { return h[i] < h[j] }       // 小顶堆
						func (h IntHeap) Swap(i, j int)         { h[i], h[j] = h[j], h[i] }
						func (h *IntHeap) Push(x interface{})   { *h = append(*h, x.(int)) }	
						func (h *IntHeap) Pop() interface{} {
							old := *h
							n := len(old)
							x := old[n-1]
							*h = old[0 : n-1]
							return x
						}
						h := &IntHeap{2, 1, 5}
						heap.Init(h)
						heap.Push(h, 3)
						fmt.Printf("minimum: %d\n", (*h)[0])
						for h.Len() > 0 {
							fmt.Printf("%d ", heap.Pop(h))
						}
						// Output:
						// minimum: 1
						// 1 2 3 5
			- 高性能定时器
						
						
5、Trie树
 - trie树又叫字典权
 - term集合
	- 根节点是总入口，不存储字符
	- 对于英文，第个节点有26个子节点，子节点可以存到数组里
	- 中文由于汉字很多，用数组存子节点太浪费内存，可以用map存子节点
	- 从根节点到叶节点的完整路径是一个term
	- 从根节点到某个中间节点也可能是一个term，即一个term可能是另一个term的前缀
		type TrieNode struct {
			Word     rune                                                        // 当前节点存储的字符；byte只能表示英文字符，rune可以表示任意字符
			Children map[rune]*TrieNode                                          // 孩子节点，用一个map存储
			Term     string
		}
		type TrieTree struct {
			root *TrieNode
		}
		// add 把words[beginIndex:]插入到Trie树中
		func (node *TrieNode) add(words []rune, term string, beginIndex int) {
			if beginIndex >= len(words) {                                        // words已经遍历完了
				node.Term = term
				return
			}
			if node.Children == nil {
				node.Children = make(map[rune]*TrieNode)
			}
			word := words[beginIndex]                                            //把这个word放到node的子节点中
			if child, exists := node.Children[word]; !exists {
				newNode := &TrieNode{Word: word}
				node.Children[word] = newNode
				newNode.add(words, term, beginIndex+1)                           //递归
			} else {                                                             
				child.add(words, term, beginIndex+1)                             //递归
			}
		}
		// AddTerm 增加一个Term
		func (tree *TrieTree) AddTerm(term string) {
			if len(term) <= 1 {
				return
			}
			words := []rune(term)
			if tree.root == nil {
				tree.root = new(TrieNode)
			}
			tree.root.add(words, term, 0)
		}
		// walk words[0]就是当前节点上存储的字符，按照words的指引顺着树往下走，最终返回words最后一个字符对应的节点
		func (node *TrieNode) walk(words []rune, beginIndex int) *TrieNode {
			if beginIndex == len(words)-1 {
				return node
			}
			beginIndex += 1
			word := words[beginIndex]
			if child, exists := node.Children[word]; exists {
				return child.walk(words, beginIndex)
			} else {
				return nil
			}
		}
		// traverseTerms 遍历一个Node下面所有的Term，注意要传数组的指针，才能真正修改这个数组
		func (node *TrieNode) traverseTerms(terms *[]string) {
			if len(node.Term) > 0 {
				*terms = append(*terms, node.Term)
			}
			for _, child := range node.Children {
				child.traverseTerms(terms)
			}
		}
		// Retrieve 检索一个Term
		func (tree *TrieTree) Retrieve(prefix string) []string {
			if tree.root == nil || len(tree.root.Children) == 0 {
				return nil
			}
			words := []rune(prefix)
			firstWord := words[0]
			if child, exists := tree.root.Children[firstWord]; exists {
				end := child.walk(words, 0)
				if end == nil {
					return nil
				} else {
					terms := make([]string, 0, 100)
					end.traverseTerms(&terms)
					return terms
				}
			} else {
				return nil
			}
		}


十三、算法的评估
1、定义
 - 算法(Algorithm)是指用来操作数据、解决程序问题的一组方法
2、排序算法
	- 冒泡排序: 两个数比较大小，较大的数下沉，较小的数冒起来
		func BubbleSort(numbers []int) []int {
			for i := range numbers {
				for j := 0; j < len(numbers)-1; j++ {
					// 当前值 numbers[i], 后一个值是多少 numbers[j+1]
					fmt.Printf("数据: 当前: %d, 比对: %d\n", numbers[j], numbers[j+1])
		
					// 比较2个数, 交换顺序, 大数沉底, 小数冒出
					if numbers[j+1] < numbers[j] {
						numbers[j], numbers[j+1] = numbers[j+1], numbers[j]
					}
				}
				fmt.Printf("第%d趟: %v\n", i+1, numbers)
			}
			return numbers
		}
	- 选择排序: 在长度为N的无序数组中，第一次遍历n-1个数，找到最小的数值与第一个元素交换，第二次遍历n-2个数，找到最小的数值与第二个元素交换...第n-1次遍历，找到最小的数值与第n-1个元素交换，排序完成
		func SelectSort(numbers []int) []int {
			for i := range numbers {
				// 拿到第一个的数, 就是numbers[i], 比如 3
				fmt.Printf("第%d趟: %d\n", i+1, numbers[i])
		
				// 依次和后面相邻的数比较
				for j := i + 1; j < len(numbers); j++ {
					fmt.Printf("数据 -->  当前数据: %d, 比对数据: %d\n", numbers[i], numbers[j])
					if numbers[i] > numbers[j] {
						// 如果当前数 > 后面的数据, 则交换位置
						numbers[i], numbers[j] = numbers[j], numbers[i]
						fmt.Printf("交换 -->  当前数据: %d, 比对数据: %d\n", numbers[i], numbers[j])
					}
				}
		
				fmt.Println("结果: ", numbers)
			}
		
			fmt.Println("最终结果", numbers)
			return numbers
		}
	- 插入排序: 在要排序的一组数中，假定前n-1个数已经排好序，现在将第n个数插到前面的有序数列中，使得这n个数也是排好顺序的。如此反复循环，直到全部排号顺序
		func NewNumberStack(numbers []int) *Stack {
			items := make([]Item, 0, len(numbers))
			for i := range numbers {
				items = append(items, numbers[i])
			}
			return &Stack{
				items: items,
			}
		}
	- 快速排序: 快速排序是对冒泡排序的一种改进，也属于交换类的排序算法
	- 其他 
		- Go语言中内置排序 -> sort包，用于对象的排序, 参与排序的对象必须实现比较方法
			// Sort sorts data.
			// It makes one call to data.Len to determine n and O(n*log(n)) calls to
			// data.Less and data.Swap. The sort is not guaranteed to be stable.
			func Sort(data Interface) {
				...
			}
			// 实现一个IntSlice结构
			func NewIntSlice(numbers []int) IntSlice {
				return IntSlice(numbers)
			}
			
			type IntSlice []int
			
			func (s IntSlice) Len() int { return len(s) }
			
			func (s IntSlice) Swap(i, j int) { s[i], s[j] = s[j], s[i] }
			
			func (s IntSlice) Less(i, j int) bool { return s[i] < s[j] }
			// 比较函数
			func BuildInSort(numbers []int) []int {
				sort.Sort(IntSlice(numbers))
				return numbers
			}
			
3、算法评估的维度
 - 时间维度: 是指执行当前算法所消耗的时间，通常用「时间复杂度」来描述，可以估算出程序对处理器的使用程度
	- 时间频度: T(n) 通常，一个算法所花费的时间与代码语句执行的次数成正比，算法执行语句越多，消耗的时间也就越多
	- 渐进时间复杂度: 算法的时间复杂度函数为 T(n)=O(f(n))
	- 常见的算法时间复杂度由小到大依次为: Ο(1)＜Ο(log n)＜Ο(n)＜Ο(nlog n)＜Ο(n2)＜Ο(n3)＜…＜Ο(2^n)＜Ο(n!)
 - 空间维度: 是指执行当前算法需要占用多少内存空间，通常用「空间复杂度」来描述，可以估算出程序对计算机内存的使用程度
	- 空间复杂度 O(1)
		- 不开辟额外空间，程序运行时，使用的空间是个常数
		- 冒泡排序、选择排序
	- 空间复杂度 O(n)
		- 程序使用的额外空间, 这个额外空间的大小和数据规模成线性关系
		- Map 的空间负责度 就介于0(1) ~ O(n)，不会因为一个元素就开辟一个bucket


编程思想
一、函数式编程  // 面向过程编程
1、定义
 - 函数式编程，指忽略(通常是不允许)可变数据(以避免处理可改变的数据引发的边际效应)，忽略程序执行状态(不允许隐式的、隐藏的、不可见的状态)，通过函数作为入参，函数作为返回值的方式进行计算，通过不断的推进(迭代、递归)这种计算，从而从输入得到输出的编程范式

2、编程模式
1).算子
 - 算子是一个函数空间到函数空间上的映射O: X -> X, 简单说来就是进行某种"操作"、动作
 - 与之对应的，就是被操作的对象，称之为操作数，业务中往往将可变部分抽象成算子，方便业务逻辑的替换
 - Map - Reduce -> 解耦数据结构和算法最常见的方式
	- Map
		- 模式
			item1 --map func--> new1
			item2 --map func--> new2
			item3 --map func--> new3
		- 示例 -> 使用Map函数将所有的字符串转换成大写
		func MapStrToUpper(data []string, fn func(string) string) []string {
			newData := make([]string, 0, len(data))
			for _, v := range data {
				newData = append(newData, fn(v))
			}
			return newData
		}
		list := []string{"abc", "def", "fqp"}
		out := MapStrToUpper(list, func(item string) string {
			return strings.ToUpper(item)
		})
	- Filter
		- 模式
			item1 -- reduce func -->   x
			item2 -- reduce func -->   itme2
			item3 -- reduce func -->   x
		- 示例-> 使用Filter函数将带"f"字段的数据筛选出
			func ReduceFilter(data []string, fn func(string) bool) []string {
				newData := []string{}
				for _, v := range data {
					if fn(v) {
						newData = append(newData, v)
					}
				}
				return newData
			}
			list := []string{"abc", "def", "fqp", "abc"}
			out := ReduceFilter(list, func(s string) bool {
				return strings.Contains(s, "f")
			})
			fmt.Println(out)
	- Reduce
		- 模式
			item1 --|
			item2 --|--reduce func--> new item
			item3 --|
		- 示例-> 使用Reduce函数进行求和
			func ReduceSum(data []string, fn func(string) int) int {
				sum := 0
				for _, v := range data {
					sum += fn(v)
				}
				return sum
			}
			list := []string{"abc", "def", "fqp", "abc"}
			out1 := ReduceSum(list, func(s string) int {          // 统计字符数量
				return len(s)
			})
			out2 := ReduceSum(list, func(s string) int {          // 出现过ab的字符串数量
				if strings.Contains(s, "ab") {
					return 1
				}
				return 0
			})
	- Map/Reduce/Filter只是一种控制逻辑，真正的业务逻辑是在传给他们的数据和那个函数来定义的
		- 示例 -> 班级统计
			- 数据集合
				type Class struct {
					Name     string     // 班级名称
					Number   uint8      // 班级编号
					Students []*Student // 班级学员
				}
				
				type Student struct {
					Name     string   // 名称
					Number   uint16   // 学号
					Subjects []string // 数学  语文  英语
					Score    []int    //  88   99   77
				}
			- 统计有多少学生数学成绩大于80
			- 列出数学成绩不及格的同学
			- 统计所有同学的数学平均分
2).修饰器 decorator 
 - 把一些函数装配到另外一些函数上，可以让代码更为的简单，也可以让一些"小功能型"的代码复用性更高，让代码中的函数可以像乐高玩具那样自由地拼装
	func Hello(s string) {
		fmt.Printf("Hello, %s\n", s)
	}
	Hello("World")
 - 示例 -> HTTP中间件(net/http包)
	func hello(w http.ResponseWriter, r *http.Request) {
		fmt.Fprintf(w, "hello, http: %s", r.URL.Path)
	}
	http.ListenAndServe(":8848", http.HandlerFunc(hello))
	- 打印AccessLog
	- 为每个请求设置RequestID
	- 添加BasicAuth
 - 优化 -> 多个修饰器的管道 Pipeline
	- 在使用上，需要对函数一层层的套起来，特别在 decorator 比较多的话，影响代码的观感和阅读
	- 重构时，需要先写一个工具函数 -> 用来遍历并调用各个 decorator
		type HttpHandlerDecorator func(http.HandlerFunc) http.HandlerFunc
		func Handler(h http.HandlerFunc, decors ...HttpHandlerDecorator) http.HandlerFunc {
			// A, B, C, D, E
			// E(D(C(B(A))))
			for i := range decors {
				d := decors[len(decors)-1-i] // iterate in reverse
				h = d(h)
			}
			return h
		}
3).Functional Options
 - 不需要传入config参数, 函数签名优雅(缺省情况下 传nil很不优雅)
 - 不需要构建一个builder类来辅助
 - 示例
	func NewServer(addr string, port int, options ...func(*Server)) (*Server, error) {}
	func WithProtocol(s string) func(s *Server) {}
	server := &Server{Addr: addr, Port: port}
	option(server)

3、特点
 - 高阶函数: (函数的参数和返回值都可以是函数)
 - 闭包         // go函数编程的特点 -> 主要是闭包，简单来说，闭包就是在函数内使用外部自由变量。
	func Adder() func(int) int {
		// 自由变量
		num := 0
		return func(v int) int {
			num += v
			return num
		}
	}
	
	func callAdder() {
		addr := Adder()
		// plus 
		var res = 0
		for i := 0; i < 10; i++ {
			// 整个的累加过程作为变量放在循环的外部
			// 不断的对一个传入的数据进行加工
			res = addr(i)
			// 在进行plus的加工
			fmt.Printf("+.. %d=%d\n", i, res)
		}
	}
	
4、函数式编程的应用场景
 - 对于数据的长流程处理
 - 类似流水线，装配模式
 - 可以随时增删流程
	func fib() func() int {    // 斐波那契数列
		a, b := 0, 1
		return func() int {
			a, b = b, a+b
			return a
		}
	}
	
	func main() {
		fun := fib()
		fmt.Println(fun())
		fmt.Println(fun())
		fmt.Println(fun())
		fmt.Println(fun())
		fmt.Println(fun())
		fmt.Println(fun())
		fmt.Println(fun())
	}

二、面向对象编程  OOP，Object Oriented Programming，面向对象的编程
1、定义
 - 面向对象编程 -> Object Oriented Programming，简称OOP，一种程序设计思想
	- OOP把对象作为程序的基本单元，一个对象包含了数据和操作数据的函数
 - 面向过程与面向对象
	- 面向过程
		- 面向过程的程序设计把计算机程序视为一系列的命令集合，即一组函数的顺序执行
		- 为了简化程序设计，面向过程把函数继续切分为子函数，即把大块函数通过切割成小块函数来降低系统的复杂度
	- 面向对象
		- 面向对象的程序设计把计算机程序视为一组对象的集合
		- 而每个对象都可以接收其他对象发过来的消息，并处理这些消息，计算机程序的执行就是一系列消息在各个对象之间传递
 - 类和实例
	- 面向对象的设计思想是从自然界中来的，因为在自然界中，每一个实体都是对象(Object/Instance)，而这种实体的抽象类别就是类(Class)
		- 比如 车就是一个类, 而从你面前路过的福特汽车就是一个实例(Object)
	- 类(Class): 抽象的模板
	- 实例(Instance): 根据类创建出来的一个个具体的"对象"，每个对象都拥有相同的方法，但各自的数据可能不同
 - Go语言的面向对象
	- Go没有class关键字，但是可以把Go当做面向对象的方式来编程
	- Go没有类，可以把struct作为类看待
	- 面向对象中，不希望直接访问包，而是通过开发者定义的New函数构造一个对象返回
		- 各类New函数，又称工厂函数
	- 类的方法: 给struct绑定的方法
 - 三大特性: 封装、继承、多态
 - 五大基本原则
	- 单一职责原则SRP(Single Responsibility Principle)         类的功能要单一
	- 开放封闭原则OCP(Open－Close Principle)                   一个模块对于拓展是开放的，对于修改是封闭的
	- 里式替换原则LSP(the Liskov Substitution Principle LSP)   子类可以替换父类出现在父类能够出现的任何地方。
	- 依赖倒置原则DIP(the Dependency Inversion Principle DIP)  高层次的模块不应该依赖于低层次的模块，他们都应该依赖于抽象。抽象不应该依赖于具体实现，具体实现应该依赖于抽象。
	- 接口分离原则ISP(the Interface Segregation Principle ISP) 设计时采用多个与特定客户类有关的接口比采用一个通用的接口要好。
 - 补充
	结构体 -> 类
		构造函数 -> 创建类对象
	组合 -> 继承
		当前已有结构体 -> 扩展并使用
		匿名组合 -> 只匿名组合一个
	方法、接口 -> 多态
	
2、封装
 - 面向对象编程的一个重要特点就是数据封装
 - 隐藏对象的属性和实现细节，仅对外提供公共访问方式，将变化隔离，便于使用，提高复用性和安全性
 - 实例本身就拥有数据，要访问这些数据，没有必要从外面的函数去访问，可以直接在类的内部定义访问数据的函数
 - 即将属性隐藏，提供相关接口供调用者访问和修改

3、继承
 - 在OOP程序设计中，当定义一个class的时候，可以从某个现有的class继承，新的class称为子类(Subclass)，而被继承的class称为基类、父类或超类(Base class、Super class)
 - 提高代码复用性，继承是多态的前提
 - 通过结构体的匿名嵌套，继承对应的字段和方法

4、多态
 - 父类或接口定义的引用变量可以指向子类或具体实现类的实例对象，提高了程序的拓展性
 - 对象 在不同的条件下 有不同的行为
 - Go语言中通过接口做多态
	- 通过interface{} 定义方法的集合
	- 多态 体现为: 各个结构体对象要实现 接口 中定义的所有方法
	- 统一的函数调用入口，传入的接口
	- 各个结构体对象中 绑定的方法只能多不能少，并且在中接口定义
	- 方法的签名要一致: 参数类型、参数个数，方法名称，函数返回值要一致
	- 多态的灵魂就是有个承载的容器，先把所有实现了接口的对象加进来，每个实例都要顾及的地方，直接遍历 调用方法即可
	- 示例一
			// 体现多态
			// 告警通知的函数，根据不同的对象通知
			// 有共同的通知方法，每种对象自己实现
			type notifer interface {
					Init()                // 动作，定义的方法
					push()
					notify()
			}
			
			type user struct {
					name  string
					email string
			}
			type admin struct {
					name string
					age  int
			}
			
			func (u *user) Init()  {}
			func (u *admin) Init() {}
			
			func (u *user) push() {
					fmt.Printf("[普通用户][sendNotify to user %s]\n", u.name)
			}
			func (u *admin) push() {
					fmt.Printf("[管理员][sendNotify to user %s]\n", u.name)
			}
			
			func (u *user) notify() {
					fmt.Printf("[普通用户][sendNotify to user %s]\n", u.name)
			}
			func (u *admin) notify() {
					fmt.Printf("[管理员][sendNotify to user %s]\n", u.name)
			}
			
			func sendNotify(n notifer) {           // 入口 -> 多态的统一调用方法
					n.push()
					n.notify()
			}
			
			u1.push()
			a1.push()
			u1.notify()
			a1.notify()
	
			var n notifer
			n = &u1
			n.push()
			n.notify()
			n = &a1
			n.push()
			n.notify()

			ns := make([]notifer, 0)
			ns = append(ns, &u1, &a1)
			for _, n := range ns {
				sendNotify(n)
			}
	- 示例二
			/*
			1. 多个数据源
			2. QueryData方法做查数据
			3. PushData方法做写入数据
			*/
			type DataSource interface {
					PushData(data string)                 // 方法集合
					QueryData(name string) string
			}
			
			type redis struct {
					Name string
					Addr string
			}
			func (r *redis) PushData(data string) {
					log.Printf("[PushData][ds.name:%s][data:%s]", r.Name, data)
			}
			func (r *redis) QueryData(name string) string {
					log.Printf("[QueryData][ds.name:%s][data:%s]", r.Name, name)
					return name + "_redis"
			}
			
			type kafka struct {
					Name string
					Addr string
			}
			func (k *kafka) PushData(data string) {
					log.Printf("[PushData][ds.name:%s][data:%s]", k.Name, data)
			}
			func (k *kafka) QueryData(name string) string {
					log.Printf("[QueryData][ds.name:%s][data:%s]", k.Name, name)
					return name + "_kafka"
			}
			
			var Dm = make(map[string]DataSource)
	
			r := redis{
					Name: "redis",
					Addr: "1.1",
			}
			k := kafka{
					Name: "kafka",
					Addr: "2.2",
			}
			
			Dm["redis"] = &r                 // 注册数据源到承载的容器中
			Dm["kafka"] = &k
			for i := 0; i < 5; i++ {         // 推送数据
					key := fmt.Sprintf("key_%d", i)
					for _, ds := range Dm {
							ds.PushData(key)
					}
			}                                // 查询数据
			for i := 0; i < 5; i++ {
					key := fmt.Sprintf("key_%d", i)
					for _, ds := range Dm {
							res := ds.QueryData(key)
							log.Println(res)
					}
			}

三、测试驱动编程 -> DDD

工具和类型
一、日期与时间
1、介绍
 - Go 语言通过标准库 time 包处理日期和时间相关的问题
 
2、打印当前时间
 - 方法: time.Now()
	func numLen(n int64) int {
		return len(strconv.Itoa(int(n)))
	}
	now := time.Now()
	log.Printf("[当前时间对象为: %v]", now)
	log.Printf("[当前时间戳 秒级: %v][位数: %v]", now.Unix(), numLen(now.Unix()))
	log.Printf("[当前时间戳 毫秒级: %v][位数:%v]", now.UnixNano()/1e6, numLen(now.UnixNano()/1e6))
	log.Printf("[当前时间戳 纳秒级: %v][位数:%v]", now.UnixNano(), numLen(now.UnixNano()))
	log.Printf("[当前时间戳 纳秒小数部分: %v]", now.Nanosecond())
	log.Printf("[当前时间 %v %v %v %v %v %v",now.Year(), now.Month(), now.Day(), now.Hour(), now.Minute(), now.Second())
	log.Printf("[今天是 %d年中的第 %d天 星期 %d]", now.Year(), now.YearDay(), now.Weekday())
	zone, offset := now.Zone() && log.Printf("[直接获取时区  %v，和东utc时区差 %d 个小时]", zone, offset/3600)
	/* 输出
	2021/07/17 16:34:10 [当前时间对象为: 2021-07-17 16:34:10.2999431 +0800 CST m=+0.007295301]
	2021/07/17 16:34:10 [当前时间戳 秒级: 1626510850][位数:10]
	2021/07/17 16:34:10 [当前时间戳 毫秒级: 1626510850299][位数:13]
	2021/07/17 16:34:10 [当前时间戳 纳秒级: 1626510850299943100][位数:19]
	2021/07/17 16:34:10 [当前时间戳 纳秒小数部分: 299943100]
	2021/07/17 16:34:10 [当前时间 2021 June 17 16 34 10]
	2021/07/17 16:44:57 [今天是 2021年中的第 198天 星期]
	2021/07/17 16:44:57 [直接获取时区  CST，和东utc时区差 8 个小时]
	*/
	- 结论
		时间戳返回 int64
		10位数时间戳 是秒单位
		13位数时间戳 是毫秒单位  // 毫秒=纳秒/1e6 且prometheus默认查询就是毫秒
		19位数时间戳 是纳秒单位

2、Time结构体
 - Now()返回的是个Time结构体, 这也是Go内部表示时间的数据结构
	- Time 代表一个纳秒精度的时间点
	- 程序中应使用 Time 类型值来保存和传递时间，而不是指针。就是说，表示时间的变量和字段，应为 time.Time 类型，而不是 *time.Time. 类型
	- 时间点可以使用 Before、After 和 Equal 方法进行比较
		- Sub 方法让两个时间点相减，生成一个 Duration 类型值（代表时间段）
		- Add 方法给一个时间点加上一个时间段，生成一个新的 Time 类型时间点
	- Time 零值代表时间点 January 1, year 1, 00:00:00.000000000 UTC。因为本时间点一般不会出现在使用中，IsZero 方法提供了检验时间是否是显式初始化的一个简单途径
	- Time是有时区的s通过 == 比较 Time 时，Location 信息也会参与比较，因此 Time 不应该作为 map 的 key
 - now() 的具体实现在 runtime 包中, 由汇编实现的, 和平台有关, 一般在sys_{os_platform}_amd64.s 中

3、时间的格式化
 - 方法: time.Now().Format()
 - 格式
    模板   占位
	年  ->  2006
	月  ->  01
	日  ->  02
	时  ->  03(12h) / 15(24h)
	分  ->  04
	秒  ->  05
 - 示例
	format := "2006-01-02 15:04:05"   // string
	fmt.Printf("%T %#v\n", now.Format(format), now.Format(format))   // string "2021-06-20 20:08:45"
	
4、时间戳转换
 - Unix时间戳(Unix timestamp)定义为从1970年01月01日00时00分00秒(UTC)起至现在经过的总秒数
 - 不论东西南北、在地球的每一个角落都是相同
 - Go语言中的转换
 
				-> time.Unix()				-> Time.Format()
	时间戳(Timestamp)			time.Time  						日期格式
				<- Time.Unix()				<- time.ParselnLocation()
				
 - 要先将时间戳转成 time.Time 类型再格式化成日期格式
 	- Time -> Timestamp  方法: time.Now().Unix()
 		ts := time.Now().Unix()             // 时间戳
 		layout := "2006-01-02 15:04:05"
 	- Timestamp -> Time  方法: time.Unix()	
 		t := time.Unix(ts, 0)               // 构造时间对象
 		log.Printf(t.Format(layout))

5、时间的解析
 - 日期字符串转时间戳
 - time.Parse()               // func Parse(layout, value string) (Time, error)  返回转换后的时间格式和判断信息（err)     
	d1, err := time.Parse("2006-01-02 15:04:05", "2021-06-18 12:12:12")
 - time.ParseInLocation()     // func ParseInLocation(layout, value string, loc *Location) (Time, error) 可以指定时区
	tStr := "2021-07-17 16:52:59"
	layout := "2006-01-02 15:04:05"
	t1, _ := time.ParseInLocation(layout, tStr, time.Local)
	t2, _ := time.ParseInLocation(layout, tStr, time.UTC)
	log.Printf("[ %s的 CST时区的时间戳为 : %d]", tStr, t1.Unix())
	log.Printf("[ %s的 UTC时区的时间戳为 : %d]", tStr, t2.Unix())
	log.Printf("[UTC - CST =%d 小时]", (t2.Unix()-t1.Unix())/3600)
	
6、时间的比较   // Before、After 和 Equal
	now := time.Now()
	t1, _ := time.ParseDuration("1h")
	m1 := now.Add(t1)
	log.Printf("[a.after(b) a在b之后: %v]", m1.After(now))      // func After(d Duration) <-chan Time
	log.Printf("[a.Before(b) a在b之前: %v]", now.Before(m1))    // func (t Time) Before(u Time) bool
	log.Printf("[a.Equal(b) a=b: %v]", m1.Equal(now))           // func (t Time) Equal(u Time) bool
	
7、时间长度 Duration
 - time.Duration表示时间长度
	- 以纳秒为基数
	- 底层数据类型为int64
	- int64 类型的变量不能直接和time.Duration类型相乘，需要显示转换，常量除外
		- 不行:  num * time.Second
		- 可以:  time.Duration(num) * time.Second
		- 可以:  5 * time.Second

8、时长计算
1).Add
 - 让一个时间点加上一个时间段，生成一个新的 Time 类型时间点     // func (t Time) Add(d Duration) Time
	now := time.Now()
	after := now.Add(time.Hour * 24)
	fmt.Println(after)             // 2021/07/19 17:33:21 2021-07-20 17:33:21.12884928 +0800 CST m=+86400.000024700
2).Sub
 - 让两个时间点相减，生成一个 Duration 类型值（代表时间段）     // func (t Time) Sub(u Time) Duration
	fmt.Println(now.Sub(after))    // 2021/07/19 17:33:21 -24h0m0s
3).ParseDuration  时间差           // func ParseDuration(s string) (Duration, error)
	now := time.Now()
	var layout = "2006-01-02 15:04:05"
	func tTostr(t time.Time) string {
		return time.Unix(t.Unix(), 0).Format(layout)
	}

	t1, _ := time.ParseDuration("1h1m1s")  // 1小时1分1秒后
	m1 := now.Add(t1)
	log.Printf("[ 1小时1分1秒后时间为: %v]", tTostr(m1))
	
	t2, _ := time.ParseDuration("-1h1m1s") // 1小时1分1秒前
	m2 := now.Add(t2)
	log.Printf("[ 1小时1分1秒前时间为: %v]", tTostr(m2))

	sub1 := now.Sub(m2)                    // sub计算两个时间差
	log.Printf("[ 时间差: %s 、相差小时数: %v 、相差分钟数: %v ]", sub1.String(), sub1.Hours(), sub1.Minutes())

	t3, _ := time.ParseDuration("-3h3m3s")
	m3 := now.Add(t3)
	log.Printf("[time.since 当前时间与t的时间差: %v]", time.Since(m3))    // func Since(t Time) Duration
	log.Printf("[time.until t与当前时间的时间差: %v]", time.Until(m3))    // func Until(t Time) Duration
	m4 := now.AddDate(0, 0, 5)                                            // func (t Time) AddDate(years int, months int, days int) Time
	log.Printf("[5天后的时间: %v]", m4)
	
9、Sleep
 - 方法: time.Sleep()
	time.Sleep(time.Hour * 24)

10、定时器
 - 定时器是进程规划自己在未来某一时刻接获通知的一种机制。
 - 定时器有2种:
	- 单次触发: Timer
		- Timer数据结构
			type Timer struct {
				C <-chan Time
				r runtimeTimer
			}
			- C: 一个存放Time对象的Channel
			- runtimeTimer: 它定义在 sleep.go 文件中，必须和 runtime 包中 time.go 文件中的 timer 必须保持一致
		- 通过time.After实现同步等待
			m := time.NewTimer(5 * time.Second)
			fmt.Println(<-m.C)
			fmt.Println("exit")
		- 通过 time.AfterFunc中断循环，触发自定义函数
			stop := false
			time.AfterFunc(5*time.Second, func() {
				stop = true
			})
			for {
				if stop {
					fmt.Println("exit")
					break
				}
				time.Sleep(1 * time.Second)
			}
			- Timer的stop
				- 如果定时器还未触发，Stop 会将其移除，并返回 true；否则返回 false
				- 后续再对该 Timer 调用 Stop，直接返回 false
		- Timer的Reset
			- Reset 先调用 stopTimer 再调用 startTimer
			- 类似于废弃之前的定时器，重新启动一个定时器
			- 返回值和 Stop 一样
	- 周期性触发: Ticker
		- Ticker数据结构
			type Ticker struct {
				C <-chan Time // The channel on which the ticks are delivered.
				r runtimeTimer
			}
		- 通过time.NewTicker实现同步等待
			tk := time.NewTicker(2 * time.Second)
			count := 1
			for {
				if count > 2 {
					tk.Stop()
					break
				}
				fmt.Println(<-tk.C)
				count++
			}


二、日志处理
1、log包 
1).简介
 - 内置日志库
 - 提供基本的日志功能，但是没有提供日志级别
 - 比如: debug、warning、error
2).简单使用
 - 输出文件
	- 只要实现接口io.Writer的类型都可以作为文件的输出
	- 示例
		func logPrinta(baseStr string) {
			for i := 0; i < 10; i++ {
				msg := fmt.Sprintf("%s_%d", baseStr, i)
				log.Println(msg)
			}
		}
		// 创建文件对象
		file, err := os.OpenFile("my.log", os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0666)
		if err != nil {
			log.Fatal(err)       // func Fatal(v ...interface{}) - Fatal is equivalent to Print() followed by a call to os.Exit(1).
		}
		// 设置log输出到文件
		log.SetOutput(file)      // func SetOutput(w io.Writer)
		go logPrint("aaaaa")
		time.Sleep(1 * time.Hour)
 - 自定义的logger
	var (
		WarningLogger *log.Logger          // type Logger struct { // Has unexported fields. }
		InfoLogger    *log.Logger
		ErrorLogger   *log.Logger
	)
	
	func init() {
		file, err := os.OpenFile("c.log", os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0666)
		if err != nil {
				log.Fatal(err)
		}
		InfoLogger = log.New(file, "[INFO]", log.Ldate|log.Ltime|log.Lshortfile)
		WarningLogger = log.New(file, "[WARNING]", log.LstdFlags|log.Lshortfile)
		ErrorLogger = log.New(file, "[ERROR]", log.Ldate|log.Ltime|log.Lmicroseconds|log.Lshortfile)
	}
	
    // 创建文件对象
    InfoLogger.Println("[常见写法]启动服务....")
    InfoLogger.Println("[日期简写]正常上报....")
    WarningLogger.Println("[文件长路径]不严重的错误，报个warining....")
    ErrorLogger.Println("[微秒时间戳]严重的错误，报个error....")
 - log.flag && iota
	- itoa枚举依次是 1，2，4，8，16，32
		const (
			Ldate         = 1 << iota     // the date in the local time zone: 2009/01/23
			Ltime                         // the time in the local time zone: 01:23:23
			Lmicroseconds                 // microsecond resolution: 01:23:23.123123.  assumes Ltime.
			Llongfile                     // full file name and line number: /a/b/c/d.go:23
			Lshortfile                    // final file name element and line number: d.go:23. overrides Llongfile
			LUTC                          // if Ldate or Ltime is set, use UTC rather than the local time zone
			Lmsgprefix                    // move the "prefix" from the beginning of the line to before the message
			LstdFlags     = Ldate | Ltime // initial values for the standard logger
		)
	 - 因为可以组由组合标志位，后端进行 &判断
		- if l.flag&(Ldate|Ltime|Lmicroseconds) != 0 {}  //  代表原来的flag中有Ldate|Ltime|Lmicroseconds
	 - logger不能决定字段输出顺序。 a|b = b|a

2、github.com/sirupsen/logrus
 - 实现利用logrus包，通过钉钉机器人发送日志
	- 示例 -> logrus源码
		type Hook interface {
			Levels() []Level
			Fire(*Entry) error
		}
		func AddHook(hook Hook) {
			std.AddHook(hook)
		}
	- 首先定义相关结构体，然后实现Levels和Fire方法 --> 实现 Hook接口
		- Levels中定义日志等级
		- Fire中处理日志发送逻辑
			- 比如发送到redis、es、钉钉、logstash
	- 调用AddHook()，直接打印日志并发送

3、github.com/rifflock/lfshook
 - 结合logrotate github.com/lestrrat-go/file-rotatelogs
	- 保留4个文件 rotatelogs.WithRotationCount(4)
	- 切割时间 rotatelogs.WithRotationTime(1*time.Second)
	- 删除时间 rotatelogs.WithMaxAge(2*time.Minute)

三、非类型安全指针
1、类型安全指针
 - Go指针是有类型限制的: *T，在使用上相对于C指针有很多限制
 - 通过施加这些限制，Go指针保留了C指针的好处，同时也避免了C指针的危险性
	- Go指针不支持算术运算                              // a = &x  a++ a-- 是不合法的
	- 一个指针类型的值不能被随意转换为另一个指针类型    // 无法直接将指针a的值进行如下转换 *int64 --> *uint64
	- 一个指针类型的值不能被赋值给其它任意类型的指针值  // b = &y  无法进行 a = b

2、unsafe标准库包
1).非类型安全指针unsafe.Pointer
	// ArbitraryType is here for the purposes of documentation only and is not actually part of the unsafe package. It represents the type of an arbitrary Go expression.  
	// ArbitraryType在这里只是为了文档的目的，实际上并不是unsafe包的一部分。它代表任意的go表达式的类型。
	type ArbitraryType int
	// Pointer represents a pointer to an arbitrary type. There are four special operations
	// available for type Pointer that are not available for other types:   // Pointer适用于其他类型不可用的指针类型:
	//	- A pointer value of any type can be converted to a Pointer.        // 任何类型的指针值都可以转换为Pointer指针。
	//	- A Pointer can be converted to a pointer value of any type.        // Pointer指针可以转换为任何类型的指针值。
	//	- A uintptr can be converted to a Pointer.                          // uintptr可以转换为Pointer指针。
	//	- A Pointer can be converted to a uintptr.                          // Pointer指针可以转换为uintptr。
	// Pointer therefore allows a program to defeat the type system and read and write arbitrary memory. It should be used with extreme care.   // 指针因此允许程序击败类型系统并读写任意内存，应该特别小心被使用
	// ...
	type Pointer *ArbitraryType
2).build中内置类型 - uintptr 
    // uintptr is an integer type that is large enough to hold the bit pattern of any pointer.  // uintptr是一个整数类型，它足够大以容纳任何指针的位模式。
	type uintptr uintptr
3).通过Pointer类型可以实现: 
 - 任意类型的指针的值 <--> Pointer
 - uintptr <--> Pointer
4).unsafe标准库包只提供了三个函数
 - Alignof
	- 此函数用来取得一个值在内存中的地址对齐保证（address alignment guarantee）
	- 同一个类型的值做为结构体字段和非结构体字段时地址对齐保证可能是不同的，这和具体编译器的实现有关
	- 对于目前的标准编译器，同一个类型的值做为结构体字段和非结构体字段时的地址对齐保证总是相同的，gcc/go编译器对这两种情形是区别对待的。
	- 在大多数平台上，系统从某些特定的位置开始读数据非常快，而从其它位置读数据会慢很多
		- 为了使程序速度尽可能地快，选择牺牲很少的空间，用填充byte的方式保证所有数据的存储都从这些特定的位置开始，而达到较高的运行速度
		- 一个结构体n字节对齐，包含2个信息
			- 结构体的起始地址能被n整除
			- 结构体的总大小能被n整除
		- 当说到一个成员变量是n字节对齐的，说明该变量的起始地址能被n整除.
 - Offsetof
	- 此函数用来取得一个结构体值的某个字段的地址相对于此结构体值的地址的偏移
	- 在一个程序中，对于同一个结构体类型的不同值的对应相同字段，此函数的返回值总是相同的
 - Sizeof
	- 此函数用来取得一个值的尺寸(亦即此值的类型的尺寸)
	- 在一个程序中，对于同一个类型的不同值，此函数的返回值总是相同的
	- unsafe.Sizeof 即 在一片内存空间中，开辟的内存大小
		m := Man{Name: "John", Age: 20}
		fmt.Println(unsafe.Sizeof(m.Name), unsafe.Sizeof(m.Age), unsafe.Sizeof(m)) // 4*4=16 8 24
		fmt.Println(unsafe.Offsetof(m.Name)) // 0
		fmt.Println(unsafe.Offsetof(m.Age))  // 16
5).Pointer与uintptr的区别
	- Go是一门支持垃圾回收的语言
	- 当一个Go程序在运行中，Go运行时(runtime)将不时地检查哪些内存块将不再被程序中的任何仍在使用中的值所引用并且回收这些内存块
	- 指针在这一过程中扮演着重要的角色，值与值之间和内存块与值之间的引用关系是通过指针来表征的。	
		- Pointer 是安全的，表征的是一种关系，有引用就回不回收
		- uintptr 是一个整数，表征的是一个值(内存地址的数字表示)，这个值表示的内存地址的值 有可能已经被GC回收
6).uintptr地址被GC回收
 - 在运行时刻，一次新的垃圾回收过程可能在一个不确定的时间启动，并且此过程可能需要一段不确定的时长才能完成
 - 所以一个不再被使用的内存块的回收时间点是不确定的
	- 直接使用内存地址访问数组的其他元素
		a := [3]int64{1, 2, 3}
		fmt.Printf("%p\n", &a)
		
		s1 := unsafe.Sizeof(a[0])
		fmt.Printf("%d\n", s1)
		
		// 把 Pointer -> uintptr (一波操作) -> Pointer, 这一系列动作是一次性完成的
		p1 := (*int64)(unsafe.Pointer(uintptr(unsafe.Pointer(&a)) + s1))
		fmt.Println(*p1)	
	- 如果把 p1 该写成2条语句:
		// 把 Pointer -> uintptr (一波操作)
		p1Addr := uintptr(unsafe.Pointer(&a)) + s1 
		
		// uintptr -> Pointer, 此时 p1Addr 的地址有可能被回收
		p1 := (*int64)(unsafe.Pointer(p1Addr))
7).GoRuntime的小动作
 - 一个值的地址在程序运行中可能改变, 比如当一个协程的栈的大小改变时，开辟在此栈上的内存块需要移动，从而相应的值的地址将改变； 
 - 而这个变化当中Pointer会跟随变化，但是uintptr是值则不会
 
3、正确使用非类型安全指针  // 官方提供的6种使用模式 https://golang.google.cn/pkg/unsafe/#Pointer
1).指针类型转换
 - 将类型*T1的一个值转换为非类型安全指针值，然后将此非类型安全指针值转换为类型*T2
	- math标准库包中的Float64bits函数
		- 此函数将一个float64值转换为一个uint64值
		- 在此转换过程中，此float64值在内存中的每个位(bit)都保持不变
		*T1 --> Pointer --> *T2
			func Float64bits(f *float64) uint64 {
				return *(*uint64)(unsafe.Pointer(&f))
			}
	- 将一个int8的整数转换成一个string，同样内存中的值保持不变，实现zero copy转换
		func bInt8(n int8) string {
			fmt.Println(*(*uint8)(unsafe.Pointer(&n))) // 1111 1111
			return strconv.FormatUint(uint64(*(*uint8)(unsafe.Pointer(&n))), 2)
		}
2).获取地址
 - 模式: Pointer --> uintptr
	- 该模式运用不是很广泛
	- 一般将最终的转换结果uintptr值输出到日志中用来调试，但是有很多其它安全并且简洁的途径也可以实现此目的
		type T struct{ a int }
		var t1 T
		fmt.Printf("%p\n", &t1)                          // 0xc0000a0200
		println(&t1)                                     // 0xc0000a0200
		fmt.Printf("%x\n", uintptr(unsafe.Pointer(&t1))) // c0000a0200
3).直接操作内存地址
 - 将一个非类型安全指针转换为一个uintptr值，然后此uintptr值参与各种算术运算，再将算术运算的结果uintptr值转回非类型安全指针
 - 模式: Pointer --> uintptr --> (一波计算) --> uintptr --> Pointer
	- p = unsafe.Pointer(uintptr(p) + offset)
	- 直接通过指针访问结构体的属性，如: 直接通过地址访问y的第3个元素
		type T struct {
			x bool
			y [3]int16
		}
		
		const (
			N = unsafe.Offsetof(T{}.y)
			M = unsafe.Sizeof(T{}.y[0])
		)
		
		func TestUnsafePointer4() {
			t1 := T{y: [3]int16{123, 456, 789}}
			p := unsafe.Pointer(&t1)
			// "uintptr(p) + N + M + M"为t.y[2]的内存地址。
			ty2 := (*int16)(unsafe.Pointer(uintptr(p) + N + M + M))
			fmt.Println(*ty2) // 789
		}
4).系统调用
 - 将非类型安全指针值转换为uintptr值并传递给syscall.Syscall函数调用
 - 模式: Pointer --> uintptr --> syscall.Syscall 
	- syscall.Syscall(SYS_READ, uintptr(fd), uintptr(unsafe.Pointer(p)), uintptr(n))
		// INVALID: uintptr cannot be stored in variable
		// before implicit conversion back to Pointer during system call.
		u := uintptr(unsafe.Pointer(p))
		syscall.Syscall(SYS_READ, uintptr(fd), u, uintptr(n))
	- 为什么uintptr传给Syscall的时候是安全的？
		- 编译器针对每个syscall.Syscall函数调用中的每个被转换为uintptr类型的非类型安全指针实参添加了一些指令，从而保证此非类型安全指针所引用着的内存块在此调用返回之前不会被垃圾回收和移动
5).其他
 - 涉及反射
	- 将reflect.Value.Pointer或者reflect.Value.UnsafeAddr方法的uintptr返回值立即转换为非类型安全指针
	- 将一个reflect.SliceHeader或者reflect.StringHeader值的Data字段转换为非类型安全指针，以及其逆转换

4、总结与弊端
 - Go语言并不保证unsafe的兼容, 应该知晓当前的非类型安全机制规则和使用模式可能在以后的Go版本中完全失效, 几率很小
	- 在实践中，尽量保证能够将使用了非类型安全机制的代码轻松改为使用安全途径实现
 - 在某些情形，非类型安全机制可以帮助我们写出运行效率更高的代码
	- 但是使用非类型安全指针也使得我们可能轻易地写出一些重现几率非常低的微妙的bug、
	- 一个含有这样的bug的程序很可能在很长一段时间内都运行正常，但是突然变得不正常甚至崩溃
	- 这样的bug很难发现和调试

四、字符串
1、定义
 - 字符串是 Go 语言中的基础数据类型
 - 虽然字符串往往被看做一个整体，但是它实际上是一片连续的内存空间，也可以将它理解成一个由字符组成的数组  
 - 字符串中的每一个元素叫做"字符"
 
2、ASCII && Unicode && UTF-8 
 - ASCII编码
	- 英文和数字  // https://blog.csdn.net/qq_39397165/article/details/116178566
 - Unicode 
	- 称为Unicode字符集或者万国码, 就是将全球所有语言的字符通过编码
	- 所有语言都统一到一套编码，本质就是一张大的码表
	- 比如 104 -> h , 101 ->e (数字 -> 字符 的映射机制，兼容assicc码)，即利用一个数字即可表示一个字符
 - UTF-8
	- 目前互联网上使用最广泛的一种Unicode编码方式，最大特点就是可变长
	- 可以使用多个字节表示一个字符，根据字符的不同变换长度
	- UTF-8编码中，一个英文为一个字节，一个中文为三个字节
		- utf8使用变长字节编码, 来表示这些unicode码, 
		- 编码规则如下
			- 如果只有一个字节则其最高二进制位为0
			- 如果是多字节，其第一个字节从最高位开始，连续的二进制位值为1的个数决定了其编码的位数，其余各字节均以10开头
			- UTF-8最多可用到6个字节
				- 如表
					1字节 0xxxxxxx                       // ascii码 本来就是7个bit表示，所以完全兼容
					2字节 110xxxxx 10xxxxxx 
					3字节 1110xxxx 10xxxxxx 10xxxxxx 
					4字节 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 
					5字节 111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 
					6字节 1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx
	- Go语言
		- Go语言里的字符串的内部实现使用UTF8编码. 默认rune类型
		- GO中 uint8(byte类型 ascll) -> 0~127; int32(rune类型 utf-8) -> 128~0x10ffff;  
		- Ascll使用下标遍历，Unicode使用for range遍历
		- len只能表示字符串的 ASCII字符的个数或者字节长度
		- 使用 + 拼接多个字符串，支持换行
		
3、字符串的本质
 - 字符串是由字符组成的数组[]byte
 - 数组会占用一片连续的内存空间，而内存空间存储的字节共同组成了字符串
 - Go语言中的字符串只是一个只读的字节数组
	// runtime/string.go
	type stringStruct struct {
		str unsafe.Pointer
		len int
	}
	
4、Go标准库提供strings包，用于实现字符串的一些常规操作
1).字符串比较
 - Compare 函数
	- 用于比较两个字符串的大小，如果两个字符串相等，返回为 0
	- 如果 a 小于 b ，返回 -1 ，反之返回 1
	- 不推荐使用这个函数，直接使用 == != > < >= <= 等一系列运算符更加直观
		func Compare(a, b string) int 
 - EqualFold 函数
	- 计算 s 与 t 忽略字母大小写后是否相等
		func EqualFold(s, t string) bool
2).是否存在某个字符或子串
 - 子串 substr 在 s 中，返回 true
	func Contains(s, substr string) bool
 - chars 中任何一个 Unicode 代码点在 s 中，返回 true
	func ContainsAny(s, chars string) bool
 - Unicode 代码点 r 在 s 中，返回 true
	func ContainsRune(s string, r rune) bool
3).子串出现次数
 - 在 Go 中，查找子串出现次数即字符串模式匹配，Count 函数的签名
	func Count(s, sep string) int
4).字符切分
 - 通过分隔符来切割字符串
	func Split(s, sep string) []string { return genSplit(s, sep, 0, -1) }               // Split 会将 s 中的 sep 去掉，而 SplitAfter 会保留 sep
	func SplitAfter(s, sep string) []string { return genSplit(s, sep, len(sep), -1) }
	func SplitN(s, sep string, n int) []string { return genSplit(s, sep, 0, n) } 
	func SplitAfterN(s, sep string, n int) []string { return genSplit(s, sep, len(sep), n) }
	- 带 N 的方法可以通过最后一个参数 n 控制返回的结果中的 slice 中的元素个数
		- 当 n < 0 时，返回所有的子字符串
		- 当 n == 0 时，返回的结果是 nil
		- 当 n > 0 时，表示返回的 slice 中最多只有 n 个元素，其中，最后一个元素不会分割
	- 这4个函数都是通过genSplit内部函数来实现的, 通过 sep 进行分割，返回[]string
	- 如果 sep 为空，相当于分成一个个的 UTF-8 字符，如 Split("abc","")，得到的是[a b c]
	func genSplit(s, sep string, sepSave, n int) []string 
5).判断前缀和后缀
 - s 中是否以 prefix 开始
	func HasPrefix(s, prefix string) bool 
 - s 中是否以 suffix 结尾
	func HasSuffix(s, suffix string) bool 
6).字符串拼接
 - '+' 用加号连接
 - func fmt.Sprintf(format string, a ...interface{}) string
 - 将字符串数组(或 slice)连接起来可以通过 Join 实现
	func Join(a []string, sep string) string  
 - 拼接性能较高
	strings.Builder 
	bytes.Buffer
7).计算子串位置
 - 查询子串的开始Index的函数有:
	func Index(s, sep string) int                   // 在 s 中查找 sep 的第一次出现，返回第一次出现的索引
	func LastIndex(s, substr string) int
	func IndexByte(s string, c byte) int            // 在 s 中查找字节 c 的第一次出现，返回第一次出现的索引
	func IndexAny(s, chars string) int              // chars 中任何一个 Unicode 代码点在 s 中首次出现的位置
	func IndexRune(s string, r rune) int            // Unicode 代码点 r 在 s 中第一次出现的位置
 - 查找字串的结束Index的函数
	- 有三个对应的查找最后一次出现的位置
		func LastIndex(s, sep string) int
		func LastIndexByte(s string, c byte) int
		func LastIndexAny(s, chars string) int
		func LastIndexFunc(s string, f func(rune) bool) int
8).子串Count
	func Repeat(s string, count int) string
9).字符和子串替换
 - 字符替换: Map
	- 将 s 的每一个字符按照 mapping 的规则做映射替换，如果 mapping 返回值 <0 ，则舍弃该字符
	- 该方法只能对每一个字符做处理，但处理方式很灵活，可以方便的过滤，筛选汉字等
		func Map(mapping func(rune) rune, s string) string

 - 字符串替换
	- 用 new 替换 s 中的 old，一共替换 n 个
	- 如果 n < 0，则不限制替换次数，即全部替换
		func Replace(s, old, new string, n int) string
	- 该函数内部直接调用了函数 Replace(s, old, new , -1)
		func ReplaceAll(s, old, new string) string
10).大小写转换
 - ToLower，ToUpper 用于大小写转换
	func ToLower(s string) string
	func ToUpper(s string) string
 - ToLowerSpecial，ToUpperSpecial 可以转换特殊字符的大小写
	func ToLowerSpecial(c unicode.SpecialCase, s string) string 
	func ToUpperSpecial(c unicode.SpecialCase, s string) string
11).剔除子串
	func Trim(s string, cutset string) string              // 将 s 左侧和右侧中匹配 cutset 中的任一字符的字符去掉
	func TrimLeft(s string, cutset string) string          // 将 s 左侧的匹配 cutset 中的任一字符的字符去掉
	func TrimRight(s string, cutset string) string         // 将 s 右侧的匹配 cutset 中的任一字符的字符去掉
	func TrimPrefix(s, prefix string) string               // 如果 s 的前缀为 prefix 则返回去掉前缀后的 string , 否则 s 没有变化。
	func TrimSuffix(s, suffix string) string               // 如果 s 的后缀为 suffix 则返回去掉后缀后的 string , 否则 s 没有变化。
	func TrimSpace(s string) string                        // 将 s 左侧和右侧的间隔符去掉。常见间隔符包括: '\t', '\n', '\v', '\f', '\r', ' ', U+0085 (NEL)
	func TrimFunc(s string, f func(rune) bool) string      // 将 s 左侧和右侧的匹配 f 的字符去掉
	func TrimLeftFunc(s string, f func(rune) bool) string  // 将 s 左侧的匹配 f 的字符去掉
	func TrimRightFunc(s string, f func(rune) bool) string // 将 s 右侧的匹配 f 的字符去掉

5、其他
 - Go语言源代码始终为UTF-8
 - Go语言的字符串可以包含任意字节，字符底层是一个只读的byte数组。
 - Go语言中字符串可以进行循环，使用下表循环获取的acsii字符，使用range循环获取的unicode字符。
 - Go语言中提供了rune类型用来区分字符值和整数值，一个值代表的就是一个Unicode字符。
 - Go语言中获取字符串的字节长度使用len()函数，获取字符串的字符个数使用utf8.RuneCountInString函数或者转换为rune切片求其长度，这两种方法都可以达到预期结果。

五、密码学&&Go语言的加解密
1、定义
 - 密码学的目的
	- 保密性、数据完整性、身份验证
 - 密码学的应用
	- 保密通信、数字签名、秘密共享、认证功能、密钥管理
 - 加密算法种类
	- 散列算法、对称加密算法、非对称加密算法、秘钥交换算法
	
2、Hash 散列算法
 - 散列是信息的提炼
	- 通常其输入可以是任意长度，长度往往要比信息小得多，且为一个固定长度
	- 加密性强的散列一定是不可逆的，即通过散列结果，无法推出任何部分的原始信息 -> 单向性
	- 任何输入信息的变化，哪怕仅一位，都将导致散列结果的明显变化，这称之为雪崩效应
	- 散列还应该是防冲突的，即找不出具有相同散列结果的两条信息 -> 唯一性
	- 具有这些特性的散列结果就可以用于验证信息是否被修改，常用于保证数据完整性
 - 单向散列函数一般用于产生消息摘要，密钥加密等
	- MD5(Message Digest Algorithm 5  信息-摘要算法5): 是RSA数据安全公司开发的一种单向散列算法  // 已被破解
		- Go语言中，由crypto/md5包实现
	- SHA(Secure Hash Algorithm  安全散列算法): 可以对任意长度的数据运算生成一个160位的数值
		- SHA-1是一种数据加密算法，防伪装，防窜扰，保证信息的合法性和完整性
		- 接收一段明文，然后以一种不可逆的方式将它转换成一段(通常更小)密文
		- 或理解为取一串输入码(称为预映射或信息)，并把它们转化为长度较短、位数固定的输出序列即散列值(也称为信息摘要或信息认证代码)的过程
		- 该算法输入报文的最大长度不超过264位，产生的输出是一个160位的报文摘要，且输入是按512位的分组进行处理的
		- SHA-1是不可逆的、防冲突，并具有良好的雪崩效应
		- SHA-1是SHA家族的五个算法之一(其它四个是SHA-224、SHA-256、SHA-384，和SHA-512)
		- Go语言中，由crypto/sha1包实现
	- HMAC
		- Hmac算法也是一种哈希算法，它可以利用MD5或SHA1等哈希算法
		- 不同的是，Hmac需要一个密钥，只要密钥发生了变化，那么同样的输入数据也会得到不同的签名，即用随机数"增强"的哈希算法
		- Go语言中，由crypto/hmac包实现
	- Bcrypt
		- 适合Password Hash
		- bcrypt也一种加盐的Hash方法
			- MD5 Hash时候，同一个报文经过hash的时候生成的是同一个hash值，在大数据的情况下，有些经过md5 hash的方法将会被破解(碰撞)
			- 使用BCrypt进行加密，同一个密码每次生成的hash值都是不相同的
			- 每次加密的时候首先会生成一个随机数就是盐，之后将这个随机数与报文进行hash，得到一个hash值
			- Bcrypt有四个变量：
				- saltRounds: 正数，代表hash杂凑次数，数值越高越安全，默认10次
				- myPassword: 明文密码字符串
				- salt: 盐，一个128bits随机字符串，22字符
				- myHash: 经过明文密码password和盐salt进行hash，比如默认10次下，循环加盐hash10次，得到myHash
		- Go语言中，由golang.org/x/crypto/bcrypt包实现
		- 示例 -> 
 - 应用
	- 用户密码的存储和校验
	- 文件上传/下载完整性校验
	- mysql大字段的快速对比

2、对称加密算法
 - 对称加密算法用来对敏感数据等信息进行加密
	- 加密过程的每一步都是可逆的
	- 加密和解密用的是同一组密钥
	- 异或是最简单的对称加密算法
 - 对称加密种类
	- 分组密码，也叫块加密(block cyphers)，一次加密明文中的一个块
		- 将明文按一定的位长分组，明文组经过加密运算得到密文组，密文组经过解密运算(加密运算的逆运算)，还原成明文组
		- 模式: ECB、CBC、CFB、OFB、CTR、CFR
			- CBC(Cipher Block Chaining)/密文分组链接方式
				- 加密步骤
					- 首先将数据按照8个字节一组进行分组得到D1D2......Dn（若数据不是8的整数倍，用指定的PADDING数据补位）
					- 第一组数据D1与初始化向量I 异或后的结果进行DES加密得到第一组密文C1(初始化向量I为全零)
					- 第二组数据D2与第一组的加密结果C1异或以后的结果进行DES加密，得到第二组密文C2
					- 之后的数据以此类推，得到Cn
					- 按顺序连为C1C2C3......Cn即为加密结果
				- 解密步骤 -> 加密的逆过程
					- 首先将数据按照8个字节一组进行分组得到C1C2C3......Cn
					- 将第一组数据进行解密后与初始化向量I进行异或得到第一组明文D1(注意：一定是先解密再异或)
					- 将第二组数据C2进行解密后与第一组密文数据进行异或得到第二组数据D2
					- 之后依此类推，得到Dn
					- 按顺序连为D1D2D3......Dn即为解密结果
						- 解密的结果并不一定是原来的加密数据，可能还得补位，要把补位去掉才是原来的数据
		- 特点
			- 不容易主动攻击，安全性好于ECB，适合传输长度长的报文，是SSL、IPSec的标准
				- 每个密文块依赖于所有的信息块，明文消息中一个改变会影响所有密文块
			- 发送方和接收方都需要知道初始化向量
			- 加密过程是串行的，无法被并行化(在解密时，从两个邻接的密文块中即可得到一个平文块；因此，解密过程可以被并行化)
	- 序列密码，也叫流加密(stream cyphers)，一次加密明文中的一个位
		- 利用少量的密钥(制乱元素)通过某种复杂的运算(密码算法)产生大量的伪随机位流，用于对明文位流的加密
 - 常用的算法
	- DES(Data Encryption Standard): 数据加密标准，一种使用密钥加密的块算法，速度较快，适用于加密大量数据的场合
		- DES是目前最为流行的加密算法之一
		- 对原始数据(明文)进行分组，每组64位，最后一组不足64位时按一定规则填充
		- 每一组上单独施加DES算法
	- 3DES(Triple DES): 是基于DES，对一块数据用三个不同的密钥进行三次加密，强度更高
	- AES(Advanced Encryption Standard): 高级加密标准，是下一代的加密算法标准，速度快，安全级别高
		- 算法原理
			- AES算法基于排列和置换运算
				- 排列是对数据重新进行安排
				- 置换是将一个数据单元替换为另一个
				- AES 使用几种不同的方法来执行排列和置换运算。
			- AES是一个迭代的、对称密钥分组的密码，它可以使用128、192 和 256 位密钥，并且用 128 位(16字节)分组加密和解密数据
				- 与公共密钥密码使用密钥对不同，对称密钥密码使用相同的密钥加密和解密数据
				- 通过分组密码返回的加密数据的位数与输入数据相同
				- 迭代加密使用一个循环结构，在该循环中重复置换和替换输入数据
		- Go语言中，由crypto/aes包实现

3、非对称加密算法
 - 常用于数据加密和身份认证
 - 常见的非对称加密算法
	- DSA(Digital Signature Algorithm): 数字签名算法，是一种标准的DSS(数字签名标准)
		- 基于整数有限域离散对数难题，其安全性与RSA相比差不多
		- DSA的一个重要特点是两个素数公开，因此当使用他人的p和q时，即使不知道私钥，也能确认它们是否是随机产生的，还是作了手脚
		- RSA算法却做不到，但是其缺点就是只能用于数字签名，不能用于加密
		- Go语言中，由crypto/des包实现
	- RSA: 由RSA公司发明，是一个支持变长密钥的公共密钥算法，需要加密的文件块的长度也是可变的
		- 目前最有影响力的公钥加密算法，能够抵抗到目前为止已知的绝大多数密码攻击，已被ISO推荐为公钥数据加密标准
		- Ron Rivest，Adi Shamir，Leonard Adleman
		- 密钥越长，越难破解
			- 目前768位的密钥还无法破解(至少没人公开宣布)
			- 因此可以认为1024位的RSA密钥基本安全，2048位的密钥极其安全
		- RSA的算法原理主要用到了数论
		- Go语言中，由crypto/rsa包实现
	- ECC(Elliptic Curves Cryptography): 椭圆曲线密码编码学
		- 基于椭圆曲线的离散对数难题
			- 给定椭圆曲线上的一个点P，一个整数k，求解 Q = kP 很容易
			- 给定一个点P、Q，知道 Q = kP，求整数 k 是一个难题
		- 背景
			- 目前只有短的RSA钥匙才可能被强力方式解破
			- 到2008年为止，世界上还没有任何可靠的攻击RSA算法的方式
			- 只要其钥匙的长度足够长，用RSA加密的信息实际上是不能被解破的
			- 随着分解大整数方法的进步及完善、计算机速度的提高以及计算机网络的发展，为了保障数据的安全，RSA的密钥需要不断增加
			- 但是，密钥长度的增加导致了其加解密的速度大为降低，硬件实现也变得越来越难以忍受，这对使用RSA的应用带来了很重的负担，因此需要一种新的算法来代替RSA
		- ECC与RSA的比较
			- 抗攻击性强
			- 计算量小，处理速度快
			- 存储空间占用小
			- 带宽要求低
	- ECDSA(Elliptic Curve Digital Signature Algorithm): 基于椭圆曲线的DSA签名算法
		- DSA在数字签名的安全性高，基于ECC的DSA更高，所以非常适合数字签名使用场景，在SSH TLS有广泛使用
		- Go语言中，由crypto/ecdsa包实现
			- 在golang的ssh库中就是使用这个算法来签名
				- A使用自己的私钥签名一段数据，然后将公钥发放出去
				- 用户拿到公钥后，验证数据的签名，如果通过则证明数据来源是A，从而达到身份认证的作用

4、秘钥交换算法
 - 一种密钥交换协议，该算法只能用于密钥的交换，而不能进行消息的加密和解密
	- 双方确定要用的密钥后，要使用其他对称密钥操作加密算法实际加密和解密消息
	- 可以让双方在不泄漏密钥的情况下协商出一个密钥来，常用于保证对称加密的秘钥的安全，比如 TLS
	- 一般有两种类型
		- DH: Diffie-Hellman, 一种确保共享KEY安全穿越不安全网络的方法，是OAKLEY的一个组成部分
		- ECDH: Elliptic Curve Diffie-Hellman, DH算法的加强版，基于椭圆曲线难题加密，现在是主流的密钥交换算法
			- 常用的是NIST系列，但是后面curve25519更为优秀
			- curve25519: 实质上也是一种ECDH，但是其实现更为优秀，表现的更为安全，可能是下一代秘钥交换算法的标准
			- Go语言中
				- 由crypto库实现了P224/P256/P384/P521
				- curve25519则不在标准库中: golang.org/x/crypto/curve25519

六、测试
1、Go语言中的测试
 - Go提供了test工具用于代码的测试
	- test工具会查找包下以 _test.go结尾的文件
	- 调用测试文件中以Test或Benchmark开头的函数并给出运行结果

2、单元测试
 - 定义
	- 单元是应用中最小的可测试部件，如函数和对象的方法
	- 单元测试是软件开发中对最小单位进行正确性检验的测试工作
	- Go语言原生支持了单元测试，使用上非常简单
 - 意义
	- 保证变更/重构的正确性，特别是在一些频繁变动和多人合作开发的项目中
	- 简化调试过程: 可以轻松的测试出哪一部分代码出现问题
	- 单元测试是最好的文档 -> 在单测中直接给出具体接口的使用方法，是最好的实例代码
 - 单元测试用例编写的原则
	- 单一原则: 一个测试用例只负责一个场景
	- 原子性: 结果只有两种情况: PASS/FAIL
	- 优先要核心组件和逻辑的测试用例
	- 对于高频使用库，如: util，需要重点覆盖
 - 使用要求
	- 文件名命名要求: {pkg_name}_test.go
	- 需要导入testing包
	- 测试方法/函数命名要求: 定义以Test开头的函数
	- 函数参数: (t *testing.T)
	- 测试文件和被测试文件必须在一个包中
	- 在测试函数中调用函数进行返回值测试，当测试失败可通过testing.T结构体的Error*函数抛出错误
	- 使用 package packagename_test 命名的测试包在构建二进制文件时不会被打包
 - Go语言的测试框架
	- testing 测试框架
		- 执行命令
			- go test -v .
			- -cover测试覆盖率 go test -v -cover .
			- 只执行某个函数 go test -run=TestAdd -v .
			- 正则过滤函数名 go test -run=TestM.* -v .
			- 指定func/sub跑子测试 go test -run=TestMul/正数 -v
		- 子测试 t.Run
			func TestMul(t *testing.T) {
				t.Run("正数", func(t *testing.T) {
					if Mul(4, 5) != 20 {
						t.Fatal("muli.zhengshu.error")
					}
				})
			
				t.Run("负数", func(t *testing.T) {
					if Mul(2, -3) != -6 {
						t.Fatal("muli.fusshu.error")
					}
				})
			}
		- table-driven tests
			- 所有用例的数据组织在切片 cases 中，看起来就像一张表，借助循环创建子测试
			- 益处
				- 新增用例非常简单，只需给 cases 新增一条测试数据即可
				- 测试代码可读性好，直观地能够看到每个子测试的参数和期待的返回值
				- 用例失败时，报错信息的格式比较统一，测试报告易于阅读
				- 如果数据量较大，或是一些二进制数据，推荐使用相对路径从文件中读取
			- 举例 https://github.com/prometheus/prometheus/blob/main/web/api/v1/api_test.go
 - GoConvey 测试框架
	- go get github.com/smartystreets/goconvey
 - testify 测试框架
	- go get github.com/stretchr/testify/assert
 - 单元测试覆盖率应用实例
	- https://github.com/m3db/m3/pull/3525

2、基准测试
 - 用途
	- 基准测试常用于代码性能测试 
 - 用法
	- 函数需要导入testing包
	- 定义以 Benchmark开头的函数，参数为(b *testing.B)
	- 在测试函数中 循环调用函数多次
 - bench的工作原理
	- 基准测试函数会被一直调用直到b.N无效，它是基准测试循环的次数
	- b.N 从 1 开始，如果基准测试函数在1秒内就完成(默认值)，则 b.N 增加，并再次运行基准测试函数
	- b.N 的值会按照序列 1,2,5,10,20,50,... 增加，同时再次运行基准测测试函数
	- 输出: BenchmarkFib-12    183    6272054 ns/op    0 B/op    0 allocs/op
		- 上述结果解读代表 1秒内运行了183次 每次 6272054 ns
		- -12 后缀和用于运行次测试的 GOMAXPROCS 值有关
		- 与GOMAXPROCS一样，此数字默认为启动时 Go
 - 执行命令
	- go test 会在运行基准测试之前执行包里所有的单元测试
		- 如果包里有很多单元测试，或者它们会运行很长时间
		- 通过 go test 的-run 标识排除这些单元测试
		- go test -bench=. -run=none
	- 内存消耗情况
		- go test -bench=. -benchmem -run=none
	- CPU消耗情况
		- go test -bench=. -cpu=1,2,4 -benchmem -run=none
	- count多次运行基准测试
		- go test -bench=. -count=10 -benchmem -run=none      // 热缩放、内存局部性、后台处理、gc活动等等会导致单次的误差
	- benchtime指定运行秒数 
		- go test -bench=. -benchtime=5s -benchmem -run=none  // 有的函数比较慢，为了更精确的结果，可以通过 -benchtime 标志指定运行时间，从而使它运行更多次
 - 示例
	- 斐波那契数列
		func fib(n int) int {                   // fib.go
			if n == 0 || n == 1 {
				return n
			}
			return fib(n-2) + fib(n-1)
		}
		func BenchmarkFib(b *testing.B) {       // fib_test.go
			for n := 0; n < b.N; n++ {
				fib(30)
			}
		}
		- ResetTimer   // 如果基准测试在循环前需要一些耗时的配置，则可以先重置定时器
			func BenchmarkFib(b *testing.B) {
				time.Sleep(3 * time.Second)
				b.ResetTimer()
				for n := 0; n < b.N; n++ {
					fib(30)
				}
			}
	- benchmem 展示内存消耗情况
		- G
		- 测试大cap的切片，直接用cap初始化，然后动态扩容
		- 结论: 用cap初始化好的性能可以高一个数据量级
		// 制定大的cap的切片
		func generateWithCap(n int) []int {
			rand.Seed(time.Now().UnixNano())
			nums := make([]int, 0, n)
			for i := 0; i < n; i++ {
				nums = append(nums, rand.Int())
			}
			return nums
		}
		
		// 动态扩容的slice
		func generateDynamic(n int) []int {
			rand.Seed(time.Now().UnixNano())
			nums := make([]int, 0)
			for i := 0; i < n; i++ {
				nums = append(nums, rand.Int())
			}
			return nums
		}
		func BenchmarkGenerateWithCap(b *testing.B) {
			for n := 0; n < b.N; n++ {
				generateWithCap(100000)
			}
		}
		func BenchmarkGenerateDynamic(b *testing.B) {
			for n := 0; n < b.N; n++ {
				generateDynamic(100000)
			}
		}
	- 测试函数复杂度 不带cap的slice 动态扩容
		- 结论: 输入变为原来的10倍，单次耗时也差不多是上一级的10倍，说明这个函数的复杂度是线性的
		func benchmarkGenerate(i int, b *testing.B) {
			for n := 0; n < b.N; n++ {
				generateDynamic(i)
			}
		}
		func BenchmarkGenerateDynamic1000(b *testing.B)     { benchmarkGenerate(1000, b) }
		func BenchmarkGenerateDynamic10000(b *testing.B)    { benchmarkGenerate(10000, b) }
		func BenchmarkGenerateDynamic100000(b *testing.B)   { benchmarkGenerate(100000, b) }
		func BenchmarkGenerateDynamic1000000(b *testing.B)  { benchmarkGenerate(1000000, b) }
		func BenchmarkGenerateDynamic10000000(b *testing.B) { benchmarkGenerate(10000000, b) }
	- string拼接的 bench
		- const letterBytes = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
		- "+"
		- []byte
		- strings.Builder
		- bytes.Buffer
		

七、文件
1、基本概念
 - 绝对路径
	- 文件路径字符串从根路径(盘符)开始
 - 相对路径
	- 二进制文件运行的目录(cd $directory)
	- 相对程序执行的路径，即当前shell 处于的路径
 - 文件类型
	cat/记事本 -> 文本内容(无乱码 .go .txt) -> 文本文件 -> string
	cat/记事本 -> 有乱码(word, zip, excel) -> 二进制文件 -> []byte
 - I/O操作
	- 也叫输入/输出操作，其中I是指Input，O是指Output，主要用来读取或写入数据，很多语言中也叫做流操作
	- Go语言中 输入和输出操作是使用原语实现的
		- 这些原语将数据模拟成可以读或者可以写的字节流
		- DataSource -> io.Reader -> Transfer buffer []byte -> io.Writer -> Target
		
2、文件
1).基本操作(不带缓冲IO): 读、写                     // 打开文件 -> 错误处理 -> 延迟关闭 -> 读/写/其他 -> 关闭文件
 - 创建 os.Create()
 - 读取 os.Open()
 - 获取属性 os.Open().Stat/ os.Stat 
 - 修改属性 -> 权限，所属人
	os.Chmod()
	os.Chown()
 - 重命名 os.Rename("a.txt", "b.txt")
 - 删除文件 os.Remove("b.txt")
 - os 包提供了对文件、系统和进程的操作函数
 - 文件操作
	- 常用常量
		- flag	
			// Exactly one of O_RDONLY, O_WRONLY, or O_RDWR must be specified.
			O_RDONLY int = syscall.O_RDONLY // open the file read-only.
			O_WRONLY int = syscall.O_WRONLY // open the file write-only.
			O_RDWR   int = syscall.O_RDWR   // open the file read-write.
			// The remaining values may be or'ed in to control behavior.
			O_APPEND int = syscall.O_APPEND // append data to the file when writing.
			O_CREATE int = syscall.O_CREAT  // create a new file if none exists.
			O_EXCL   int = syscall.O_EXCL   // used with O_CREATE, file must not exist.
			O_SYNC   int = syscall.O_SYNC   // open for synchronous I/O. 使用同步 I/O
			O_TRUNC  int = syscall.O_TRUNC  // truncate regular writable file when opened. 截断(清空)文件
			ModePerm: 0777
		- I/O
			Stdin    // Stdin  = NewFile(uintptr(syscall.Stdin), "/dev/stdin")
			Stdout   // Stdout = NewFile(uintptr(syscall.Stdout), "/dev/stdout")
			Stderr   // Stderr = NewFile(uintptr(syscall.Stderr), "/dev/stderr")
	- 常用函数
		Args: 获取命令行参数
		Hostname: 获取主机名
		Getpid: 获取当前进程名
		Getenv: 获取一条环境变量
		Environ: 获取所有环境变量
		Getwd: 获取当前目录
		Chmod: 修改文件权限
		Chown: 修改文件所属用户，用户组
		Chtimes: 修改文件访问时间和修改时间
		IsExist: 与 os.Stat 一起用于判断文件存在
		IsNotExist: 与 os.Stat 一起用于判断文件不存在
		Link: 创建软链接
		Mkdir: 创建文件夹
		MkdirAll: 创建文件夹（父目录不存在逐层创建）
		Remove: 移除文件或空文件夹
		RemoveAll: 移除所有文件
		Rename: 重命名
	- 常用结构体   
		File: 对文件操作                 // type File struct { // Has unexported fields. }              	  
		- 常用函数
			Create: 创建文件并返回文件对象指针（文件不存在则创建，文件存在则清空）  // func os.Create(name string) (*os.File, error)
			Open: 打开文件并返回文件对象指针                                        // func os.Open(name string) (*os.File, error)
			OpenFile: 按指定权限打开文件，并返回文件指针对象                        // func OpenFile(name string, flag int, perm FileMode) (*File, error)
		- 常用方法
			Read: 读取文件到字节切片              // func (*os.File).Read(b []byte) (n int, err error)
			Write: 写入字节切片到文件             // func (*os.File).Write(b []byte) (n int, err error)
			WriteString: 写入字符串到文件         // func (*os.File).WriteString(s string) (n int, err error)
			Readdir: 获取目录下所有文件信息       // func (*os.File).ReadDir(n int) ([]fs.DirEntry, error)
			Readdirnames: 获取目录下所有文件名    // func (*os.File).Readdirnames(n int) (names []string, err error)
			Seek: 设置文件指针位置                // func (f *File) Seek(offset int64, whence int) (ret int64, err error)  whence: 0文件开始, 1当前位置, 2文件末尾; 在大部分编程语言中，不支持在文件的开始或中间插入数据(会直接从光标位置进行覆写)，只支持在文件末尾进行数据追加
			Stat: 获取文件状态信息                // func (file *File) Stat() (FileInfo, error)
			Sync: 同步文件到硬盘                  
			Close: 关闭文件                       // func (*os.File).Close() error
	- 创建和写入文件
		path := "test.txt"
		file, err := os.Create(path)
		if err != nil {
			fmt.Println(err)
			return
		}
		defer file.Close()
		
		name := "aa"
		fmt.Fprintf(file, "I am %s\n", name)
		file.WriteString("ccc联动")
		file.Write([]byte("123456789\n"))
		fmt.Println(file.Write([]byte("bb")))    // 两个返回值 一个是 []byte 的长度，一个是 error
	- 读文件
		path := "test.txt"
		file, err := os.Open(path)
		fmt.Println(file, err)
		if err != nil {
			return
		}
		defer file.Close()
		
		content := make([]byte, 3)
		
		for {
			n, err := file.Read(content)
			if err != nil {
				if err != io.EOF {               // EOF(End Of File) -> 标识文件读取结束
					fmt.Print(err)
				} else {
					fmt.Print(err)
				}
				break
			}
			fmt.Println(string(content[:n]))
		}
	- os.OpenFile使用
		- os.Open -> 读文件，文件不存在则报错
			func Open(name string) (*File, error) {
				return os.OpenFile(name, os.O_RDONLY, 0777)
			}
		- os.Create -> 写文件，文件存在 截断，文件不存在 创建
			func Create(name string) (*File, error) {
				return os.OpenFile(name, os.O_WRONLY|os.O_CREATE|os.O_TRUNC)
			}
		- 示例
			file, err := os.OpenFile("test.txt", os.O_WRONLY, os.ModePerm)
			if err != nil {
				fmt.Println(err)
				return
			}
			defer file.Close()
2).标准输入、标准输出、标准错误
 - 标准输入 -> os.Stdin
	- 示例
		content := make([]byte, 3)
		
		fmt.Print("请输入内容: ")
		fmt.Println(os.Stdin.Read(content))
		fmt.Printf("%q\n", string(content))
	- os.stdin 作为脚本的输入内容
		- os/exec
			- exec包提供了启动一个外部进程并使用标准输入和输出进行通信
				- 常用结构体
					- Cmd: 执行命令 
				- 常用函数
					- Command     // func Command(name string, arg ...string) *Cmd
				- 常用方法
					- Output: 执行并获取标准输出结果
					- Run: 自行命令            // func (c *Cmd) Run() error
					- Start: 启动命令          // func (c *Cmd) Start() error
					- Wait: 与 Start一起使用等待命令结束
					- StdoutPipe: 输出管道     // func (c *Cmd) StdoutPipe() (io.ReadCloser, error)
					- StdinPipe: 输入管道      // func (c *Cmd) StdinPipe() (io.WriteCloser, error)
					- StderrPipe: 错误管道     // func (c *Cmd) StderrPipe() (io.ReadCloser, error)
		- 写一个脚本，和命令一个输入的文件
		- 文件作为脚本的stdin，执行
			// echo "ss -ntlp " > a.txt
			// go run a.go < a.txt
			cmd := exec.Command("sh")
			cmd.Stdin = os.Stdin
			cmd.Stdout = os.Stdout
			cmd.Stderr = os.Stderr
			err := cmd.Run()
			if err != nil {
				fmt.Println("run.err", err)
				return
			}
 - 标准输出 -> os.Stdout  
	- 示例
		os.Stdout.WriteString("我是Stdout的输出")
		fmt.Fprintln(os.Stdout, "aaaaa")
		fmt.Fprintf(os.Stdout, "I am: %s", "aaaaa")
	- os.StdOut.Write 代替 fmt.Print
		os.Stdout.Write([]byte("aa和bb"))
		fmt.Println("aa和bb")
 - 标准错误  -> os.Stderr  
3).带缓冲的IO
 - bufio包提供缓冲流的功能
	- 常用结构体
		- Reader
			- 常用函数
				NewReader: 创建缓冲 输入 流
			- 常用方法
				Read: 读取数据到切片中
				ReadLine: 读取一行内容到字节切片中
				ReadSlice: 根据分隔符读取数据到字节切片
				ReadString: 根据分隔符读取数据到字符串
				Reset: 重设缓冲流
				WriteTo: 将数据写入到输出流
		- Scanner
			- 常用函数
				NewScanner: 创建扫描对象
			- 常用方法
				Scan: 扫描数据
				Split: 定义流分割函数，默认 空格
				Text: 读取数据
				Err: 获取错误
		- Writer
			- 常用函数
				NewWriter: 创建缓冲输出流
			- 常用方法
				Write: 将字节切片内容写入
				WriteString: 将字符串写入
				Reset: 重置输出流
				Flush: 刷新数据到输出流
	- 示例
		scanner := bufio.NewScanner(os.Stdin)        // os.Stdin
		for scanner.Scan() {
			fmt.Println(scanner.Text())
			break
		}
		
		func ScanInt() (int, error) {
			// 读取一行 进行转换
			scanner := bufio.NewScanner(os.Stdin)
			if scanner.Scan() {
				return strconv.Atoi(scanner.Text())
			}
			return 0, scanner.Err()
		}
		num, err := ScanInt()
		fmt.Println(num, err)
4).IO库
 - io.Copy // func io.Copy(dst io.Writer, src io.Reader) (written int64, err error)
 - io库属于底层接口定义库，作用是定义一些基本接口和基本常量，如io.EOF
 - io库常用接口有:Reader、Writer、Close         // 以流的方式高效处理数据，并不需要考虑数据是什么，数据来自哪里，数据要发送到哪里
 	- Reader
 		- io.Reader表示一个读取器
			- 它从某个地方读取数据到传输的缓存区
			- 在缓存区里面，数据可以被流式的使用
			- 接口签名
				type Reader interface {
					Read(p []byte) (n int, err error)
				}
 		- strings.NewReader
 			- io.Reader 接口只有一个方法: Read方法
 			- 即只要有个对象实现了Read方法，那么这个对象就是一个读取器
 			- Read() 首先要有一个读缓冲区的参数
 			- Read() 返回两个值，第一个是读取到的字节数，第二个是读取时发生的错误  // func (*strings.Reader).Read(b []byte) (n int, err error)
 			- 注意: 返回到的读取字节个数n可能小于缓冲区的大小
 			- io.EOF 表示输入的流已经读到头了
 			- 示例
				// 实现一个 reader 每次读取4个字节
				// 从字符串创建一个reader对象
				reader := strings.NewReader("马哥教育 2021 第005期 golang")
				// new一个3字节的读取缓冲区
				p := make([]byte, 3)
				for {
					// reader对象读取数据
					n, err := reader.Read(p)
					if err != nil {
						if err == io.EOF {
							log.Printf("[数据已读完 EOF:%d]", n)
							break
						}
						log.Printf("[未知错误:%v]", err)
						return
					}
					log.Printf("[打印读取的字节数:%d 内容:%s]", n, string(p[:n]))
				}
 		- 自定义Reader
			- 要求: 过滤输入字符串中的非字母字符
			- 输入 "mage jiaoyue 2021 go !!!!"
			- 输出 "magejiaoyuego"
			- 示例
				type zimuguolv struct {
					src string
					cur int
				}
				func alpha(r byte) byte {
					// r在 A-Z 或者 a-z
					if (r >= 'A' && r <= 'Z') || (r >= 'a' && r <= 'z') {
						return r
					}
					return 0
				}
				func (z *zimuguolv) Read(p []byte) (int, error) {
					// 当前位置 >= 字符串长度，说明已经读取到结尾了，返回 EOF
					if z.cur >= len(z.src) {
						return 0, io.EOF
					}
					// 定义一个剩余还没读到的长度
					x := len(z.src) - z.cur
					// bound叫做本次读取长度
					// n代表本次遍历 bound的索引
					n, bound := 0, 0
					if x >= len(p) {
						// 剩余长度超过缓冲区大小，说明本次可以完全填满换冲区
						bound = len(p)
					} else {
						// 剩余长度小于缓冲区大小，使用剩余长度输出，缓冲区填不满
						bound = x
					}
				
					buf := make([]byte, bound)
				
					for n < bound {
						if char := alpha(z.src[z.cur]); char != 0 {
							buf[n] = char
						}
						// 索引++
						n++
						z.cur++
					}
					copy(p, buf)
					return n, nil
				}
				zmreader := zimuguolv{
					src: "mage jiaoyu 2021 go !!!!",
				}
				p := make([]byte, 4)
				for {
					n, err := zmreader.Read(p)
					if err == io.EOF {
						log.Printf("[EOF错误]")
						break
					}
					log.Printf("[读取到的长度%d 内容%s]", n, string(p[:n]))
				}
		- 组合多个Reader
			- 标准库里面已经有了很多Reader
			- 使用一个Reader A作为一个Reader B的一部分
			- 目的是重用和屏蔽下层实现的复杂度；即复用逻辑，流式处理
			- 复用的io.Reader
			- 例如:
				type alphaReader struct {
					ioReader io.Reader
				}
				func (a *alphaReader) Read(p []byte) (int, error) {
					// 复用io.reader的read方法
					n, err := a.ioReader.Read(p)
					if err != nil {
						return n, err
					}
				
					buf := make([]byte, n)
					for i := 0; i < n; i++ {
						if char := alpha(p[i]); char != 0 {
							buf[i] = char
						}
					}
					copy(p, buf)
					return n, nil
				}
				myReader := alphaReader{
					strings.NewReader("mage jiaoyu 2021 go !!!"),
				}

		- os.File 结合
			- os.Open得到一个file对象 ，实现了io.Reader的Read方法
			- 以下代码展示了 alphaReader 如何与 os.File 结合以过滤掉文件中的非字母字符
			- 例如:
				file, err := os.Open("test.txt")
				if err != nil {
					fmt.Println(err)
					os.Exit(1)
				}
				defer file.Close()
				myReader := alphaReader{
					file,
				}
		- 读取文件 ioutil.ReadFile vs bufio 
			- 都提供了文件读写的能力
			- bufio多了一层缓存的能力，优势体现在读取大文件的时候
			- ioutil.ReadFile是一次性将内容加载到内存，大文件容易爆掉
			- 示例
				fileName := "test.txt"
				- ioutil.ReadFile
					bytes, err := ioutil.ReadFile(fileName)
					if err != nil {
						return
					}
				- os.Open + ioutil.ReadAll
					file, err := os.Open(fileName)
					if err != nil {
						return
					}
					bytes, err = ioutil.ReadAll(file)
					if err != nil {
						return
					}
					file.Close()
				- os.Open + file.Read
					file, _ = os.Open(fileName)
					buf := make([]byte, 50)
					_, err = file.Read(buf)
					if err != nil {
						return
					}
					file.Close()
				-  os.Open + bufio.Read
					file, _ = os.Open(fileName)
					rd := bufio.NewReader(file)  	// bufio.NewReader
					buf1 := make([]byte, 50)
					_, err = rd.Read(buf1)
					if err != nil {
						return
					}
					file.Close()
	- Writer 
		- io.Writer 表示一个编写器，它从缓冲区读取数据，并将数据写入目标资源。
			- 接口签名
				type Writer interface {
					Write(p []byte) (n int, err error)
				}
		- Write() 方法有两个返回值，一个是写入到目标资源的字节数，一个是发生错误时的错误。
			- closer
			- bytes.Buffer库 
				- bytes.Buffer 的针对的是内存到内存的缓存
			- ioutil库 工具包
				- 在io目录下，它是一个工具包，实现一些实用的工具  // "io/ioutil"
					- ReadFile 读取文件                           // func ReadFile(filename string) ([]byte, error)
						fileName := "golang.txt"
						bytes, err := ioutil.ReadFile(fileName)
						if err != nil {
							fmt.Println(err)
							return
						}
					- WriteFile 写入文件                          // func WriteFile(filename string, data []byte, perm fs.FileMode) error
						fileName := "test.txt"
						err := ioutil.WriteFile(fileName, []byte("123\n456"), 0644)
						fmt.Println(err)
					- ReadDir 读取目录下的文件元信息              // func ReadDir(dirname string) ([]fs.FileInfo, error)
						fs, err := ioutil.ReadDir("./")
						if err != nil {
							fmt.Println(err)
							return
						}
						for _, f := range fs {
							fmt.Printf("[name:%v][size:%v][isDir:%v][mode:%v][ModTime:%v]\n",
								f.Name(),
								f.Size(),
								f.IsDir(),
								f.Mode(),
								f.ModTime(),
							)
						}
4).目录
 - 创建
	fmt.Println(os.Mkdir("a", os.ModePerm))
	fmt.Println(os.MkdirAll("a/b/c", os.ModePerm))
 - 读取 os.Open("test.txt")
 - 获取属性 os.Open().Stat/ os.Stat 
 - 修改属性 -> 权限，所属人
	os.Chmod()
	os.Chown()
 - 重命名 fmt.Println(os.Rename("b", "d:\\d"))
 - 删除文件夹
	fmt.Println(os.Remove("a"))
	os.RemoveAll("a")
 - FileInfo: 文件状态信息
	- 常用函数
		Lstat: 获取文件路径文件信息（对于链接返回连接文件信息）
		Stat: 获取文件路径文件信息（对于链接返回连接到的文件的信息）
	- 常用方法
		Name: 获取文件名
		Size: 获取文件大小
		Mode: 获取文件模式              // func (fs.FileInfo).Mode() fs.FileMode
		ModTime: 获取修改时间
		IsDir: 判断是否为文件夹  
 - FileMode: 文件模式
	- 常用方法
		IsDir: 判断是否为文件夹         // func (fs.FileMode).IsDir() bool
5).编码格式
 - 注册，打开文件，创建对象，编码/解码
 - gob                                  // go特有的编码格式，不能跨语言
	- encoding/gob 包提供了对数据结构进行二进制序列化的功能
		- 常用函数
			- Register: 注册 gob 编解码记录值                       // func Register(value interface{})
			- RegisterName: 注册 gob 编解码记录值，并指定名称       // func RegisterName(name string, value interface{})
		- 常用结构体
			- Encoder                                               // type Encoder struct{ ... }
				- 常用函数 
					- NewEncoder: 创建编码器                        // func NewEncoder(w io.Writer) *Encoder
				- 常用方法
					- Encode: 将对象进行编码到流对象中              // func (enc *Encoder) Encode(e interface{}) error
			- Decoder                                               // type Decoder struct{ ... }
				- 常用函数
					- NewDecoder: 创建解码器                        // func NewDecoder(r io.Reader) *Decoder
				- 常用方法
					- Decode: 将流对象中的数据编码到对象中          // func (dec *Decoder) Decode(e interface{}) error
	- 示例
		type User struct {
			Id   int
			Name string
		}
		enusers := []User{
			{1, "aa"},
			{2, "bb"},
		}
		// 注册
		gob.Register(User{})
		// 编码
		file, err := os.Create("users.gob")
		if err != nil {
			fmt.Println(err)
			return
		}
		encoder := gob.NewEncoder(file)
		fmt.Println(encoder.Encode(enusers))
		file.Close()
		// 解码
		file, err := os.Open("users.gob")
		if err != nil {
			return
		}
		decoder := gob.NewDecoder(file)
		var deusers []User
		fmt.Println(decoder.Decode(&deusers))
		fmt.Println(deusers)
		file.Close()	
 - csv
	- encoding/csv 包提供对 csv 文件读写的操作
	- 常用结构体
		- Reader
			- 常用函数
				- NewReader        // func NewReader(r io.Reader) *Reader
			- 常用方法
				- Read             // func (r *Reader) Read() (record []string, err error)
				- ReadAll          // func (r *Reader) ReadAll() (records [][]string, err error)
		- Writer
			- 常用函数
				- NewWriter        // func NewWriter(w io.Writer) *Writer    
			- 常用方法
				- Write            // func (w *Writer) WriteAll(records [][]string) error 
				- WriteAll         // func (w *Writer) Write(record []string) error  
				- Flush            // func (w *Writer) Flush() 
				- Error            // func (w *Writer) Error() error
	- 示例
		wusers := []User{
			{1, "aa"},
			{2, "bb"},
		}
		// 写入
		file, err := os.Create("users.csv")
		if err != nil {
			return
		}
		writer := csv.NewWriter(file)
		for _, user := range wusers {
			writer.Write([]string{strconv.Itoa(user.Id), user.Name})
		}
		writer.Flush()
		file.Close()
		// 读取
		file, err = os.Open("users.csv")
		if err != nil {
			return
		}
		var rusers []User
		reader := csv.NewReader(file)
		for {
			line, err := reader.Read()
			if err != nil {
				if err != io.EOF {
					fmt.Println(err)
				}
				break
			}
			id, _ := strconv.Atoi(line[0])
			rusers = append(rusers, User{id, line[1]})
		}
		fmt.Println(rusers)


八、网络
1、网络通信
 - 网络请求过程
	- 流程图
		                                     内核空间                               用户空间
				1).网络请求 ->        2).copy(I/O模型、DMA)->        3).copy(MMAP) ->      4-1).处理请求
		client                   网卡                         内核缓冲区            web服务进程    |
				7).返回数据 <-               6).copy <-                  6).copy <-        4-2).构建Respense
	- DMA
		- 网卡和磁盘数据拷贝到内存流程比较固定，不涉及到运算操作，且非常耗时
		- 在磁盘嵌入一个DMA芯片，完成上述拷贝工作，把CPU解脱出来，让CPU专注于运算
	- MMAP
		- 用户空间和内核空间映射同一块内存空间，从而达到省略将数据从内核缓冲区拷贝到用户空间的操作，用户空间通过映射直接操作内核缓冲区的数据
	- I/O模型
		- 阻塞式网络I/O
		- 非阻塞式网络I/O
		- 多路复用网络I/O
	- socket
		- 用户进程(复数，即应用层) -> socket抽象层 -> TCP/UDP(传输层)
		- socket把复杂的传输层协议封装成简单的接口，使应用层可以像读写文件一样进行网络数据的传输
		- socket通信过程
			- Server端
				          设置监听端口|设置监听队列|阻塞，循环等待客户端连接
				Socket() -> Bind() -> Listen() -> Accept() -> Receive() -> Send()    -> Close()
			- Client端                            建立连接     发送数据    接收数据   关闭连接
				Socket()           ->            Connect() -> Send()    -> Receive() -> Close()

2、Socket编程
 - 网络进程标识
	- 用三元组(ip地址，协议，端口号)唯一标示网络中的一个进程，如(172.122.121.111, tcp, 5656)
	- IPv4的地址位数为32位，分为4段，每段最大取值为255
	- IPv6的地址位数为128位，分为8段，各段用16进制表示，最大取值为ffff
	- 端口: 0~1023被熟知的应用程序占用(普通应用程序不可以使用)，49152~65535 客户端程序运行时动态选择使用
 - TCP/CS架构
	- TCP协议
		- 传输层协议
		- MSS = MTU - ip首部 - tcp首部，MTU视网络接口层的不同而不同
		- TCP在建立连接时通常需要协商双方的MSS值
		- 应用层传输的数据大于MSS时需要分段
		- TCP首部
			- 报文结构
				|      源端口(2Bytes)          |         目的端口(2Bytes)       |
				|                             序号                              |
				|                            确认号                             |
				| 数据偏移 | 保留位 |           tcp flags            |   窗口   | 
				|  (4bit)  | (6bit) | (URG、ACK、PSH、RST、SYS、FIN) | (2Bytes) |
				|      检验和(2Bytes)          |         紧急指针(2Bytes)       |
				|                           TCP选项                             |
			- 前20个字节是固定的，后面还有4N个可选字节(TCP选项)
			- 端口在 TCP层指定，ip在 IP层指定
				- 端口占2个字节，则最大端口号为2^16-1=65535
			- 由于应用层的数据被进行分段，为了在接收端对数据按顺序重组，需要为每段数据编个"序号"
			- 数据偏移
				- TCP数据部分距TCP开头的偏移量(一个偏移量是4个字节)，亦即TCP首部的长度
				- 所以TCP首部的最大长度是15*4=60个字节，即TCP选项最多有40个字节
			- TCP协议规定在连接建立后所有传输的报文段都必须把ACK设置为1
			- TCP连接
				- 建立连接 三次握手
					- 第一次握手: TCP首部SYN=1，初始化一个序号=J；SYN报文段不能携带数据
					- 第二次握手: TCP首部SYN=1，ACK=1，确认号=J+1，初始化一个序号=K；此报文同样不携带数据
					- 第三次握手: SYN=1，ACK=1，序号=J+1，确认号=K+1；此次一般会携带真正需要传输的数据
					- 确认号: 即希望下次对方发过来的序号值
					- SYN Flood 攻击始终不进行第三次握手，属于DDOS攻击的一种
				- 断开连接 四次挥手
					- TCP的连接是全双工(可以同时发送和接收)的连接，因此在关闭连接的时候，必须关闭传送和接收两个方向上的连接
					- 第一次挥手: FIN=1，序号=M
					- 第二次挥手: ACK=1，序号=M+1
					- 第三次挥手: FIN=1，序号=N
					- 第四次挥手: ACK=1，序号=N+1
					- 从TIME_WAIT进入CLOSED需要经过2个MSL(Maxinum Segment Lifetime)，RFC793建议MSL=2分钟
	- Go语言中的TCP编程接口
		- net.ResolveTCPAddr
			- func ResolveTCPAddr(network, address string) (*TCPAddr, error)
			- net参数是"tcp4"、"tcp6"、"tcp"中的任意一个，分别表示TCP4(IPv4-only)，TCP6(IPv6-only)或者TCP(IPv4,、IPv6的任意一个)
			- addr表示域名或者IP地址，例如" www.qq.com:80" 或者"127.0.0.1:22"
		- net.ListenTCP
			- func ListenTCP(network string, laddr *TCPAddr) (*TCPListener, error)
			- 监听端口
		- net.Accept
			- func (l *TCPListener) Accept() (Conn, error)
			- 等待客户端连接
		- net.DialTCP
			- func DialTCP(network string, laddr, raddr *TCPAddr) (*TCPConn, error)
			- net参数是"tcp", "tcp4" (IPv4-only), "tcp6" (IPv6-only)
			- laddr表示本机地址，一般设置为nil
			- 向raddr端发起请求，建立tcp连接
		- net.DialTimeout
			- func DialTimeout(network, address string, timeout time.Duration) (Conn, error)
			- 创建连接时设置超时时间
			- netwok指定为tcp，建立连接时指定超时
		- net.SetReadDeadline
			- func (c *TCPConn) SetReadDeadline(t time.Time) error
			- 设置从一个tcp连接上读取的超时时间
		- net.SetWriteDeadline
			- func (c *TCPConn) SetWriteDeadline(t time.Time) error
			- 设置从一个tcp连接上写入的超时时间
		- net.SetKeepAlive
			- func (c *TCPConn) SetKeepAlive(keepalive bool) error
			- 当一个tcp连接上没有数据时，操作系统会间隔性地发送心跳包，如果长时间没有收到心跳包会认为连接已经断开
		- net.Write
			- func (c *TCPConn) Write(b []byte) (int, error)
			- 通过conn发送数据
		- net.Read
			- func (c *TCPConn) Read(b []byte) (int, error)
			- 从conn里读取数据
		- ioutil.ReadAll
			- func ReadAll(r io.Reader) ([]byte, error)
			- 从conn中读取所有内容，直到遇到error(比如连接关闭)或EOF
		- net.Close
			- func (c *TCPConn) Close() error
			- func (l *TCPListener) Close() error
			- 关闭连接
 - UDP/CS架构
	- UDP协议
		- 不需要建立连接，直接收发数据，效率很高
		- 面向报文
			- 对应用层交下来的报文，既不合并也不拆分，直接加上边界交给IP层
			- TCP是面向字节流
		- 从机制上不保证顺序(在IP层要对数据分段)，可能会丢包(检验和如果出差错就会把这个报文丢弃掉)
			- 在内网环境下分片乱序和数据丢包极少发生
		- 支持一对一、一对多、多对一和多对多的交互通信
		- 首部开销小，只占8个字节
		- UDP首部
			- 报文结构
				| 源端口(2Bytes) | 目的端口(2Bytes) |  // UDP首部
				|  UDP报文长度   |       检验和     |
				|           用户数据部分            |
	- Go语言中的UDP编程接口
		- net.ResolveUDPAddr
			- func ResolveUDPAddr(network, address string) (*UDPAddr, error)
			- netwok指定为"udp", "udp4" (IPv4-only), "udp6" (IPv6-only)，解析成udp地址
		- net.ListenUDP
			- func ListenUDP(network string, laddr *UDPAddr) (*UDPConn, error)
			- 直接调用Listen返回一个udp连接
		- net.DialUDP
			- func DialUDP(network string, laddr, raddr *UDPAddr) (*UDPConn, error)
			- netwok指定为"udp", "udp4" (IPv4-only), "udp6" (IPv6-only)
			- 建立udp连接(伪连接)
		- net.DialTimeout
			- func DialTimeout(network, address string, timeout time.Duration) (Conn, error)
			- 创建连接时设置超时时间
			- netwok指定为udp，建立连接时指定超时
		- net.SetReadDeadline
			- func (c *UDPConn) SetReadDeadline(t time.Time) error
		- net.SetWriteDeadline
			- func (c *UDPConn) SetWriteDeadline(t time.Time) error
		- net.Read
			- func (c *UDPConn) Read(b []byte) (int, error)
		- net.ReadFromUDP
			- func (c *UDPConn) ReadFromUDP(b []byte) (int, *UDPAddr, error)
			- 读数据，会返回remote的地址
		- net.Write
			- func (c *UDPConn) Write(b []byte) (int, error)
		- net.WriteToUDP
			- func (c *UDPConn) WriteToUDP(b []byte, addr *UDPAddr) (int, error)
			- 写数据，需要指定remote的地址
		- net.Close
			- func (c *UDPConn) Close() error
 - TLS协议
 	- 很多应用层协议(http、ftp、smtp等)直接使用明文传输
 	- TLS(Transport Layer Security，安全传输层)将应用层的报文进行加密后再交由TCP进行传输
 	- TLS 在SSL v3.0 的基础上，提供了一些增强功能，两者差别很小
 	- TLS的作用
 		- 保密性，信息加密传输(对称加密)
 		- 完整性，MAC检验(散列函数)
 		- 认证，双方都可以配备证书，防止身份被冒充
 	- TLS过程
 		- C端获得S端的证书
 		- C端生成一个随机的AES口令，然后用S端的公钥通过RSA加密这个口令，并发给S端
 		- S端用自己的RSA私钥解密得到AES口令
 		- 双方使用这个共享的AES口令用AES加密通信
 	- TLS证书
 		- TLS 通过两个证书来实现服务端身份验证，以及对称密钥的安全生成
 			- CA 证书: 浏览器/操作系统自带，用于验证服务端的 TLS 证书的签名，保证服务端证书可信
 			- TLS 证书: 客户端和服务端使用 TLS 证书进行协商，以安全地生成一个对称密钥
 		- 证书，是非对称加密中的公钥，加上一些别的信息组成的一个文件
 		- 通过权威CA机构验证证书主人的真实身份
 			- 验证签名
 				- 私钥加密，公钥解密
 		- 证书来源
 			- 向权威CA机构申请证书需要收费(也有短期免费的)
 			- 若所有通信全部在自家网站或APP内完成可以使用本地签名证书(即自己生成CA证书)
 				- 编写证书签名请求的配置文件csr.conf，指定加密算法、授信域名、申请者信息等，规范参考(openssl.org)
 				- 生成server的TLS证书私钥
 					openssl genrsa -out server.key 2048
 				- 根据第1步的配置文件，生成证书签名请求(公钥加申请者信息)
 					openssl req -new -key server.key -out server.csr -config csr.conf
 				- 生成CA的私钥
 					openssl genrsa -out ca.key 2048
 				- 生成CA证书，有效期1000天
 					openssl req -x509 -new -nodes -key ca.key -subj "/CN=MaGeCA" -days 1000 -out ca.crt
 				- 签名，得到server的TLS证书，有效其365天
 					- 包含四部分: 公钥+申请者信息 + 颁发者(CA)的信息 + 签名(使用 CA 私钥加密)
 						openssl x509 -req -in server.csr -CA ca.crt -CAkey ca.key  -CAcreateserial -out server.crt -days 365  -extensions v3_ext -extfile csr.conf
 		- 服务端安装TLS证书
 			- 编辑Nginx配置文件 
 				$ vim /etc/nginx/nginx.conf 
 				# Settings for a TLS enabled server.
 				server {
 					listen       443;
 					server_name  july.go.edu;                     // 填写自己的域名
 					ssl_certificate "/path/to/server.crt";        // 填写刚生成的TLS证书（包含公钥）
 					ssl_certificate_key "/path/to/server.key";    // 填写刚生成的TLS证书私钥
 				}
 			- 使Nginx重新加载配置文件 nginx -s reload
 		- 客户端安装TLS证书
 			- 将服务端的TLS证书添加到 OS 的默认证书列表中
 				- linux
 					sudo cp server.crt /usr/local/share/ca-certificates/server.crt 
 					sudo update-ca-certificates
 				- mac
 					- 打开钥匙串，把刚刚生成的server.crt 拖到证书一栏里
 			- 编程: 使用 HTTPS 客户端的 api 指定使用的 TLS 证书
 - WebSocket协议
	- 与http的异同
		- 通信方式
			- http 客户端和服务端每次通信，都需要进行客户端请求(如 POST/GET)，服务端返回的流程
			- websocket 客户端和服务端再进行握手确认后，直接使用全双工的方式进行通信，最后断开连接
		- 相似和关联
			- 都是应用层协议，基于tcp传输协议
			- 跟http有良好的兼容性，websocket和http的默认端口都是80，websockets和https的默认端口都是443
			- websocket在握手阶段采用http发送数据
		- 差异
			- http是半双工，而websocket通过多路复用实现了全双工
			- http只能由client主动发起数据请求，而websocket还可以由server主动向client推送数据
				- 在需要及时刷新的场景中，http只能靠client高频地轮询，浪费严重
			- http是短连接(也可以实现长连接，HTTP1.1的连接默认使用长连接)，每次数据请求都得经过三次握手重新建立连接，而websocket是长连接
			- http长连接中每次请求都要带上header，而websocket在传输数据阶段不需要带header
	- websocket握手协议
		- Request Header
			Sec-Websocket-Version:13
			Upgrade:websocket
			Connection:Upgrade
			Sec-Websocket-Key:duR0pUQxNgBJsRQKj2Jxsw==
		- Response Header
			Upgrade:websocket
			Connection:Upgrade
			Sec-Websocket-Accept:a1y2oy1zvgHsVyHMx+hZ1AYrEHI=
		- 特点
			- Upgrade:websocket 和 Connection:Upgrade 指明使用WebSocket协议
			- Sec-WebSocket-Version 指定Websocket协议版本
			- Sec-WebSocket-Key是一个Base64 encode的值，是浏览器随机生成的
			- 服务端收到Sec-WebSocket-Key后拼接上一个固定的GUID，进行一次SHA-1摘要，再转成Base64编码，得到Sec-WebSocket-Accept返回给客户端
				- 客户端对本地的Sec-WebSocket-Key执行同样的操作跟服务端返回的结果进行对比，如果不一致会返回错误关闭连接
				- 该操作把websocket header跟http header区分开
	- WebSocket/CS架构
		- 引用第三方包
			go get github.com/gorilla/websocket
		- 服务端需要将 http协议升级到 WebSocket协议
			func (u *Upgrader) Upgrade(w http.ResponseWriter, r *http.Request, responseHeader http.Header) (*websocket.Conn, error)	
		- 客户端发起握手，请求连接
			func (*websocket.Dialer) Dial(urlStr string, requestHeader http.Header) (*websocket.Conn, *http.Response, error)
	- Go语言中的标准库 "net/http"
		- http.Serve                                                                 // 启动http服务
			func Serve(l net.Listener, handler Handler) error
		- http.ListenAndServe                                                        // net.Listen和 http.Serve两步合成一步
			func ListenAndServe(addr string, handler Handler) error
		- http.Handler                                                               // 需要实现Handler接口
			type Handler interface {
				ServeHTTP(ResponseWriter, *Request)
			}
			func (ws *WsServer) ServeHTTP(w http.ResponseWriter, r *http.Request)
		- http.HandleFunc
			func HandleFunc(pattern string, handler func(ResponseWriter, *Request))
		- http.ServeFile                                                             // ServeFile用命名文件或者目录的内容，回复请求
			func ServeFile(w ResponseWriter, r *Request, name string)
	- Go语言中的第三方库 "github.com/gorilla/websocket"
		- Upgrader结构体
			type Upgrader struct {
				HandshakeTimeout time.Duration                                                 // websocket握手超时时间
				ReadBufferSize, WriteBufferSize int                                            // io操作的缓存大小
				Error func(w http.ResponseWriter, r *http.Request, status int, reason error)   // http错误响应函数
				CheckOrigin func(r *http.Request) bool                                         // 用于统一的链接检查，以防止跨站点请求伪造
			}
		- websocket发送的消息类型有5种：TextMessag, BinaryMessage, CloseMessag, PingMessage, PongMessage
		- TextMessag 和 BinaryMessage 分别表示发送文本消息和二进制消息
		- CloseMessage 关闭帧，接收方收到这个消息就关闭连接
		- PingMessage和PongMessage是保持心跳的帧
			- 发送方 -> 接收方是PingMessage
			- 接收方 -> 发送方是PongMessage
			- 目前浏览器没有相关api发送ping给服务器，只能由服务器发ping给浏览器，浏览器返回pong消息
	- 示例 聊天室实现
	
3、Http编程
 - Http协议
	- Http: 超文本传输协议 Hyper Text Transfer Protocol
		- Http属于应用层协议，它在传输层用的是tcp协议
		- 无状态，对事务处理没有记忆能力(对比TCP协议里的确认号)
			- 如果要保存状态需要引用其他技术，如cookie
		- 无连接，每次连接只处理一个请求
			- 早期带宽和计算资源有限，这么做是为了追求传输速度快，后来通过Connection: Keep-Alive实现长连接
			- http1.1废弃了Keep-Alive，默认支持长连接
	- Http Request
		- Request报文结构
			| 请求方法 | 空格 | URL | 空格 | 协议版本 | \r | \n |      // 请求行
			|      字段名     |  :  |        值       | \r | \n |      // 请求头
			                         ...
			|      字段名     |  :  |        值       | \r | \n |
			| \r | \n |                                                // 空行
			|                        正文                       |
		- 请求方法
			- http 1.0
				- GET      请求获取Request-URI所标识的资源 
				- POST     向URI提交数据(例如提交表单或上传数据)
				- HEAD     类似于GET，返回的响应中没有具体的内容，用于获取报头
			- http 1.1
				- PUT      对服务器上已存在的资源进行更新
				- DELETE   请求服务器删除指定的页面
				- CONNECT  HTTP/1.1预留，能够将连接改为管道方式的代理服务器
				- OPTIONS  查看服务端性能
				- TRACE    回显服务器收到的请求，主要用于测试或诊断
				- PATCH    同PUT，可只对资源的一部分更新，资源不存在时会创建
			- 注意
				- 实际中server对各种request method的处理方式可能不是按协议标准来的
					- server收到PUT请求时执行DELETE操作
					- 仅用一个GET方法也能实现增删改查的全部功能
				- 大多数浏览器只支持GET和POST
		- URL
			- URI: uniform resource identifier，统一资源标识符，用来标识唯一的一个资源
			- URL: uniform resource locator，统一资源定位器，它是一种具体的URI，指明了如何locate这个资源
			- 示例
				https://baijiahao.baidu.com/s?id=1603848351636567407&wfr=spider&for=pc
				协议    域名                  参数
				http://www.qq.com:8080/news/tech/43253.html?id=432&name=f43s#pic
				协议   域名       端口 路径      文件名     参数             锚点
		- 协议版本
			- HTTP/1.0
			- HTTP/1.1
		- 请求头
			- Header字段解释及示例
				Accept           指定客户端能够接收的内容类型，如 Accept: text/plain, text/html
				Accept-Charset   浏览器可以接受的字符编码集，如 Accept-Charset: iso-8859-5
				Accept-Encoding  指定浏览器可以支持的web服务器返回内容压缩编码类型，如 Accept-Encoding: compress, gzip
				Accept-Language  浏览器可接受的语言，如 Accept-Language: en,zh
				Authorization    HTTP授权的授权证书，如 Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==
				Cache-Control    指定请求和响应遵循的缓存机制，如 Cache-Control: no-cache
				Connection       表示是否需要持久连接(HTTP 1.1默认进行持久连接)，如 Connection: close
				Cookie           HTTP请求发送时，会把保存在该请求域名下的所有cookie值一起发送给web服务器，如 Cookie: $Version=1; Skin=new;
				Content-Length   请求的内容长度，如 Content-Length: 348
				Content-Type     指定正文(body)的数据格式，如 Content-Type: application/x-www-form-urlencoded
				Date             请求发送日期和时间
				User-Agent       浏览器信息，如 Mozilla/5.0 (Windows NT 6.1; Win64; x64)
			- Content-Type
				- application/x-www-form-urlencoded
					- 浏览器的原生form表单，如果不设置 Content-Type 属性，则默认以 application/x-www-form-urlencoded 方式传输数据
					- 正文示例: name=manu&message=this_is_great
				- multipart/form-data
					- 上传文件时使用multipart/form-data，支持多种文件格式
					- 正文示例: name="text"name="file"; filename="chrome.png"Content-Type: image/png... content of chrome.png
				- application/json
					- JSON数据格式
					- 正文示例: {"title":"test","sub":[1,2,3]}
				- application/xhtml+xml
					- XHTML格式
				- application/xml
					- XML数据格式
				- application/pdf
					- pdf格式
				- application/msword
					- word文档格式
				- application/octet-stream
					- 二进制流数据
				- text/xml
					- 正文示例: <?xml version="1.0"?><methodCall>    <methodName>examples.getStateName</methodName>    </methodCall>
				- text/html
					- HTML格式
				- text/plain
					- 纯文本格式
				- image/gif
					- gif图片格式
				- image/jpeg
					- jpg图片格式
				- image/png
					- png图片格式
		- 请求正文
			- GET请求没有请求正文
			- POST可以包含GET
				POST /post?id=1234&page=1 HTTP/1.1
				Content-Type: application/x-www-form-urlencoded
				
				name=manu&message=this_is_great
			- GET和POST的区别
				- get的请求参数全部在url里，参数变时url就变
					- post可以把参数放到请求正文里，参数变时url不变
				- http协议并没有对url和请求正文做长度限制，但在实际中浏览器对url的长度限制到比请求正文要小很多
					- 所以post可以提交的数据比get要大得多
				- get比post更容易受到攻击(源于get的参数直接暴露在url里)
	- Http Response
		- Response报文结构
			| 协议版本 | 状态码 | 原因话术 | \r | \n |      // 相应行
			|  字段名  |    :   |    值    | \r | \n |      // 相应头
							    ...
			|  字段名  |    :   |    值    | \r | \n |
			| \r | \n |                                     // 空行
			|                响应正文                |
		- 状态码及话术
			- Code\Phrase
				200 Ok                      请求成功
				400 Bad Request             客户端有语法错误，服务端不理解
				401 Unauthorized            请求未经授权
				403 Forbidden               服务端拒绝提供服务
				404 Not Found               请求资源不存在
				500 Internal Server Error   服务器发生不可预期的错误
				503 Server Unavailable      服务器当前有问题，过段时间可能恢复
		- 响应头
			- Header字段解释及示例
				Allow              对某网络资源的有效的请求行为，如 Allow: GET, HEAD
				Date               原始服务器消息发出的时间，如 Date: Tue, 15 Nov 2010 08:12:31 GMT
				Content-Encoding   服务器支持的返回内容压缩编码类型，如 Content-Encoding: gzip
				Content-Language   响应体的语言，如 Content-Language: en,zh
				Content-Length     响应体的长度，如 Content-Length: 348
				Cache-Control      指定请求和响应遵循的缓存机制，如 Cache-Control: no-cache
				Content-Type       返回内容的MIME类型，如 Content-Type: text/html; charset=utf-8
		- 响应正文
			- Http Response示例
				HTTP/1.1 200 OK 
				Date: Fri, 22 May 2009 06:07:21 GMT 
				Content-Type: text/html; charset=UTF-8 
				
				<html>                                  // 响应正文
					<head></head>
					<body>
						<!--body goes here--> 
					</body> 
				</html>
	- Https
		- http:  (应用层)HTTP -> TCP -> IP
		- https: (应用层)HTTP -> SSL/TCP -> TCP -> IP
			HTTP + 加密 + 认证 + 完整性保护 = HTTPS(HTTP Secure)
 - Go语言中的标准库 "net/http"
	- http server
		func HelloHandler(w http.ResponseWriter, r *http.Request) {
			fmt.Fprint(w, "Hello Boy") // 把返回的内容写入http.ResponseWriter
		}
		func main() {
			http.HandleFunc("/", HelloHandler)  // 路由，请求要目录时去执行HelloHandler  
			// ListenAndServe如果不发生error会一直阻塞
			// 为每一个请求创建一个协程去处理
			http.ListenAndServe(":5656", nil)
		}
	- http client
		if resp, err := http.Get("http://127.0.0.1:5656"); err != nil {
			panic(err)
		} else {
			// 注意一定要调用resp.Body.Close()，否则会协程泄漏(同时引发内存泄漏)
			defer resp.Body.Close() 
			io.Copy(os.Stdout, resp.Body) // 把resp.Body输出到标准输出流
		}
	- http router
		- Go语言中的第三方库 "github.com/julienschmidt/httprouter"
			- go get -u github.com/julienschmidt/httprouter
			- Router实现了http.Handler接口
			- 为各种request method提供了便捷的路由方式
			- 支持restful请求方式
			- 支持ServeFiles访问静态文件
			- 可以自定义捕获panic的方法
	- 关于请求校验的常见问题
		- XSS
			- 跨站脚本攻击(Cross-site scripting，XSS)是一种安全漏洞，即通过注入脚本获取敏感信息
				- 攻击者可以利用这种漏洞在网站上注入恶意的客户端代码
				- 当被攻击者登陆网站时就会自动运行这些恶意代码，从而攻击者可以突破网站的访问权限，冒充受害者
		- CSRF
			- 跨站请求伪造(Cross-site request forgery，CSRF)是一种冒充受信任用户，向服务器发送非预期请求的攻击方式
			- 例如，这些非预期请求可能是通过在跳转链接后的 URL 中加入恶意参数来完成
		- jsonp  // 跨域
			- 主流浏览器不允许跨域访问数据(端口不同也属于跨域)
			- <script>标签的src属性不受同源策略限制
			- 通过script的src请求返回的数据，浏览器会当成js脚本去处理
				- 所以服务端可以返回一个在客户端存在的js函数
			- https://www.ruanyifeng.com/blog/2016/04/cors.html
		- validator
			- Go语言中的第三方库 "github.com/go-playground/validator"
				- go get github.com/go-playground/validator
					type RegistRequest struct {
						UserName string `validate:"gt=0"` // >0 长度大于0
						PassWord string `validate:"min=6,max=12"` //密码长度[6, 12]
						PassRepeat string `validate:"eqfield=PassWord"` //跨字段相等校验
						Email string `validate:"email"` //需要满足email的格式
					}
			- 范围约束
				- 对于字符串、切片、数组和map，约束其长度: len=10, min=6, max=10, gt=10
				- 对于数值，约束其取值: min, max, eq, ne, gt, gte, lt, lte, oneof=6 8
			- 跨字段约束
				- 跨字段就在范围约束的基础上加field后缀
				- 如果还跨结构体(cross struct)就在跨字段的基础上在field前面加cs
					- 范围约束 cs, field
			- 字符串约束
				- contains包含子串
				- containsany包含任意unicode字符，containsany=abcd
				- containsrune包含rune字符，containsrune=☻
				- excludes不包含子串
				- excludesall不包含任意的unicode字符，excludesall=abcd
				- excludesrune不包含rune字符，excludesrune=☻
				- startswith以子串为前缀
				- endswith以子串为后缀
			- 唯一性uniq
				- 对于数组和切片，约束没有重复的元素
				- 对于map，约束没的重复的value
				- 对于元素类型为结构体的切片，unique约束结构体对象的某个字段不重复，通过unqiue=field指定这个字段名
				- Friends []User `validate:"unique=Name"`
			- 自定义约束
				func validateEmail(fl validator.FieldLevel) bool {
					input := fl.Field().String()
					if pass, _ := regexp.MatchString(`^([\w\.\_]{2,10})@(\w{1,})\.([a-z]{2,4})$`, input); pass {
						return true
					}
					return false
				}
				//注册一个自定义的validator
				val.RegisterValidation("my_email", validateEmail)
				Email string `validate:"my_email"`
	- http中间件
		- 中间件的作用
			- 将业务代码和非业务代码解耦
			- 非业务代码: 限流、超时控制、打日志等等
		- 中间件的实现原理
			- 传入一个http.Handler，外面套上一些非业务功能代码，再返回一个http.Handler
			- 支持中间件层层嵌套
			- 通过HandlerFunc把一个func(rw http.ResponseWriter, r *http.Request)函数转为Handler
				func timeMiddleWare(next http.Handler) http.Handler {
					return http.HandlerFunc(func(rw http.ResponseWriter, r *http.Request) {
						begin := time.Now()
						next.ServeHTTP(rw, r)
						timeElapsed := time.Since(begin)
						log.Printf("request %s use %d ms\n", r.URL.Path, timeElapsed.Milliseconds())
					})
				}
 - Go语言中的Http框架
	- 自定义Web框架
		- 框架的作用
			- 节省封装的开发时间，统一各团队的编码风格，节省沟通和排查问题的时间
		- Web框架需要具备的功能
			- request参数获取
			- 参数校验 validator
			- 路由 httprouter
			- response生成和渲染
			- 中间件
			- 会话管理
		- Gorilla工具集
			- mux       一款强大的HTTP路由和URL匹配器
			- websocket 一个快速且被广泛应用的WebSocket实现
			- sessions  支持将会话跟踪信息保存到Cookie或文件系统
			- handler   为http服务提供很多有用的中间件
			- schema    表单数据和go struct互相转换
			- csrf      提供防止跨站点请求攻击的中间件
	- Gin框架
		- Gin是一款高性能的、简单轻巧的Http Web框架
			go get -u github.com/gin-gonic/gin
		- 路由
			- Gin的路由是基于httprouter做的
			- 支持GET, POST, PUT, PATCH, DELETE, OPTIONS, HEAD
			- 支持路由分组，不用重复写上级路径
		- 参数获取
			c.Query()         从GET请求的URL中获取参数
			c.Param()         从Restful风格的url中获取参数
			c.PostForm()      从post表单中获取参数
			c.FormFile()      获取上传的文件，消息类型为form-data
			c.MultipartForm() multipart/form-data可以上传多个form-data 并且用分隔符进行分割
		- 参数绑定
			type Student struct {
				Name string `form:"username" json:"name" uri:"user" xml:"user" yaml:"user" binding:"required"`
				Addr string `form:"addr" json:"addr" uri:"addr" xml:"addr" yaml:"addr" binding:"required"`
			}
			var stu Student
			ctx.ShouldBindJSON(&stu)
		- Gin生成response
			c.String()   response Content-Type= text/plain
			c.JSON()     response Content-Type= application/json
			c.XML()      response Content-Type= application/xml
			c.HTML()     前端写好模板，后端往里面填值
			c.Redirect() 重定向
		- Gin参数校验
			- 基于go-playground/validator
				type Student struct {
					Name string `form:"name" binding:"required"` // required:必须上传name参数
					Score int `form:"score" binding:"gt=0"` // score必须为正数
					Enrollment time.Time `form:"enrollment" binding:"required,before_today" time_format:"2006-01-02" time_utc:"8"` // 自定义验证before_today，日期格式东8区
					Graduation time.Time `form:"graduation" binding:"required,gtfield=Enrollment" time_format:"2006-01-02" time_utc:"8"` // 毕业时间要晚于入学时间
				}
		- Gin中间件
			// 全局MiddleWare
			engine.Use(timeMiddleWare()) 
			// 局部MiddleWare
			engine.GET("/girl", limitMiddleWare(), func(c *gin.Context) {
				c.String(http.StatusOK, "hi girl")
			})
			- 丰富的第三方中间件 gin-gonic/contrib (github.com)
		- Gin会话
			- http是无状态的，即服务端不知道两次请求是否来自于同一个客户端
			- Cookie由服务端生成，发送给客户端，客户端保存在本地
			- 客户端每次发起请求时把Cookie带上，以证明自己的身份
			- HTTP请求中的Cookie头只会包含name和value信息(服务端只能取到name和value)，domain、path、expires等cookie属性是由浏览器使用的，对服务器来说没有意义
			- Cookie可以被浏览器禁用
	- Beego框架
		- beego简介
			beego是一个大而全的http框架，用于快速开发go应用程序
			bee工具提供诸多命令，帮助进行 beego 项目的创建、热编译、开发、测试、和部署
			beego的八大模块互相独立，高度解耦，开发者可任意选取
			日志模块
			ORM模块
			Context模块  封装了request和response
			Cache模块    封装了memcache、redis、ssdb
			Config模块   解析.ini、.yaml、.xml、.json、.env等配置文件
			httplib模块
			Session模块  session保存在服务端，用于标识客户身份，跟踪会话
			toolbox模块  健康检查、性能调试、访问统计、计划任务
		- 用bee工具创建web项目
			go get github.com/astaxie/beego
			go get github.com/beego/bee
			cd $GOPATH/src
			bee new myweb
			cd myweb
			go build -mod=mod
			bee run
		- MainController
			type MainController struct { //继承自beego.Controller
				beego.Controller //beego.Controller里有Get、Post、Put等方法
			}
			func (c *MainController) Get() {
				c.Data["Website"] = "github.com/Orisun"
				c.Data["Email"] = zhchya@gmail.com
				//TplName是需要渲染的模板  .tpl经常被用来表示PHP模板
				c.TplName = "index.tpl”
				//Resquest和ResponseWriter都在beego.Controller.Ctx里
				fmt.Println("remote addr", c.Ctx.Request.RemoteAddr)
				//如果指定了response正文，就不会去渲染index.tpl了
				c.Ctx.WriteString("Hi boy") 
			}
		- MVC
			- View 前端页面
			- Controller 处理业务逻辑
			- Model 把Controller层重复的代码抽象出来
				- 在Model层可以使用beego提供的ORM功能


九、数据库
1、SQL语法简介
 - MySQL初始配置
	- SQL(i/ˈsiːkwəl/; Structured Query Language)是一套语法标准，不区分大小写
	- MySQL、sql-server和Oracle都是关系型数据库，在一些高级语法上跟标准SQL略有出入
	- Linux安装MySQL客户端   yum install mysql
	- 安装MySQL服务端        yum install mysql-server
	- 启动MySQL服务端        systemctl start mysqld.service
	- 以root登录             mysql -uroot
		- SQL管理员创建账号      create user 'tester' identified by '123456';
		- 查看账号创建是否成功   select host, user from mysql.user where user='tester';
		- 赋予账号对应权限       grant create, insert on *.* to 'tester';    // grant <privileges> on <database>.<table> to 'tester'@'localhost';
		                         grant all privileges on *.* to '用户名'@'%' identified by '密码' with grant option;  // 这里表示赋予该用户所有数据库所有表(*.*表示所有表)，%表示所有IP地址
	- 以tester登录           mysql -utester -p'123456' -h121.40.150.39 -P9528
		- 创建database           create database test;
		- 使用database           use test;                        // show tables;
			- 示例一
				create table if not exists student(
				id int not null auto_increment comment '主键自增id',
				name char(4) not null comment '姓名',
				province char(6) not null comment '省',
				city char(10) not null comment '城市',
				addr varchar(100) default '' comment '地址',
				score float not null default 0 comment '考试成绩',
				enrollment date not null comment '入学时间',
				primary key (id),  unique key idx_name (name),  
				key idx_location (province,city)
				)default charset=utf8 comment '学员基本信息';
			- 示例二
				show variables like 'innodb_large_prefix';
				show variables like 'innodb_file_format';
				set global innodb_large_prefix=1;
				set global innodb_file_format=BARRACUDA;
				CREATE TABLE `resource` (
				`id` char(64) CHARACTER SET latin1 NOT NULL,
				`vendor` tinyint(1) NOT NULL,
				`region` varchar(64) CHARACTER SET latin1 NOT NULL,
				`zone` varchar(64) CHARACTER SET latin1 NOT NULL,
				`create_at` bigint(13) NOT NULL,
				`expire_at` bigint(13) DEFAULT NULL,
				`category` varchar(64) CHARACTER SET latin1 NOT NULL,
				`type` varchar(120) CHARACTER SET latin1 NOT NULL,
				`instance_id` varchar(120) CHARACTER SET latin1 NOT NULL,
				`name` varchar(255) NOT NULL,
				`description` varchar(255) DEFAULT NULL,
				`status` varchar(255) CHARACTER SET latin1 NOT NULL,
				`update_at` bigint(13) DEFAULT NULL,
				`sync_at` bigint(13) DEFAULT NULL,
				`sync_accout` varchar(255) CHARACTER SET latin1 DEFAULT NULL,
				`public_ip` varchar(64) CHARACTER SET latin1 DEFAULT NULL,
				`private_ip` varchar(64) CHARACTER SET latin1 DEFAULT NULL,
				`pay_type` varchar(255) CHARACTER SET latin1 DEFAULT NULL,
				`describe_hash` varchar(255) NOT NULL,
				`resource_hash` varchar(255) NOT NULL,
				PRIMARY KEY (`id`),
				KEY `name` (`name`) USING BTREE,
				KEY `status` (`status`) USING HASH,
				KEY `private_ip` (`private_ip`) USING BTREE,
				KEY `public_ip` (`public_ip`) USING BTREE,
				KEY `instance_id` (`instance_id`) USING HASH
				) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
		- 查看索引  // https://blog.csdn.net/shaochenshuo/article/details/51064685
			show index from student\G;
		- 新增记录
			- 必须给not null且无default值的列赋值
				insert into student (name,province,city,enrollment) values
				('张三','北京','北京','2021-03-05'),
				('李四','河南','郑州','2021-04-25'),
				('小丽','四川','成都','2021-03-10');
		- 查询记录
			select id,name from student where id>0;
			select province,avg(score) as avg_score from student 
				where score>0 
				group by province having avg_score>50 
				order by avg_score desc;
			select * from student order by c1 asc, c2 desc;    // 先按列 c1 升序排列，再按 c2 降序排列
		- 修改记录
			update student set score=score+10,addr='海淀' where province='北京';
			update student set
				score=case province
					when '北京' then score+10     
					when '四川' then score+5 
					else score+7
				end,
				addr=case province
					when '北京' then '东城区'        
					when '四川' then '幸福里'        
					else '朝阳区'    
				end
			where id>0;
		- 删除记录
			delete from student where city= '郑州';
			delete from student;    --删除表里的所有行
			drop table student;     --删除表
 - MySQL相关概念
	- 注意事项
		- 注意存储引擎的选择(InnoDB)
		- 主键选择 和 唯一键考虑清楚
		- 考虑数据类型与长度，选择合适的类型，避免空间浪费
		- 字符串注意确认字符集, 如果需要存入中文, 请选择utf8编码
		- 为过滤条件的字段 添加索引
		- 高频组合查询可以考虑 联合索引
		- 注意选择使用索引的方法: Hash Btree Normal
		- 写sql时一律使用小写
		- 建表时先判断表是否已存在  if not exists 
		- 所有的列和表都加 comment
			- comment 是备注、注释的意思，写上comment 'id'之后，在建表信息里可以看到添加的备注信息
		- 字符串长度比较短时尽量使用char，定长有利于内存对齐，读写性能更好，而varchar字段频繁修改时容易产生内存碎片
		- 满足需求的前提下尽量使用短的数据类型，如tinyint vs int, float vs double, date vs datetime
		- null
			- default null有别于 default '' 和 default 0
			- is null, is not null有别于 != '', !=0
			- 尽量设为 not null
				- 有些DB索引列不允许包含null
				- 对含有null的列进行统计，结果可能不符合预期
				- null值有时候会严重拖慢系统性能
	- B+树
		- B即Balance，对于m叉树每个节点上最多有m个数据，最少有m/2个数据(根节点除外)
		- 叶节点上存储了所有数据，把叶节点链接起来可以顺序遍历所有数据
		- 每个节点设计成内存页的整倍数；MySQL的 m=1200，树的前两层放在内存中
		- 示例
			                2  28 65
			                P1 P2 P3
				    |          |         |
				2  13 20   28 35 56   65 80 90
				P1 P2 P3   P1 P2 P3   P1 P2 P3
				|  |  |    |  |  |    |  |  | 
				2  13 20   28 35 56   65 80 90
				8  15 23   30 38 60   73 85 96
				9  19 27   32 50 63   79 88 99
				Q  Q  Q    Q  Q  Q    Q  Q  Q   // data 
	- 索引
		- MySQL索引默认使用B+树
			- 散列表(Hash table，也叫哈希表) 与 B+树
				- Hash table 查询时间为 O(1)，但是其对范围查询的支持不如 B+树
				- 即Hash table只支持等于或不等于，不支持关键词检索
		- 主键默认会加索引
			- 按主键构建的B+树里包含所有列的数据，而普通索引的B+树里只存储了主键，还需要再查一次主键对应的B+树(回表)
			- 使用 explain命令 查看一个SQL语句的执行计划，如使用的索引，是否做全表扫描等
		- 联合索引的前缀同样具有的索引的效果
		- sql语句前加explain可以查看索引使用情况
		- 如果MySQL没有选择最优的索引方案，可以在where前force index (index_name)
		- 规避慢查询
			- 大部分的慢查询都是因为没有正确地使用索引
			- 一次select不要超过1000行
			- 分页查询limit m,n 会检索前m+n行，只是返回后n行，通常用id>x来代替这种分页方式
			- 批量操作时最好一条sql语句搞定；其次打包成一个事务，一次性提交(高并发情况下减少对共享资源的争用)
			- 不要使用连表操作，join逻辑在业务代码里完成
	- Go语言中SQL驱动接口
		- database/sql
			- Go官方没有提供数据库驱动，而是为开发数据库驱动定义了一些标准接口(即database/sql)，开发者可以根据定义的接口来开发相应的数据库驱动
			- Go语言中支持MySQL的驱动比较多，如
				github.com/go-sql-driver/mysql  支持 database/sql
				github.com/ziutek/mymysql       支持 database/sql，支持自定义的接口
				github.com/Philio/GoMySQL     不支持 database/sql，支持自定义的接口
		- Driver
			// driver.Driver
			package driver // import "database/sql/driver"
			type Driver interface { 
				Open(name string) (Conn, error)                        // func Open(driverName, dataSourceName string) (*DB, error)
			}
			- 注册数据库驱动
				var d = Driver{proto: "tcp", raddr: "127.0.0.1:3306"}
				sql.Register("mysql", &d)                              // func Register(name string, driver driver.Driver)
			- 打开数据库连接
				db, err := sql.Open("mysql", "root:@tcp(localhost:3306)/test?charset=utf8")
		- Conn
			// driver.Conn
			type Conn interface {
				Prepare(query string) (Stmt, error)                    // func (db *DB) Prepare(query string) (*Stmt, error)
				Close() error                                          // func (c *Conn) Close() error
				Begin() (Tx, error)                                    // func (db *DB) Begin() (*Tx, error)
			}
			- 把一个查询query传给Prepare，返回Stmt(statement)
			- Close关闭数据库连接
			- Begin返回一个事务Tx(transaction)
		- Stmt
			// driver.Stmt
			type Stmt interface {
				Close() error                                          // func (s *Stmt) Close() error
				NumInput() int
				Exec(args []Value) (Result, error)                     // func (s *Stmt) Exec(args ...interface{}) (Result, error)
				Query(args []Value) (Rows, error)                      // func (s *Stmt) Query(args ...interface{}) (*Rows, error)
			}
			- Close关闭当前的链接状态
			- NumInput返回当前预留参数的个数
			- Exec执行Prepare准备好的 sql，传入参数执行 update/insert 等操作，返回 Result 数据
			- Query执行Prepare准备好的 sql，传入需要的参数执行 select 操作，返回 Rows 结果集
		- Tx
			// driver.Tx
			type Tx interface {
				Commit() error                                          // func (tx *Tx) Commit() error
				Rollback() error                                        // func (tx *Tx) Rollback() error
			}
			- Commit提交事务
			- Rollback回滚事务
		- Result
			// driver.Result
			type Result interface {
				LastInsertId() (int64, error)
				RowsAffected() (int64, error)
			}
			- LastInsertId返回由数据库执行插入操作得到的自增ID号
			- RowsAffected返回操作影响的数据条目数
			- RowsAffected
				- RowsAffected是int64的别名，它实现了Result接口
					type RowsAffected int64
					func (RowsAffected) LastInsertId() (int64, error)
					func (v RowsAffected) RowsAffected() (int64, error)
		- Rows
			// driver.Rows
			type Rows interface {
				Columns() []string                             // func (rs *Rows) Columns() ([]string, error)
				Close() error                                  // func (rs *Rows) Close() error
				Next(dest []Value) error                       // func (rs *Rows) Next() bool
			}
			- Columns是查询所需要的表字段
			- Close关闭迭代器
			- Next返回下一条数据，把数据赋值给dest，dest里面的元素必须是driver.Value的值
				- 如果最后没有数据，Next 函数返回 io.EOF
		- Value
			// driver.Value
			type Value interface{}
				nil           // 要么是 nil，要么是下面的任意一种
				int64 
				float64 
				bool 
				[]byte 
				string 
				time.Time
		- driver.ValueConverter
			type ValueConverter interface {
				ConvertValue(v interface{}) (Value, error)
			}
			- 把数据库里的数据类型转换成Value允许的数据类型
	- Go语言中 数据库的操作
		- 增删改查
			- Go语言中的第三方库
				go get github.com/go-sql-driver/mysql
			- 连接数据库
				db, err := sql.Open("mysql", "root:@tcp(localhost:3306)/test?charset=utf8")
			- 增删改
				func (*sql.DB).Exec(sql string) (sql.Result, error)
			- 查
				func (*sql.DB).Query(sql string) (*sql.Rows, error)
		- Stmt
			- 参数化查询
				db.Where("merchant_id = ?", merchantId)
			- 拼接sql
				db.Where(fmt.Sprintf("merchant_id = %s", merchantId))
			- 定义一个sql模板
				stmt, err := db.Prepare("update student set score=score+? where city=?")
			- 多次使用模板
				res, err := stmt.Exec(10, "上海")
				res, err = stmt.Exec(9, "深圳") 
	- 数据库使用问题
		- SQL注入
			- 问题现象
				- sql = "select username,password from user where username='" + username + "' and password='" + password + "'"; 
					- 变量username和password从前端输入框获取，如果用户输入的username为lily， password为aaa' or '1'='1
					- 则完整的sql为select username,password from user where username='lily' and password='aaa' or '1'='1'
					- 会返回表里的所有记录，如果记录数大于0就允许登录，则lily的账号被盗
				- sql = "insert into student (name) values ('"+username+"')";
					- 变量username从前端输入框获取，如果用户输入的username为lily'); drop table student;--
					- 完整sql为insert into student (name) values ('lily'); drop table student;--')
					- 通过注释符--屏蔽掉了末尾的')，删除了整个表
			- 预防措施
				- 前端输入要加正则校验、长度限制
				- 对特殊符号(<>&*; '"等)进行转义或编码转换，Go的text/template 包里面的HTMLEscapeString函数可以对字符串进行转义处理
				- 不要将用户输入直接嵌入到sql语句中，而应该使用参数化查询接口，如Prepare、Query、Exec(query string, args ...interface{})
				- 使用专业的SQL注入检测工具进行检测，如sqlmap、SQLninja
				- 避免网站打印出SQL错误信息，以防止攻击者利用这些错误信息进行SQL注入
		- SQL预编译
			- DB执行SQL分为3步
				- 词法和语义解析
				- 优化 SQL 语句，制定执行计划
				- 执行并返回结果
			- SQL 预编译技术是指将用户输入用占位符?代替，先对这个模板化的sql进行预编译，实际运行时再将用户输入代入
			- 除了可以防止 SQL 注入，还可以对预编译的SQL语句进行缓存，之后的运行就省去了解析优化SQL语句的过程

2、ORM与NoSQL技术
 - SQLBuilder
	- Go语言中的第三方库
		- Go-SQLBuilder是一个用于创建SQL语句的工具函数库，提供一系列灵活的、与原生SQL语法一致的链式函数，归属于艾润物联公司
				go get -u github.com/parkingwang/go-sqlbuilder
			- 函数链
				sql := gsb.NewContext().
					Select("id", "name", "score", "city").
					From("student").
					OrderBy("score").DESC().                  // 按"score"降序
					Column("name").ASC().                     // 当"score"相同，按"name"升序
					Limit(10).Offset(20).                     // 从第20个开始，读10个 limit 20, 10
					ToSQL()
		- Gendry是一个用于辅助操作数据库的Go包，基于go-sql-driver/mysql，它提供了一系列的方法来为调用标准库database/sql中的方法准备参数
				go get –u github.com/didi/gendry
			- map
				where := map[string]interface{}{
					"city": []string{"北京", "上海", "杭州"},
					"score<": 30,
					"addr": builder.IsNotNull,
					"_orderby": "score desc",
				}
				fields := []string{"id", "name", "city", "score"}
				_, _, err := builder.BuildSelect("student", where, fields)
	- 自行封装SQL构建器
		- 写一句很长的sql容易出错，且出错后不好定位
		- 函数式编程可以直接定位到是哪个函数的问题
		- 函数式编程比一长串sql更容易编写和理解
		- github.com/ahwhy/myGolang/blob/main/week12/database/self_sql_builder/main.go
 - ORM技术与GORM
	- ORM
		- ORM 即 Object Relational Mapping，对象关系映射
		- Relational指各种sql类的关系型数据为
		- Object指面向对象编程(object-oriented programming)中的对象
		- ORM在数据库记录和程序对象之间做一层映射转换，使程序中不用再去编写原生SQL，而是面向对象的思想去编写类、对象、调用相应的方法来完成数据库操作
	- GORM
		- go get -u gorm.io/gorm
		- go get -u gorm.io/driver/mysql
		- GORM是一个全能的、友好的、基于golang的ORM库
		- GORM 倾向于约定，而不是配置
			- 默认情况下，GORM 使用 ID 作为主键，使用结构体名的 蛇形复数 作为表名，字段名的 蛇形 作为列名，并使用 CreatedAt、UpdatedAt 字段追踪创建、更新时
				dsn := "root:@tcp(127.0.0.1:3306)/test?charset=utf8mb4&parseTime=True"   // data source name
				db, err := gorm.Open(mysql.Open(dsn), &gorm.Config{})
				student := Student{Name: "光绪", Province: "北京", City: "北京", Score: 38, Enrollment: time.Now()}
				db.Create(&student)
				- 完全是在操作struct，看不到sql的影子
 - MongoDB
	- 相关概念
		- NoSQL泛指非关系型数据库，如 mongodb, redis, HBase
		- mongo使用高效的二进制数据存储，文件存储格式为BSON(一种json的扩展，比json性能更好，功能更强大)
		- MySQL中表的概念在mongo里叫集合(collection)， MySQL中行的概念在mongo中叫文档(document)，一个文档看上去像一个json
	- 安装MongoDB
		- $ vim /etc/yum.repos.d/mongodb-org-4.2.repo
			[mongodb-org-4.2] 
			name=MongoDB Repository
			baseurl=https://repo.mongodb.org/yum/redhat/$releasever/mongodb-org/4.2/x86_64/
			gpgcheck=1
			enabled=1
			gpgkey=https://www.mongodb.org/static/pgp/server-4.2.asc
		- $ yum install -y mongodb-org
		- $ systemctl start mongod.service
	- MongoDB常用命令
		$ mongo
		use test;                                                                                // 切换到test库，如果没有则创建
		db.createUser({user: "tester", pwd: "123456", roles: [{role: "dbAdmin", db: "test"}]});  // 创建用户
		db.createCollection("student");                                                          // 创建collection
		db.student.createIndex({"name":1});                                                      // 在name上创建索引,不是唯一索引
		db.student.insertOne({name:"张三",city:"北京"});
		db.student.find({name:"张三"});
		db.student.update({name:"张三"},{name:"张三",city:"上海"});
		db.student.deleteOne({name:"张三"});
	- Go语言中 MongoDB的操作
		- 安装mongo-driver
			go get go.mongodb.org/mongo-driver
			go get go.mongodb.org/mongo-driver/x/bsonx/bsoncore@v1.7.1
			go get go.mongodb.org/mongo-driver/x/mongo/driver@v1.7.1
			go get go.mongodb.org/mongo-driver/mongo/options@v1.7.1
			go get go.mongodb.org/mongo-driver/x/mongo/driver/topology@v1.7.1
			go get go.mongodb.org/mongo-driver/mongo@v1.7.1
		- 连接MongoDB
			option := options.Client().ApplyURI("mongodb://127.0.0.1:27017").
			SetConnectTimeout(time.Second).                                                         // 连接超时时长
			SetAuth(options.Credential{Username: "tester", Password: "123456", AuthSource: "test"}) // 指定用户名和密码，AuthSource代表Database
			client, err := mongo.Connect(context.Background(), option)
			err = client.Ping(ctx, nil) 
			- 注意: Ping成功才代表连接成功
		- 查询MongoDB
			sort := bson.D{{"name", 1}}                                 // 1升序，-1降序
			filter := bson.D{{"score", bson.D{{"$gt", 3}}}} //score>3   // greater than
			findOption := options.Find()
			findOption.SetSort(sort)                                    // 按name排序
			findOption.SetLimit(10)                                     // 最多返回10个
			findOption.SetSkip(3)                                       // 跳过前3个
			cursor, err := collection.Find(ctx, filter, findOption)
	

十、其他类型
1、进程的内存结构
	0xc0000000  内核虚拟内存         <-- 内核使用
	0x40000000      栈区             <-- 程序运行时用于存放局部变量，可向下延伸空间
	            共享库的内存映像
	                堆区             <-- 程序运行时用于分配mallco和new申请的区域
	            可读写区(.data .bss) <-- 存放全局变量和静态变量
	0x08048000     只读区            <-- 存放程序和常量等
	        0      未使用
				     
2、常用包与函数  // 标准库 https://studygolang.com/pkgdoc
1).time
	time.Now()          // 获取当前时间
	time.Now().Unix()
	time.Now().Year()   // Month() Day()  Hour()  Minute()  Second()
	time.Now().Format("2006-01-02 15:04:05")
	time.Parse()        // 返回转换后的时间格式和一个判断信息（err)
	time.Sleep(1 * time.Second)
	time.Unix(time.Now().Unix(), 0).Format("2006-01-02 15:04:05")
2).math包
 - math/rand
	- rand.Seed(time.Now().Unix())  // 使用当前时间设置随机数种子
	- rand.Intn(100)    // 生产[0, 100)的随机数
 - math.IsNaN
	- 用于测试一个数是否是非数NaN     // NaN非数，一般用于表示无效的除法操作结果0/0或Sqrt(-1)
 - math.NaN
	- 返回非数对应的值
3).reflect
	reflect.TypeOf() 获取数据类型 // 同Printf("%T")
	reflect.ValueOf()
4).os
	os文件处理，见上
	*os.PathError           // PathError records an error and the operation and file path that caused it.
	*os.LinkError           // LinkError records an error during a link or symlink or rename system call and the paths that caused it.
	*os.SyscallError        // SyscallError records an error from a specific system call.
	os.Esxit(1) 系统退出
	os.Args                 // 接收命令行参数生成切片，从程序本身的路径开始 var os.Args []string
	os.Stat("test.txt")     // func os.Stat(name string) (fs.FileInfo, error)  Stat returns a FileInfo describing the named file. If there is an error, it will be of type *PathError.
5).strings  // 见上字符串
	strings.FieldsFunc()  // 将字符串进行分段，返回切片 func strings.FieldsFunc(s string, f func(rune) bool) []string
	strings.Contains()    // func Contains(s, substr string) bool  判断字符串s中是否存在对应字符substr
	strings.ToLower()     // func ToLower(s string) string         将字符串统一转成小写
	strings.NewReader("")     // 从字符串创建一个reader对象
	strings.Reader.Reader()   // func (*strings.Reader).Read(b []byte) (n int, err error)
6).errors
	errors.New() // 创建错误 或使用 fmt.Errorf() 
7).sort
	type StringSlice []string
	func sort.Strings(x []string)
	func sort.Sort(data sort.Interface)
8).flag
	flag.Parse()           // 解析命令行参数
	flag.IntVar()          // 设置int类型参数
	flag.BoolVar()		   // 设置bool类型参数
	flag.StringVar()       // 设置string类型参数    func flag.StringVar(p *string, name string, value string, usage string)
	flag.PrintDefaults()   // 获取自动生成的参数信息
9).crypto
	a、crypto/md5
		md5.Sum([]byte(""))     // 计算byte切片中字符的MD5
		md5.New()               // 解码
	b、crypto/sha1
		sha1.Sum([]byte(""))    // 计算byte切片中字符消息摘要(Hash)
		sha256.Sum([]byte(""))
		sha512.Sum([]byte(""))
		sha256.Sum256([]byte(""))
10).encoding/base64
	base64.stdEncoding.EncodeToString([]byte(""))     // 计算byte切片中字符的base64加密
	base64.StdEncoding.DecodeString()                 // 计算base64解码
	base64.RawStdEncoding.EncodeToString([]byte(""))  // 计算byte切片中字符的base64加密且不使用=填充
	base64.URLEncoding.EncodeToString([]byte(""))     // 计算byte切片中字符的url加密
	encoding/gob
	encoding/csv
	encoding/json
11).log
	log.Printf("aa")  // 2021/07/04 15:32:10 aa  
12).sync    // 见上Go中的锁
	sync.Mutex 互斥锁
	sync.RWMutex 读写锁
	sync.Map
	sync.WaitGroup(计数信号量)
13).runtime
14).bufio  // 提供缓冲流的功能,具体见上
	bufio.NewScanner(os.Stdin)
15).io 
	func io.Copy(dst io.Writer, src io.Reader) (written int64, err error)
16).io/ioutil
17).gopkg.in/yaml.v2
	yaml.Unmarshal()
18).net/http
	http.StatusOK
19).github.com/gin-gonic/gin               // http客户端
20).github.com/go-playground/validator     // 校验参数的包
21).github.com/spf13/cobra                 // cmd命令行客户端       
22).github.com/AlecAivazis/survey          // 隐藏密码
23).github.com/schollz/progressbar         // 进度条
24).github.com/BurntSushi/toml             // toml解析库，解析配置文件
25).github.com/caarlos0/env                // 环境变量解析库，解析环境变量
25).github.com/rs/xid                      // ID生成器库