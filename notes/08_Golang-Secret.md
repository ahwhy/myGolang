# Golang-Secret  Golang的加解密

## 一、密码学&&Go语言的加解密

### 1. 定义
- 密码学的目的
	- 保密性、数据完整性、身份验证

- 密码学的应用
	- 保密通信、数字签名、秘密共享、认证功能、密钥管理

- 加密算法种类
	- 散列算法、对称加密算法、非对称加密算法、秘钥交换算法
	
### 2. Hash 散列算法
- 散列是信息的提炼
	- 通常其输入可以是任意长度，长度往往要比信息小得多，且为一个固定长度
	- 加密性强的散列一定是不可逆的，即通过散列结果，无法推出任何部分的原始信息 --> 单向性
	- 任何输入信息的变化，哪怕仅一位，都将导致散列结果的明显变化 --> 雪崩效应
	- 散列还应该是防冲突的，即找不出具有相同散列结果的两条信息 --> 唯一性
	- 具有这些特性的散列结果就可以用于验证信息是否被修改 --> 保证数据完整性

- 单向散列函数一般用于产生消息摘要，密钥加密等
	- MD5(Message Digest Algorithm 5  信息-摘要算法5): 是RSA数据安全公司开发的一种单向散列算法
		- 目前已被破解
		- Go语言中，由 `crypto/md5` 包实现
	- SHA(Secure Hash Algorithm  安全散列算法): 可以对任意长度的数据运算生成一个160位的数值
		- SHA-1是一种数据加密算法，防伪装，防窜扰，保证信息的合法性和完整性
		- 接收一段明文，然后以一种不可逆的方式将它转换成一段(通常更小)密文
		- 或理解为取一串输入码(称为预映射或信息)，并把它们转化为长度较短、位数固定的输出序列即散列值(也称为信息摘要或信息认证代码)的过程
		- 该算法输入报文的最大长度不超过264位，产生的输出是一个160位的报文摘要，且输入是按512位的分组进行处理的
		- SHA-1是不可逆的、防冲突，并具有良好的雪崩效应
		- SHA-1是SHA家族的五个算法之一(其它四个是SHA-224、SHA-256、SHA-384，和SHA-512)
		- Go语言中，由 `crypto/sha1` 包实现
	- HMAC
		- Hmac算法也是一种哈希算法，它可以利用MD5或SHA1等哈希算法
		- 不同的是，Hmac需要一个密钥，只要密钥发生了变化，那么同样的输入数据也会得到不同的签名，即用随机数"增强"的哈希算法
		- Go语言中，由 `crypto/hmac` 包实现
	- Bcrypt
		- 适合Password Hash
		- bcrypt也一种加盐的Hash方法
			- MD5 Hash时候，同一个报文经过hash的时候生成的是同一个hash值，在大数据的情况下，有些经过md5 hash的方法将会被破解(碰撞)
			- 使用BCrypt进行加密，同一个密码每次生成的hash值都是不相同的
			- 每次加密的时候首先会生成一个随机数就是盐，之后将这个随机数与报文进行hash，得到一个hash值
			- Bcrypt有四个变量：
				- saltRounds: 正数，代表hash杂凑次数，数值越高越安全，默认10次
				- myPassword: 明文密码字符串
				- salt: 盐，一个128bits随机字符串，22字符
				- myHash: 经过明文密码password和盐salt进行hash，比如默认10次下，循环加盐hash10次，得到myHash
		- Go语言中，由 `golang.org/x/crypto/bcrypt` 包实现

- 应用
	- 用户密码的存储和校验
	- 文件上传/下载完整性校验
	- mysql大字段的快速对比

### 3. 对称加密算法
- 对称加密算法用来对敏感数据等信息进行加密
	- 加密过程的每一步都是可逆的
	- 加密和解密用的是同一组密钥
	- 异或是最简单的对称加密算法

- 对称加密种类
	- 分组密码，也叫块加密(block cyphers)，一次加密明文中的一个块
		- 将明文按一定的位长分组，明文组经过加密运算得到密文组，密文组经过解密运算(加密运算的逆运算)，还原成明文组
		- 模式: ECB、CBC、CFB、OFB、CTR、CFR
			- CBC(Cipher Block Chaining)/密文分组链接方式
				- 加密步骤
					- 首先将数据按照8个字节一组进行分组得到D1D2......Dn（若数据不是8的整数倍，用指定的PADDING数据补位）
					- 第一组数据D1与初始化向量I 异或后的结果进行DES加密得到第一组密文C1(初始化向量I为全零)
					- 第二组数据D2与第一组的加密结果C1异或以后的结果进行DES加密，得到第二组密文C2
					- 之后的数据以此类推，得到Cn
					- 按顺序连为C1C2C3......Cn即为加密结果
				- 解密步骤 -> 加密的逆过程
					- 首先将数据按照8个字节一组进行分组得到C1C2C3......Cn
					- 将第一组数据进行解密后与初始化向量I进行异或得到第一组明文D1(注意：一定是先解密再异或)
					- 将第二组数据C2进行解密后与第一组密文数据进行异或得到第二组数据D2
					- 之后依此类推，得到Dn
					- 按顺序连为D1D2D3......Dn即为解密结果
						- 解密的结果并不一定是原来的加密数据，可能还得补位，要把补位去掉才是原来的数据
		- 特点
			- 不容易主动攻击，安全性好于ECB，适合传输长度长的报文，是SSL、IPSec的标准
				- 每个密文块依赖于所有的信息块，明文消息中一个改变会影响所有密文块
			- 发送方和接收方都需要知道初始化向量
			- 加密过程是串行的，无法被并行化(在解密时，从两个邻接的密文块中即可得到一个平文块；因此，解密过程可以被并行化)
	- 序列密码，也叫流加密(stream cyphers)，一次加密明文中的一个位
		- 利用少量的密钥(制乱元素)通过某种复杂的运算(密码算法)产生大量的伪随机位流，用于对明文位流的加密

- 常用的算法
	- DES(Data Encryption Standard): 数据加密标准，一种使用密钥加密的块算法，速度较快，适用于加密大量数据的场合
		- DES是目前最为流行的加密算法之一
		- 对原始数据(明文)进行分组，每组64位，最后一组不足64位时按一定规则填充
		- 每一组上单独施加DES算法
	- 3DES(Triple DES): 是基于DES，对一块数据用三个不同的密钥进行三次加密，强度更高
	- AES(Advanced Encryption Standard): 高级加密标准，是下一代的加密算法标准，速度快，安全级别高
		- 算法原理
			- AES算法基于排列和置换运算
				- 排列是对数据重新进行安排
				- 置换是将一个数据单元替换为另一个
				- AES 使用几种不同的方法来执行排列和置换运算。
			- AES是一个迭代的、对称密钥分组的密码，它可以使用128、192 和 256 位密钥，并且用 128 位(16字节)分组加密和解密数据
				- 与公共密钥密码使用密钥对不同，对称密钥密码使用相同的密钥加密和解密数据
				- 通过分组密码返回的加密数据的位数与输入数据相同
				- 迭代加密使用一个循环结构，在该循环中重复置换和替换输入数据
		- Go语言中，由 `crypto/aes` 包实现

### 4. 非对称加密算法
- 常用于数据加密和身份认证

- 常见的非对称加密算法
	- DSA(Digital Signature Algorithm): 数字签名算法，是一种标准的DSS(数字签名标准)
		- 基于整数有限域离散对数难题，其安全性与RSA相比差不多
		- DSA的一个重要特点是两个素数公开，因此当使用他人的p和q时，即使不知道私钥，也能确认它们是否是随机产生的，还是作了手脚
		- RSA算法却做不到，但是其缺点就是只能用于数字签名，不能用于加密
		- Go语言中，由crypto/des包实现
	- RSA: 由RSA公司发明，是一个支持变长密钥的公共密钥算法，需要加密的文件块的长度也是可变的
		- 目前最有影响力的公钥加密算法，能够抵抗到目前为止已知的绝大多数密码攻击，已被ISO推荐为公钥数据加密标准
		- Ron Rivest，Adi Shamir，Leonard Adleman
		- 密钥越长，越难破解
			- 目前768位的密钥还无法破解(至少没人公开宣布)
			- 因此可以认为1024位的RSA密钥基本安全，2048位的密钥极其安全
		- RSA的算法原理主要用到了数论
		- Go语言中，由crypto/rsa包实现
	- ECC(Elliptic Curves Cryptography): 椭圆曲线密码编码学
		- 基于椭圆曲线的离散对数难题
			- 给定椭圆曲线上的一个点P，一个整数k，求解 Q = kP 很容易
			- 给定一个点P、Q，知道 Q = kP，求整数 k 是一个难题
		- 背景
			- 目前只有短的RSA钥匙才可能被强力方式解破
			- 到2008年为止，世界上还没有任何可靠的攻击RSA算法的方式
			- 只要其钥匙的长度足够长，用RSA加密的信息实际上是不能被解破的
			- 随着分解大整数方法的进步及完善、计算机速度的提高以及计算机网络的发展，为了保障数据的安全，RSA的密钥需要不断增加
			- 但是，密钥长度的增加导致了其加解密的速度大为降低，硬件实现也变得越来越难以忍受，这对使用RSA的应用带来了很重的负担，因此需要一种新的算法来代替RSA
		- ECC与RSA的比较
			- 抗攻击性强
			- 计算量小，处理速度快
			- 存储空间占用小
			- 带宽要求低
	- ECDSA(Elliptic Curve Digital Signature Algorithm): 基于椭圆曲线的DSA签名算法
		- DSA在数字签名的安全性高，基于ECC的DSA更高，所以非常适合数字签名使用场景，在SSH TLS有广泛使用
		- Go语言中，由 `crypto/ecdsa` 包实现
			- 在golang的ssh库中就是使用这个算法来签名
				- A使用自己的私钥签名一段数据，然后将公钥发放出去
				- 用户拿到公钥后，验证数据的签名，如果通过则证明数据来源是A，从而达到身份认证的作用

### 5. 秘钥交换算法
- 一种密钥交换协议，该算法只能用于密钥的交换，而不能进行消息的加密和解密
	- 双方确定要用的密钥后，要使用其他对称密钥操作加密算法实际加密和解密消息
	- 可以让双方在不泄漏密钥的情况下协商出一个密钥来，常用于保证对称加密的秘钥的安全，比如 TLS

- 有两种类型
	- DH: Diffie-Hellman, 一种确保共享KEY安全穿越不安全网络的方法，是OAKLEY的一个组成部分
	- ECDH: Elliptic Curve Diffie-Hellman, DH算法的加强版，基于椭圆曲线难题加密，现在是主流的密钥交换算法
		- 常用的是NIST系列，但是后面curve25519更为优秀
		- curve25519: 实质上也是一种ECDH，但是其实现更为优秀，表现的更为安全，可能是下一代秘钥交换算法的标准
		- Go语言中
			- 由crypto库实现了P224/P256/P384/P521
			- curve25519则不在标准库中: `golang.org/x/crypto/curve25519`